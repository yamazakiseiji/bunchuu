SH SERIES C/C++ Compiler (V.9.02.00.003)                                                         08-Sep-2023 13:46:33  PAGE    1

************ OBJECT LISTING ************

FILE NAME: C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\mnet.c

SCT OFFSET   CODE       C LABEL     INSTRUCTION OPERAND    COMMENT

               mnet.c          1    /******************************************************************************
               mnet.c          2    * モーションネット管理タスク                                                  *
               mnet.c          3    *                                                                             *
               mnet.c          4    * File name : mnet.c                                                          *
               mnet.c          5    *                                                                             *
               mnet.c          6    * Copyright (c) 2018 NICHIRYO Co., Ltd.                                       *
               mnet.c          7    *                                                                             *
               mnet.c          8    ******************************************************************************/
               mnet.c          9    #include <kernel.h>
               mnet.c         10    #include "iodefine.h"
               mnet.c         11    #include "define.h"
               mnet.c         12    #include "datastruct.h" 
               mnet.c         13    #include "mnet.h"
               mnet.c         14    #include "sub.h"
               mnet.c         15    #include "automachine.h"
               mnet.c         16    #include "macro.h"
               mnet.c         17    
               mnet.c         18    
               mnet.c         19    // *****************************************************
               mnet.c         20    //  コンパイルスイッチ
               mnet.c         21    // *****************************************************
               mnet.c         22    #define WAIT_TYPE_IFB 1   // 定義:IFBフラグ監視
               mnet.c         23    #define WAIT_END_CHK  1   // 定義:完了待ちﾙｰﾌﾟ
               mnet.c         24    #define WAIT_TYPE_RW  1   // 定義:RWディレイ
               mnet.c         25    
               mnet.c         26    #define DEBUG_INFO                1       // ☆ 1 = DEBUG用, 0 = 製品用
               mnet.c         27    
               mnet.c         28    
               mnet.c         29    // *****************************************************
               mnet.c         30    //  関数定義
               mnet.c         31    // *****************************************************
               mnet.c         32    ER    MntInit( void );
               mnet.c         33    BOOL pio_Init();
               mnet.c         34    BOOL motor_Init(void);
               mnet.c         35    
               mnet.c         36    void pio_ALLIN(UB *data);
               mnet.c         37    UB pio_BIN(UB ch);
               mnet.c         38    void pio_BOUT(UB ch, UB sw);
               mnet.c         39    void pio_PATOUT(UB sw1, UB sw2, UB sw3);
               mnet.c         40    ER motor_POWER(UB pm, UB sw);
               mnet.c         41    ER motor_LIMIT(UB mm, UB dr, UB md, INT sp );
               mnet.c         42    ER motor_SCAN(UB pm, UH dir);
               mnet.c         43    ER motor_SET(UB pm, ST_MOTOR_PARAM mp);
               mnet.c         44    ER motor_PSET(UB pm, INT cnt, INT enc, INT def);
               mnet.c         45    ER motor_ABSMV(UB pm, INT pos, UB status);
               mnet.c         46    ER motor_RELMV(UB pm, INT pos, UB status);
               mnet.c         47    ER motor_STOP(UB pm);
               mnet.c         48    ER motor_ABORT(UB pm);
               mnet.c         49    ER motor_STATUS(UB pm, ST_MOTOR_STATUS *status);
               mnet.c         50    
               mnet.c         51    static BOOL WriteMemory(INT addr, UH data);
               mnet.c         52    static BOOL WriteMemoryInt(INT addr, INT data);
               mnet.c         53    static BOOL ReadMemory(INT addr,  UH *data);
               mnet.c         54    static BOOL SetMainCommand(UH command);
               mnet.c         55    static BOOL GetMainStatus(MNETStatus* status);
               mnet.c         56    
               mnet.c         57    // PCD4611 ---
               mnet.c         58    static void WriteMemoryPCD4611(UB data);
               mnet.c         59    static void WriteMemoryIntPCD4611(INT data);
               mnet.c         60    static INT  ReadMemoryPCD4611();
               mnet.c         61    // PCD4611 ---
               mnet.c         62    
               mnet.c         63     BOOL SetMotorRegisterInt(UB dev_no, UH reg, INT value);//★
               mnet.c         64    //static BOOL SetMotorRegisterInt(UB dev_no, UH reg, INT value);
               mnet.c         65    static BOOL SetMotorRegister(UB dev_no, UH reg, UH value);
               mnet.c         66           BOOL GetMotorStatus(UB dev_no, MotorStatus* status);
               mnet.c         67    static BOOL GetMotorSubStatus(UB dev_no, MNETSubStatus* substs);
               mnet.c         68    static BOOL SetMainRegister(UH reg, UH data);
               mnet.c         69           BOOL IsExist(UB dev_no);
               mnet.c         70    static BOOL SetMotorCommand(UB dev_no, UH command);
               mnet.c         71           BOOL   GetMotorRegister(UB dev_no, UH reg, INT* value);
               mnet.c         72    static ER   motor_SetAllRegister(UB pm);
               mnet.c         73    static ER   motor_CalcMotorReg(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg);
               mnet.c         74    static ER motor_CalcMotorRegPCD4611(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg);
               mnet.c         75    static void motor_RegistCommand(UB pm, UH cmd);
               mnet.c         76           void g_Sleep(INT usec);
               mnet.c         77    static void ClearInterrupt(void);
               mnet.c         78    static BOOL IfbIdleWait(void);    // ＩＦＢアイドリング待ち
               mnet.c         79    static BOOL ChkIFB( void );       // ＩＦＢ状態取得
               mnet.c         80    static BOOL EndIdleWait(void);    // 完了待ち
               mnet.c         81    static BOOL ChkEnd( void );       // エンド状態取得
               mnet.c         82    static BOOL motor_InitController(void);
               mnet.c         83    static UB ChkRbsy( void );
               mnet.c         84    static UB ChkDbsy( void );
               mnet.c         85    static UB ChkSbsy( void );
               mnet.c         86    
               mnet.c         87    
               mnet.c         88    
               mnet.c         89    static ER SetRenv1Fu( UB dev_no );                // RENV1 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         90    static ER SetRenv1PCD4611( UB dev_no );           // 
               mnet.c         91    static ER SetRenv2Fu( UB dev_no, UB teibai ); // RENV2 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         92    static ER SetRenv2PCD4611( UB dev_no, UB teibai );
               mnet.c         93    static ER SetRenv3Fu( UB dev_no, UB enc );        // RENV3 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         94    static ER SetRmdFu( UB dev_no, UB mod );      // RMD   設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         95    static ER SetRmv( UB dev_no, INT pos );           // RMV   設定
               mnet.c         96    static ER SetRmvPCD4611( UB dev_no, INT pos );
               mnet.c         97    void  check_main_pulsemotor_initialize( );
               mnet.c         98    
               mnet.c         99    #ifdef DEBUG_INFO
               mnet.c        100    static void DebugMnetInfo( UB mm );
               mnet.c        101    #endif
               mnet.c        102    static ER SetRenv3PCD4611( UB dev_no, UB enc );
               mnet.c        103    static ER SetRmdPCD4611( UB dev_no, UB mod );
               mnet.c        104    
               mnet.c        105    
               mnet.c        106    /***********************************************************************
               mnet.c        107    * 構造体
               mnet.c        108    ***********************************************************************/
               mnet.c        109    
               mnet.c        110    
               mnet.c        111    
               mnet.c        112    /***********************************************************************
               mnet.c        113    * テーブル
               mnet.c        114    ***********************************************************************/
               mnet.c        115    
               mnet.c        116    static const INT MOTORSPD_TBL[10] = {
               mnet.c        117      1999,
               mnet.c        118       999,
               mnet.c        119       399,
               mnet.c        120       199,
               mnet.c        121        99,
               mnet.c        122        39,
               mnet.c        123        19,
               mnet.c        124         9,
               mnet.c        125         3,
               mnet.c        126         2
               mnet.c        127    };
               mnet.c        128    static const INT MOTORSPD_TBL_PCD4611[10] = {
               mnet.c        129      3999,// 0.3
               mnet.c        130      2399,// 0.5
               mnet.c        131      1199,// 1
               mnet.c        132       599,// 2
               mnet.c        133       239,// 5
               mnet.c        134        59,// 10
               mnet.c        135        29,// 20
               mnet.c        136        14,// 50
               mnet.c        137         5,// 100
               mnet.c        138         2 // 200
               mnet.c        139    };
               mnet.c        140    
               mnet.c        141    // LIMITコマンド時のモード選択
               mnet.c        142    static const UB LMMOD_TBL[2][3] = {
               mnet.c        143    //    規定外   CW      CCW
               mnet.c        144      { MOD20  , MOD20,  MOD28 }, // GENTEN_POS
               mnet.c        145      { MOD22  , MOD22,  MOD2A }  // NUKEDA_POS
               mnet.c        146    };
               mnet.c        147    
               mnet.c        148    /***********************************************************************
               mnet.c        149    * データ定義
               mnet.c        150    ***********************************************************************/
               mnet.c        151    volatile struct   StMotionnet *pMotionnet;
               mnet.c        152    volatile struct   StPulseMotor    *pPulseMotor;
               mnet.c        153    
               mnet.c        154    
               mnet.c        155    static    ST_PM_INFO      _pmInfo[20];            // パルスモータ情報配列
               mnet.c        156    static    BOOL            Initialized = FALSE;    // 
               mnet.c        157    static    INT factor;
               mnet.c        158    static    INT param;
               mnet.c        159    static    INT RMG;
               mnet.c        160    static    INT RFL;
               mnet.c        161    static    INT RFH;
               mnet.c        162    static    INT RUR;
               mnet.c        163    static    INT RUS;
               mnet.c        164    static    INT RDS;
               mnet.c        165    
               mnet.c        166    #define   PULSEMOTOR_CMD_CUN1R    0x20            // カウンタリセット（COUNTER1）
               mnet.c        167    #define   PULSEMOTOR_CMD_CUN2R    0x21            // カウンタリセット（COUNTER2）
               mnet.c        168    #define   PULSEMOTOR_CMD_STOP     0x49            // 即停止
               mnet.c        169    #define   PULSEMOTOR_CMD_STAFL    0x50            // FL低速スタート
               mnet.c        170    #define   PULSEMOTOR_CMD_WPRFL    0x81            // [W] 初速度
               mnet.c        171    #define   PULSEMOTOR_CMD_WPRMG    0x85            // [W] 速度倍率
               mnet.c        172    #define   PULSEMOTOR_CMD_WPRMD    0x87            // [W] 動作モード
               mnet.c        173    #define   PULSEMOTOR_CMD_WRENV1   0x9C            // [W] 環境設定1
               mnet.c        174    #define   PULSEMOTOR_CMD_WRENV2   0x9D            // [W] 環境設定2
               mnet.c        175    #define   PULSEMOTOR_CMD_RRENV1   0xDC            // [R] 環境設定1
               mnet.c        176    #define   PULSEMOTOR_CMD_RCUN1    0xE3            // [R] COUNTER1（指令位置カウンタ）
               mnet.c        177    #define   PULSEMOTOR_CMD_RCUN2    0xE4            // [R] COUNTER2（機械位置カウンタ）
               mnet.c        178    #define   PULSEMOTOR_CMD_RREST    0xF2            // [R] エラー割り込み要因取得
               mnet.c        179    
               mnet.c        180    
               mnet.c        181    
               mnet.c        182    
               mnet.c        183    /******************************************************************************
               mnet.c        184    * 
               mnet.c        185    * [概要]
               mnet.c        186    * 
               mnet.c        187    * 
               mnet.c        188    * 
               mnet.c        189    ******************************************************************************/
               mnet.c        190    ER    MntInit( void )
P   00000000              _MntInit:                        ; function: MntInit
                                                           ; frame size=12
    00000000 4DF0                   MOVMU.L     R13,@-R15
               mnet.c        191    {
               mnet.c        192      BOOL    blnResult;
               mnet.c        193      UB      rtycnt = 0;
               mnet.c        194      int setValue;
               mnet.c        195    
               mnet.c        196      pMotionnet = (struct StMotionnet *)MNET_BASE_ADDRESS;
    00000002 D289                   MOV.L       L619,R2    ; H'0C008000
               mnet.c        197    
               mnet.c        198      blnResult = SetMainCommand(MNET_CENTER_RESET);              //  100h
    00000004 E401                   MOV         #1,R4      ; H'00000001
    00000006 D689                   MOV.L       L619+4,R6  ; _pMotionnet
    00000008 2622                   MOV.L       R2,@R6     ; pMotionnet
    0000000A B77C                   BSR         __$SetMainCommand
    0000000C 4418                   SHLL8       R4
               mnet.c        199    
               mnet.c        200      check_main_pulsemotor_initialize();// PCD4611 初期化追加
    0000000E B03F                   BSR         _check_main_pulsemotor_initialize
    00000010 0009                   NOP
    00000012 EE00                   MOV         #0,R14     ; H'00000000
    00000014              L11:
               mnet.c        201    
               mnet.c        202      // BUSY解除まで待つ
               mnet.c        203      while( ChkRbsy() ){};
    00000014 D386                   MOV.L       L619+8,R3  ; __$ChkRbsy
    00000016 434B                   JSR/N       @R3
    00000018 620C                   EXTU.B      R0,R2
    0000001A 2228                   TST         R2,R2
    0000001C 8BFA                   BF          L11
               mnet.c        204      
               mnet.c        205      blnResult = SetMainRegister(MNET_CENTER_WRENV0, 0x037F);    // 5500h
    0000001E E455                   MOV         #85,R4     ; H'00000055
    00000020 ED0A                   MOV         #10,R13    ; H'0000000A
    00000022 0500037F               MOVI20      #895,R5    ; H'0000037F
    00000026 B79E                   BSR         __$SetMainRegister
    00000028 4418                   SHLL8       R4
               mnet.c        206      blnResult = SetMainCommand(MNET_CMD_CLEAR_SEND_FIFO);       //  200h
    0000002A E402                   MOV         #2,R4      ; H'00000002
    0000002C B76B                   BSR         __$SetMainCommand
    0000002E 4418                   SHLL8       R4
               mnet.c        207      blnResult = SetMainCommand(MNET_CMD_CLEAR_RECV_FIFO);       //  300h
    00000030 E403                   MOV         #3,R4      ; H'00000003
    00000032 B768                   BSR         __$SetMainCommand
    00000034 4418                   SHLL8       R4
               mnet.c        208      blnResult = SetMainCommand(MNET_CENTER_SYSCOM);             // 1000h
    00000036 E410                   MOV         #16,R4     ; H'00000010
    00000038 B765                   BSR         __$SetMainCommand
    0000003A 4418                   SHLL8       R4
    0000003C              L13:
               mnet.c        209    
               mnet.c        210      // BUSY解除まで待つ
               mnet.c        211      while( 1)
               mnet.c        212      {
               mnet.c        213          if( ChkDbsy() == CLR ) break;
    0000003C D37D                   MOV.L       L619+12,R3 ; __$ChkDbsy
    0000003E 434B                   JSR/N       @R3
    00000040 620C                   EXTU.B      R0,R2
    00000042 2228                   TST         R2,R2
    00000044 8B19                   BF          L15
               mnet.c        214    
               mnet.c        215          rtycnt++;
               mnet.c        216          dly_tsk(DLY_1M);
               mnet.c        217    
               mnet.c        218          if( rtycnt > SYS_RTY_OVER )
               mnet.c        219          {
               mnet.c        220              return( E_CON_SYSCOM );
               mnet.c        221          }
               mnet.c        222      };
               mnet.c        223    
               mnet.c        224      // センター通信開始
               mnet.c        225      rtycnt = 0;
               mnet.c        226      blnResult = SetMainCommand(MNET_CENTER_STA_IOCOM);          // 3000h
    00000046 E430                   MOV         #48,R4     ; H'00000030
    00000048 EE00                   MOV         #0,R14     ; H'00000000
    0000004A B75C                   BSR         __$SetMainCommand
    0000004C 4418                   SHLL8       R4
    0000004E              L16:
               mnet.c        227      while(1)
               mnet.c        228      {
               mnet.c        229          if( ChkSbsy() ) break;
    0000004E D37A                   MOV.L       L619+16,R3 ; __$ChkSbsy
    00000050 434B                   JSR/N       @R3
    00000052 620C                   EXTU.B      R0,R2
    00000054 2228                   TST         R2,R2
    00000056 8905                   BT          L18
               mnet.c        230          rtycnt++;
               mnet.c        231          dly_tsk(DLY_1M);
               mnet.c        232    
               mnet.c        233          // BUSY解除されず
               mnet.c        234          if( rtycnt > SYS_RTY_OVER )
               mnet.c        235          {
               mnet.c        236              // 通信異常と判断
               mnet.c        237              return( E_CON_IO_COM );
               mnet.c        238          }
               mnet.c        239      }
               mnet.c        240      
               mnet.c        241      
               mnet.c        242      pio_Init();
    00000058 B0DD                   BSR         _pio_Init
    0000005A 0009                   NOP
               mnet.c        243      motor_Init();
    0000005C B044                   BSR         _motor_Init
    0000005E 0009                   NOP
               mnet.c        244    
               mnet.c        245      return( E_SUCCESS );
    00000060 A014                   BRA         L19
    00000062 E000                   MOV         #0,R0      ; H'00000000
    00000064              L18:
    00000064 7E01                   ADD         #1,R14
    00000066 D175                   MOV.L       L619+20,R1 ; _v4_dly_tsk
    00000068 410B                   JSR         @R1
    0000006A E401                   MOV         #1,R4      ; H'00000001
    0000006C 65EC                   EXTU.B      R14,R5
    0000006E 35D7                   CMP/GT      R13,R5
    00000070 00000441               MOVI20      #1089,R0   ; H'00000441
    00000074 890A                   BT          L19
    00000076 AFEA                   BRA         L16
    00000078 0009                   NOP
    0000007A              L15:
    0000007A 7E01                   ADD         #1,R14
    0000007C D66F                   MOV.L       L619+20,R6 ; _v4_dly_tsk
    0000007E 460B                   JSR         @R6
    00000080 E401                   MOV         #1,R4      ; H'00000001
    00000082 67EC                   EXTU.B      R14,R7
    00000084 37D7                   CMP/GT      R13,R7
    00000086 00000440               MOVI20      #1088,R0   ; H'00000440
    0000008A 8BD7                   BF          L13
    0000008C              L19:
    0000008C 4DF4                   MOVMU.L     @R15+,R13
               mnet.c        246    
               mnet.c        247    }
    0000008E 006B                   RTS/N
               mnet.c        248    //==============================================================================
               mnet.c        249    //    Function    : check_main_pulsemotor_initialize
               mnet.c        250    //    Description : メイン基板のパルスモータ検査の初期化
               mnet.c        251    //    Parameters  : なし
               mnet.c        252    //    Return      : なし
               mnet.c        253    //    Note        : 
               mnet.c        254    //    Global      : 
               mnet.c        255    //==============================================================================
               mnet.c        256    void  check_main_pulsemotor_initialize( )
    00000090              _check_main_pulsemotor_initialize:
                                                           ; function: check_main_pulsemotor_initialize
                                                           ; frame size=12
    00000090 4DF0                   MOVMU.L     R13,@-R15
               mnet.c        257    {
               mnet.c        258    //    int setValue;
               mnet.c        259      
               mnet.c        260      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000092 D26B                   MOV.L       L619+24,R2 ; H'0C009000
               mnet.c        261    
               mnet.c        262    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRFL, _pmInfo[MT_HEAD_Y0].reg[R1] );   // RFL
               mnet.c        263    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRFH, _pmInfo[MT_HEAD_Y0].reg[R2] );   // RFH
               mnet.c        264    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRUR, _pmInfo[MT_HEAD_Y0].reg[R3] );   // RUR
               mnet.c        265    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRDR, 0                           );   // RDR
               mnet.c        266    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRMG, _pmInfo[MT_HEAD_Y0].reg[R4] );   // RMG
               mnet.c        267    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRDP, 0                           );   // RDP
               mnet.c        268    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRDS, _pmInfo[MT_HEAD_Y0].reg[R9] );   // RDS
               mnet.c        269    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRMG, 1199                        );   // RMG
               mnet.c        270    #if 1
               mnet.c        271      SetMotorRegisterInt( MT_Y0, WRG_PRMG,   1199              );    // 
    00000094 E585                   MOV         #-123,R5   ; H'FFFFFF85
    00000096 D76B                   MOV.L       L619+28,R7 ; _pPulseMotor
    00000098 2722                   MOV.L       R2,@R7     ; pPulseMotor
    0000009A 655C                   EXTU.B      R5,R5
    0000009C EE01                   MOV         #1,R14     ; H'00000001
    0000009E 6D53                   MOV         R5,R13
    000000A0 060004AF               MOVI20      #1199,R6   ; H'000004AF
    000000A4 64E3                   MOV         R14,R4
               mnet.c        272      SetMotorRegisterInt( MT_Y0, WPCD_PRFL,  50                );    // 
    000000A6 B78A                   BSR         _SetMotorRegisterInt
    000000A8 7DFC                   ADD         #-4,R13
    000000AA E632                   MOV         #50,R6     ; H'00000032
    000000AC 64E3                   MOV         R14,R4
    000000AE 65D3                   MOV         R13,R5
               mnet.c        273      SetMotorRegisterInt( MT_Y0, WPCD_PRFH,  300               );    // 
    000000B0 B785                   BSR         _SetMotorRegisterInt
    000000B2 7D01                   ADD         #1,R13
    000000B4 E64B                   MOV         #75,R6     ; H'0000004B
    000000B6 64E3                   MOV         R14,R4
    000000B8 4608                   SHLL2       R6
    000000BA 65D3                   MOV         R13,R5
               mnet.c        274      SetMotorRegisterInt( MT_Y0, WPCD_PRUR,  500               );    // 
    000000BC B77F                   BSR         _SetMotorRegisterInt
    000000BE 7D01                   ADD         #1,R13
    000000C0 E67D                   MOV         #125,R6    ; H'0000007D
    000000C2 64E3                   MOV         R14,R4
    000000C4 4608                   SHLL2       R6
    000000C6 65D3                   MOV         R13,R5
               mnet.c        275      SetMotorRegisterInt( MT_Y0, WPCD_RENV2, 0x00000005        );    // 
    000000C8 B779                   BSR         _SetMotorRegisterInt
    000000CA 7D1A                   ADD         #26,R13
    000000CC E605                   MOV         #5,R6      ; H'00000005
    000000CE 65D3                   MOV         R13,R5
    000000D0 B775                   BSR         _SetMotorRegisterInt
    000000D2 64E3                   MOV         R14,R4
               mnet.c        276      WriteMemoryPCD4611 ( CMD_CUN1R );                           // CUN1R : 
    000000D4 B71D                   BSR         __$WriteMemoryPCD4611
    000000D6 E420                   MOV         #32,R4     ; H'00000020
               mnet.c        277      WriteMemoryPCD4611 ( CMD_CUN2R );                           // CUN2R : 
    000000D8 B71B                   BSR         __$WriteMemoryPCD4611
    000000DA E421                   MOV         #33,R4     ; H'00000021
               mnet.c        278    #endif
               mnet.c        279    
               mnet.c        280    #if 0
               mnet.c        281      WriteMemoryIntPCD4611( 1199 );
               mnet.c        282      WriteMemoryPCD4611( WPCD_PRMG );        // PRMG : 速度倍率設定
               mnet.c        283    
               mnet.c        284      WriteMemoryIntPCD4611( 50 );
               mnet.c        285      WriteMemoryPCD4611( WPCD_PRFL );        // PRFL : 初速設定
               mnet.c        286    
               mnet.c        287      WriteMemoryIntPCD4611( 300 );
               mnet.c        288      WriteMemoryPCD4611( WPCD_PRFH );        // PRFH : 高速設定
               mnet.c        289    
               mnet.c        290      WriteMemoryIntPCD4611( 500 );
               mnet.c        291      WriteMemoryPCD4611( WPCD_PRUR );        // PRUR : 
               mnet.c        292    
               mnet.c        293      WriteMemoryIntPCD4611( 500 );
               mnet.c        294      WriteMemoryPCD4611( WPCD_PRDR );        // PRDR : 
               mnet.c        295    
               mnet.c        296      WriteMemoryIntPCD4611( 0x00000005 );
               mnet.c        297      WriteMemoryPCD4611( WPCD_RENV2 );       // RENV2 : 
               mnet.c        298      
               mnet.c        299      WriteMemoryPCD4611( CMD_CUN1R );        // CUN1R : 
               mnet.c        300      WriteMemoryPCD4611( CMD_CUN2R );        // CUN2R : 
               mnet.c        301    #endif
               mnet.c        302    
               mnet.c        303    #if 0
               mnet.c        304      // PRMG : 速度倍率設定
               mnet.c        305      setValue = 1199;                            // 倍率 = 1
               mnet.c        306      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        307      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        308      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        309      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        310      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRMG;    // 0x85;
               mnet.c        311    
               mnet.c        312      // PRFL : 初速設定
               mnet.c        313      setValue = 50;                              // 初速設定 = 50[pps]
               mnet.c        314      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        315      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        316      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        317      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        318      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRFL;    // 0x81;
               mnet.c        319    
               mnet.c        320      // PRFH
               mnet.c        321      setValue = 300;
               mnet.c        322      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        323      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        324      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        325      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        326      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRFH;    // 0x82;
               mnet.c        327    
               mnet.c        328      // PRUR
               mnet.c        329      setValue = 500;
               mnet.c        330      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        331      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        332      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        333      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        334      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRUR;    // 0x83;
               mnet.c        335    
               mnet.c        336      // PRDR
               mnet.c        337      setValue = 500;
               mnet.c        338      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        339      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        340      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        341      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        342      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRDR;    // 0x84;
               mnet.c        343    
               mnet.c        344      // RENV2 : 環境設定2
               mnet.c        345      setValue = 0x00000005;                      // EA/EB: A/B相1逓倍, P1〜P0: 汎用出力
               mnet.c        346      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        347      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        348      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        349      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        350      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_RENV2;   // 0x9D
               mnet.c        351    #endif
               mnet.c        352      
               mnet.c        353      // 初期状態の設定
               mnet.c        354      // 汎用出力（"P0", "P1"）を"L"にする ... HOLDで可変
               mnet.c        355      pPulseMotor->unCmdSts.stWrite.OTPB = 0x00;
    000000DC D159                   MOV.L       L619+28,R1 ; _pPulseMotor
    000000DE 6E12                   MOV.L       @R1,R14    ; pPulseMotor
    000000E0 E000                   MOV         #0,R0      ; H'00000000
    000000E2 80E2                   MOV.B       R0,@(2,R14); (pPulseMotor)->OTPB
    000000E4 4DF4                   MOVMU.L     @R15+,R13
               mnet.c        356    }
    000000E6 006B                   RTS/N
               mnet.c        357    
               mnet.c        358    
               mnet.c        359    
               mnet.c        360    BOOL motor_Init(void)
    000000E8              _motor_Init:                     ; function: motor_Init
                                                           ; frame size=28
    000000E8 49F0                   MOVMU.L     R9,@-R15
    000000EA DE57                   MOV.L       L619+32,R14; H'0000007F+__$_pmInfo
    000000EC E9C8                   MOV         #-56,R9    ; H'FFFFFFC8
    000000EE 7E49                   ADD         #73,R14
    000000F0 699C                   EXTU.B      R9,R9
               mnet.c        361    {
               mnet.c        362      UB i;
               mnet.c        363    
               mnet.c        364      motor_InitController();
    000000F2 B02C                   BSR         __$motor_InitController
    000000F4 ED02                   MOV         #2,R13     ; H'00000002
    000000F6 EC00                   MOV         #0,R12     ; H'00000000
    000000F8 EA07                   MOV         #7,R10     ; H'00000007
    000000FA 0B000320               MOVI20      #800,R11   ; H'00000320
    000000FE              L22:
               mnet.c        365    
               mnet.c        366      for (i=DVMIN+1; i<=DVMAX; i++)
               mnet.c        367      {
               mnet.c        368          if (IsExist( i ))
    000000FE D353                   MOV.L       L619+36,R3 ; _IsExist
    00000100 430B                   JSR         @R3
    00000102 64D3                   MOV         R13,R4
    00000104 2008                   TST         R0,R0
    00000106 891A                   BT          L24
               mnet.c        369          {
               mnet.c        370              _pmInfo[i].factor           = 2;
               mnet.c        371              _pmInfo[i].pos              = 0;
               mnet.c        372              _pmInfo[i].power            = OFF;
               mnet.c        373              _pmInfo[i].paused           = FALSE;
               mnet.c        374              _pmInfo[i].command.code     = CMD_NOCOMMAND;
               mnet.c        375              _pmInfo[i].startParam       = CMD_NOTYPE;
               mnet.c        376    
               mnet.c        377              _pmInfo[i].reg[R0]          = 0;        // Pls
               mnet.c        378              _pmInfo[i].reg[R1]          = 200;      // RFL
               mnet.c        379              _pmInfo[i].reg[R2]          = 800;      // RFH
               mnet.c        380              _pmInfo[i].reg[R3]          = 500;      // RUR
    00000108 E17D                   MOV         #125,R1    ; H'0000007D
    0000010A E602                   MOV         #2,R6      ; H'00000002
    0000010C 4108                   SHLL2       R1
    0000010E 2E62                   MOV.L       R6,@R14    ; _pmInfo[].factor
    00000110 3EC12014               MOV.L       R12,@(80:12,R14); _pmInfo[].pos
    00000114 3EC1102A               MOV.W       R12,@(84:12,R14); _pmInfo[].power
    00000118 3EC12016               MOV.L       R12,@(88:12,R14); _pmInfo[].paused
    0000011C 3EC1102E               MOV.W       R12,@(92:12,R14); _pmInfo[].code
    00000120 3EC11030               MOV.W       R12,@(96:12,R14); _pmInfo[].startParam
    00000124 1EC9                   MOV.L       R12,@(36,R14); _pmInfo[].reg[]
               mnet.c        381              _pmInfo[i].reg[R4]          = 500;
               mnet.c        382              _pmInfo[i].reg[R5]          = 0;
               mnet.c        383              _pmInfo[i].reg[R6]          = 0;
               mnet.c        384              _pmInfo[i].reg[R7]          = 0;
               mnet.c        385    
               mnet.c        386              motor_PowerUp(i, _pmInfo[i].power);
    00000126 64DC                   EXTU.B      R13,R4
    00000128 1E9A                   MOV.L       R9,@(40,R14); _pmInfo[].reg[]
    0000012A 1EBB                   MOV.L       R11,@(44,R14); _pmInfo[].reg[]
    0000012C 1E1C                   MOV.L       R1,@(48,R14); _pmInfo[].reg[]
    0000012E 1E1D                   MOV.L       R1,@(52,R14); _pmInfo[].reg[]
    00000130 1ECE                   MOV.L       R12,@(56,R14); _pmInfo[].reg[]
    00000132 1ECF                   MOV.L       R12,@(60,R14); _pmInfo[].reg[]
    00000134 3EC12010               MOV.L       R12,@(64:12,R14); _pmInfo[].reg[]
    00000138 D345                   MOV.L       L619+40,R3 ; _motor_PowerUp
    0000013A 430B                   JSR         @R3
    0000013C E500                   MOV         #0,R5      ; H'00000000
    0000013E              L24:
    0000013E 7D01                   ADD         #1,R13
    00000140 7E64                   ADD         #100,R14
    00000142 62DC                   EXTU.B      R13,R2
    00000144 32A7                   CMP/GT      R10,R2
    00000146 8FDA                   BF/S        L22
    00000148 E001                   MOV         #1,R0      ; H'00000001
    0000014A 49F4                   MOVMU.L     @R15+,R9
               mnet.c        387          }
               mnet.c        388      }
               mnet.c        389    
               mnet.c        390      return TRUE;
               mnet.c        391    }
    0000014C 006B                   RTS/N
               mnet.c        392    ///<summary>
               mnet.c        393    /// モータコントローラを初期化する関数
               mnet.c        394    ///</summary>
               mnet.c        395    static BOOL motor_InitController(void)
    0000014E              __$motor_InitController:         ; function: __$motor_InitController
                                                           ; frame size=20
    0000014E 4CF0                   MOVMU.L     R12,@-R15
    00000150 7FFC                   ADD         #-4,R15
               mnet.c        396    {
               mnet.c        397      UB pm;
               mnet.c        398      UB enc;
               mnet.c        399      UB mnet_drv_typ;
               mnet.c        400    
               mnet.c        401      // メインデバイスの全割り込みを無効化
               mnet.c        402      if (!SetMainRegister(MNET_CENTER_WRENV0, 0x037F))               return FALSE;
    00000152 E455                   MOV         #85,R4     ; H'00000055
    00000154 0500037F               MOVI20      #895,R5    ; H'0000037F
    00000158 B705                   BSR         __$SetMainRegister
    0000015A 4418                   SHLL8       R4
    0000015C 2008                   TST         R0,R0
    0000015E 8955                   BT          L33
               mnet.c        403    
               mnet.c        404      for (pm=DVMIN; pm<=DVMAX; pm++)
    00000160 EE01                   MOV         #1,R14     ; H'00000001
    00000162 EC07                   MOV         #7,R12     ; H'00000007
    00000164              L34:
               mnet.c        405      {
               mnet.c        406          if (IsExist( pm ))                                          // デバイス接続しているか(≠0：接続)
    00000164 D339                   MOV.L       L619+36,R3 ; _IsExist
    00000166 430B                   JSR         @R3
    00000168 64E3                   MOV         R14,R4
    0000016A 2008                   TST         R0,R0
    0000016C 8948                   BT          L36
               mnet.c        407          {
               mnet.c        408              mnet_drv_typ = MNET_DRV_TYPE[pm];                       // デバイス情報取得
    0000016E D639                   MOV.L       L619+44,R6 ; _MNET_DRV_TYPE
    00000170 6EEC                   EXTU.B      R14,R14
    00000172 60E3                   MOV         R14,R0
    00000174 026C                   MOV.B       @(R0,R6),R2; MNET_DRV_TYPE[]
    00000176 602C                   EXTU.B      R2,R0
               mnet.c        409    
               mnet.c        410              switch( mnet_drv_typ )
    00000178 8801                   CMP/EQ      #1,R0
    0000017A 8905                   BT          L38
    0000017C 2008                   TST         R0,R0
    0000017E 8922                   BT          L40
    00000180 8809                   CMP/EQ      #9,R0
    00000182 8938                   BT          L41
    00000184 A03C                   BRA         L36
    00000186 0009                   NOP
    00000188              L38:
               mnet.c        411              {
               mnet.c        412              case BCD4020FUA:
               mnet.c        413                  if (!SetMotorCommand(pm, CMD_SRST))                 continue;
    00000188 E504                   MOV         #4,R5      ; H'00000004
    0000018A B6FA                   BSR         __$SetMotorCommand
    0000018C 64E3                   MOV         R14,R4
    0000018E 2008                   TST         R0,R0
    00000190 8936                   BT          L36
               mnet.c        414                  if( IsEncoderExist(pm) == TRUE )                    enc = EC_3;
    00000192 64E3                   MOV         R14,R4
    00000194 D330                   MOV.L       L619+48,R3 ; _IsEncoderExist
    00000196 430B                   JSR         @R3
    00000198 ED00                   MOV         #0,R13     ; H'00000000
    0000019A 8801                   CMP/EQ      #1,R0
    0000019C 8B00                   BF          L44
    0000019E ED03                   MOV         #3,R13     ; H'00000003
    000001A0              L44:
               mnet.c        415                  else                                                enc = EC_N;
               mnet.c        416    
               mnet.c        417                  if( SetRenv1Fu( pm ))                               return FALSE;// RENV1設定
    000001A0 D32E                   MOV.L       L619+52,R3 ; __$SetRenv1Fu
    000001A2 430B                   JSR         @R3
    000001A4 64E3                   MOV         R14,R4
    000001A6 2008                   TST         R0,R0
    000001A8 8B30                   BF          L33
               mnet.c        418                  if( SetRenv2Fu( pm, enc ))                          return FALSE;// RENV2設定
    000001AA 64E3                   MOV         R14,R4
    000001AC D32C                   MOV.L       L619+56,R3 ; __$SetRenv2Fu
    000001AE 430B                   JSR         @R3
    000001B0 65D3                   MOV         R13,R5
    000001B2 2008                   TST         R0,R0
    000001B4 8B2A                   BF          L33
               mnet.c        419                  if( SetRenv3Fu( pm, enc ))                          return FALSE;// RENV3設定
    000001B6 64E3                   MOV         R14,R4
    000001B8 D32A                   MOV.L       L619+60,R3 ; __$SetRenv3Fu
    000001BA 430B                   JSR         @R3
    000001BC 65D3                   MOV         R13,R5
    000001BE 2008                   TST         R0,R0
    000001C0 8B24                   BF          L33
    000001C2 A018                   BRA         L41
    000001C4 0009                   NOP
    000001C6              L40:
               mnet.c        420                  break;
               mnet.c        421    
               mnet.c        422              case BCD4020FU:
               mnet.c        423                  if (!SetMotorCommand(pm, CMD_SRST))                 continue;
    000001C6 E504                   MOV         #4,R5      ; H'00000004
    000001C8 B6DB                   BSR         __$SetMotorCommand
    000001CA 64E3                   MOV         R14,R4
    000001CC 2008                   TST         R0,R0
    000001CE 8917                   BT          L36
               mnet.c        424                  if( IsEncoderExist(pm) == TRUE )                    enc = EC_3;
    000001D0 D321                   MOV.L       L619+48,R3 ; _IsEncoderExist
    000001D2 430B                   JSR         @R3
    000001D4 64E3                   MOV         R14,R4
    000001D6 8801                   CMP/EQ      #1,R0
    000001D8 8F01                   BF/S        L49
    000001DA E500                   MOV         #0,R5      ; H'00000000
    000001DC E503                   MOV         #3,R5      ; H'00000003
    000001DE              L49:
               mnet.c        425                  else                                                enc = EC_N;
               mnet.c        426    
               mnet.c        427                  if( SetRenv1Fu( pm ))                               return FALSE;// RENV1設定
    000001DE 2F50                   MOV.B       R5,@R15    ; enc
    000001E0 D31E                   MOV.L       L619+52,R3 ; __$SetRenv1Fu
    000001E2 430B                   JSR         @R3
    000001E4 64E3                   MOV         R14,R4
    000001E6 2008                   TST         R0,R0
    000001E8 8B10                   BF          L33
               mnet.c        428                  if( SetRenv2Fu( pm, enc ))                          return FALSE;// RENV2設定
    000001EA 65F0                   MOV.B       @R15,R5    ; enc
    000001EC D31C                   MOV.L       L619+56,R3 ; __$SetRenv2Fu
    000001EE 430B                   JSR         @R3
    000001F0 64E3                   MOV         R14,R4
    000001F2 2008                   TST         R0,R0
    000001F4 8B0A                   BF          L33
    000001F6              L41:
    000001F6 E5AC                   MOV         #-84,R5    ; H'FFFFFFAC
               mnet.c        429                  break;
               mnet.c        430    
               mnet.c        431              case PCD4611:
               mnet.c        432    //                if( SetRenv1PCD4611( pm ))                          return FALSE;// RENV1設定
               mnet.c        433    //                if( SetRenv2PCD4611( pm, enc ))                     return FALSE;// RENV2設定
               mnet.c        434                  break;
               mnet.c        435    
               mnet.c        436              default:
               mnet.c        437                  // モータドライバ以外は、スキップ
               mnet.c        438                  continue;
               mnet.c        439                  break;
               mnet.c        440              }
               mnet.c        441              // RIRQ
               mnet.c        442              SetMotorRegisterInt(pm, WRG_RIRQ, 0x00000000);
    000001F8 E600                   MOV         #0,R6      ; H'00000000
    000001FA 655C                   EXTU.B      R5,R5
    000001FC B6DF                   BSR         _SetMotorRegisterInt
    000001FE 64E3                   MOV         R14,R4
    00000200              L36:
    00000200 7E01                   ADD         #1,R14
    00000202 62EC                   EXTU.B      R14,R2
    00000204 32C7                   CMP/GT      R12,R2
    00000206 8BAD                   BF          L34
               mnet.c        443          }
               mnet.c        444      }
               mnet.c        445      return TRUE;
    00000208 A001                   BRA         L52
    0000020A 0029                   MOVT        R0
    0000020C              L33:
    0000020C E000                   MOV         #0,R0      ; H'00000000
    0000020E              L52:
    0000020E 7F04                   ADD         #4,R15
    00000210 4CF4                   MOVMU.L     @R15+,R12
               mnet.c        446    }
    00000212 006B                   RTS/N
               mnet.c        447    ////////////////////////////////////////////////////////////////////////////////
               mnet.c        448    //
               mnet.c        449    // 割り込みハンドラ
               mnet.c        450    
               mnet.c        451    ///<summary>
               mnet.c        452    /// コマンド実行結果を取得します
               mnet.c        453    ///</summary>
               mnet.c        454    void IRQ4_ISR()
    00000214              _IRQ4_ISR:                       ; function: IRQ4_ISR
                                                           ; frame size=0
               mnet.c        455    {
               mnet.c        456    #if 0 
               mnet.c        457      MNETStatus status;
               mnet.c        458      status.UNID.data = pMotionnet->commandStatus0 ;
               mnet.c        459      ClearInterrupt();
               mnet.c        460      INTC.IRQRR.BIT.IRQ4F = 0;
               mnet.c        461    #endif
               mnet.c        462    }
    00000214 006B                   RTS/N
               mnet.c        463    
               mnet.c        464    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        465    // 
               mnet.c        466    // IO系
               mnet.c        467    // 
               mnet.c        468    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        469    ///<summary>
               mnet.c        470    /// IOトローラを初期化する関数
               mnet.c        471    ///</summary>
               mnet.c        472    BOOL pio_Init()
    00000216              _pio_Init:                       ; function: pio_Init
                                                           ; frame size=4
    00000216 4F22                   STS.L       PR,@-R15
               mnet.c        473    {
               mnet.c        474    // シュミレーションモード
               mnet.c        475    #if DEBUG_SIM_MODE != 0
               mnet.c        476      return TRUE;
               mnet.c        477    #endif
               mnet.c        478      // メインデバイスの全割り込みを無効化
               mnet.c        479      SetMainRegister(MNET_CENTER_WRENV0, 0x037F);
    00000218 E455                   MOV         #85,R4     ; H'00000055
    0000021A 0500037F               MOVI20      #895,R5    ; H'0000037F
    0000021E B6A2                   BSR         __$SetMainRegister
    00000220 4418                   SHLL8       R4
               mnet.c        480    
               mnet.c        481      return TRUE;
    00000222 4F26                   LDS.L       @R15+,PR
               mnet.c        482    }
    00000224 000B                   RTS
    00000226 E001                   MOV         #1,R0      ; H'00000001
    00000228              L619:
    00000228 0C008000               .DATA.L     H'0C008000
    0000022C <00000000>             .DATA.L     _pMotionnet
    00000230 <00000000>             .DATA.L     __$ChkRbsy
    00000234 <00000000>             .DATA.L     __$ChkDbsy
    00000238 <00000000>             .DATA.L     __$ChkSbsy
    0000023C <00000000>             .DATA.L     _v4_dly_tsk
    00000240 0C009000               .DATA.L     H'0C009000
    00000244 <00000000>             .DATA.L     _pPulseMotor
    00000248 <0000007F>             .DATA.L     H'0000007F+__$_pmInfo
    0000024C <00000000>             .DATA.L     _IsExist
    00000250 <00000000>             .DATA.L     _motor_PowerUp
    00000254 <00000000>             .DATA.L     _MNET_DRV_TYPE
    00000258 <00000000>             .DATA.L     _IsEncoderExist
    0000025C <00000000>             .DATA.L     __$SetRenv1Fu
    00000260 <00000000>             .DATA.L     __$SetRenv2Fu
    00000264 <00000000>             .DATA.L     __$SetRenv3Fu
               mnet.c        483    
               mnet.c        484    
               mnet.c        485    /******************************************************************************
               mnet.c        486    * 
               mnet.c        487    * [概要]  全入力チャネルの状態を取得する
               mnet.c        488    * [引数]  data    入力値格納先
               mnet.c        489    * [戻り値]    TRUE:成功、FALSE:失敗
               mnet.c        490    * 
               mnet.c        491    ******************************************************************************/
               mnet.c        492    void pio_ALLIN(UB *data)
    00000268              _pio_ALLIN:                      ; function: pio_ALLIN
                                                           ; frame size=32
    00000268 48F0                   MOVMU.L     R8,@-R15
    0000026A D297                   MOV.L       L620+2,R2  ; H'0C008000
               mnet.c        493    {
               mnet.c        494      INT Loopn;
               mnet.c        495      INT amari;
               mnet.c        496      INT syou;
               mnet.c        497      INT sftdat;
               mnet.c        498      UB  sftbit;
               mnet.c        499      UB  ret;
               mnet.c        500    
               mnet.c        501      sftbit = 0x01;
               mnet.c        502    
               mnet.c        503      pMotionnet = (struct StMotionnet *)MNET_BASE_ADDRESS;
    0000026C 6943                   MOV         R4,R9
    0000026E D697                   MOV.L       L620+6,R6  ; _pMotionnet
    00000270 2622                   MOV.L       R2,@R6     ; pMotionnet
               mnet.c        504    
               mnet.c        505      // ※補足）実装されていない入力個所０
               mnet.c        506      // bit1    チャネル2
               mnet.c        507      // ・
               mnet.c        508      // bit63   チャネル64
               mnet.c        509    
               mnet.c        510      
               mnet.c        511      // ※補足）実装されていない入力個所０
               mnet.c        512      // Ch0は無効のため検査しない
               mnet.c        513      for( Loopn = MIN_CH; Loopn <= MAX_CH; Loopn++ ) // 2020/2/12 １はじまり対応
    00000272 EB3F                   MOV         #63,R11    ; H'0000003F
    00000274 EA01                   MOV         #1,R10     ; H'00000001
    00000276 EC00                   MOV         #0,R12     ; H'00000000
    00000278 D895                   MOV.L       L620+10,R8 ; _GetInputDat
    0000027A              L56:
    0000027A 4C11                   CMP/PZ      R12
               mnet.c        514      {
               mnet.c        515          sftbit = 0x01;
               mnet.c        516    
               mnet.c        517          syou    = ( (Loopn - MIN_CH) / 8 );         // 余り取得
    0000027C 8D01                   BT/S        L58
    0000027E 62C3                   MOV         R12,R2
    00000280 7207                   ADD         #7,R2
    00000282              L58:
    00000282 E1FD                   MOV         #-3,R1     ; H'FFFFFFFD
               mnet.c        518          amari   = ( (Loopn - MIN_CH) % 8 );         // 余り取得
               mnet.c        519          sftdat  = ( sftbit << amari );              // 余りをシフト
    00000284 4C11                   CMP/PZ      R12
    00000286 421C                   SHAD        R1,R2
    00000288 8D06                   BT/S        L60
    0000028A 6D23                   MOV         R2,R13
    0000028C 60C7                   NOT         R12,R0
    0000028E 7001                   ADD         #1,R0
    00000290 C907                   AND         #7,R0
    00000292 6207                   NOT         R0,R2
    00000294 A003                   BRA         L61
    00000296 7201                   ADD         #1,R2
    00000298              L60:
    00000298 60C3                   MOV         R12,R0
    0000029A C907                   AND         #7,R0
    0000029C 6203                   MOV         R0,R2
    0000029E              L61:
    0000029E EE01                   MOV         #1,R14     ; H'00000001
               mnet.c        520    
               mnet.c        521    // シュミレーションモード
               mnet.c        522    #if DEBUG_SIM_MODE != 0
               mnet.c        523          ret = 0;
               mnet.c        524    #else
               mnet.c        525          ret = GetInputDat( Loopn ) ;
    000002A0 64A3                   MOV         R10,R4
    000002A2 480B                   JSR         @R8
    000002A4 4E2C                   SHAD        R2,R14
    000002A6 610C                   EXTU.B      R0,R1
    000002A8 2118                   TST         R1,R1
               mnet.c        526    #endif
               mnet.c        527    
               mnet.c        528          if( ret )
    000002AA 60D3                   MOV         R13,R0
    000002AC 8D02                   BT/S        L63
    000002AE 069C                   MOV.B       @(R0,R9),R6; data[]
               mnet.c        529          {
               mnet.c        530              data[syou] |= sftdat;
    000002B0 A002                   BRA         L64
    000002B2 26EB                   OR          R14,R6
    000002B4              L63:
               mnet.c        531          }
               mnet.c        532          else
               mnet.c        533          {
               mnet.c        534              data[syou] &= (~sftdat);
    000002B4 62E7                   NOT         R14,R2
    000002B6 2629                   AND         R2,R6
    000002B8              L64:
    000002B8 4B10                   DT          R11
    000002BA 0964                   MOV.B       R6,@(R0,R9); data[]
    000002BC 7C01                   ADD         #1,R12
    000002BE 8FDC                   BF/S        L56
    000002C0 7A01                   ADD         #1,R10
    000002C2 48F4                   MOVMU.L     @R15+,R8
               mnet.c        535          }
               mnet.c        536      }
               mnet.c        537    }
    000002C4 006B                   RTS/N
               mnet.c        538    
               mnet.c        539    /******************************************************************************
               mnet.c        540    * 
               mnet.c        541    * [概要]  入力チャネルから信号を取得する
               mnet.c        542    * [引数]  ch      入力チャネル(０〜)
               mnet.c        543    *             sw      [out]チャネルの状態(TRUE:ON、FALSE：OFF)
               mnet.c        544    * [戻り値]    1:High、0:Low
               mnet.c        545    * 
               mnet.c        546    ******************************************************************************/
               mnet.c        547    UB pio_BIN(UB ch)
    000002C6              _pio_BIN:                        ; function: pio_BIN
                                                           ; frame size=4
    000002C6 4F22                   STS.L       PR,@-R15
               mnet.c        548    {
               mnet.c        549      UB retdat = OFF;
               mnet.c        550      
               mnet.c        551    // シュミレーションモード
               mnet.c        552    #if DEBUG_SIM_MODE != 0
               mnet.c        553      if( ch == 4 )
               mnet.c        554      {
               mnet.c        555          return(1);
               mnet.c        556      }
               mnet.c        557      else
               mnet.c        558      {
               mnet.c        559          return(0);
               mnet.c        560      }
               mnet.c        561    #endif
               mnet.c        562      
               mnet.c        563      if( ( ch == I_DOORSW1 )||( ch == I_DOORSW2 ) )
    000002C8 644C                   EXTU.B      R4,R4
    000002CA 6043                   MOV         R4,R0
    000002CC 8801                   CMP/EQ      #1,R0
    000002CE 8D05                   BT/S        L68
    000002D0 E600                   MOV         #0,R6      ; H'00000000
    000002D2 8802                   CMP/EQ      #2,R0
    000002D4 8902                   BT          L68
               mnet.c        564      {
               mnet.c        565          
               mnet.c        566          
               mnet.c        567          
               mnet.c        568          
               mnet.c        569      }
               mnet.c        570      else
               mnet.c        571      {
               mnet.c        572          retdat = GetInputDat( ch );
    000002D6 D27E                   MOV.L       L620+10,R2 ; _GetInputDat
    000002D8 424B                   JSR/N       @R2
    000002DA 6603                   MOV         R0,R6
    000002DC              L68:
    000002DC 4F26                   LDS.L       @R15+,PR
               mnet.c        573      }
               mnet.c        574      
               mnet.c        575      
               mnet.c        576      return ( retdat );
               mnet.c        577    }
    000002DE 067B                   RTV/N       R6
               mnet.c        578    /******************************************************************************
               mnet.c        579    * 
               mnet.c        580    * [概要]  出力チャネルへの出力データ
               mnet.c        581    * [引数]  ch      出力チャネル
               mnet.c        582    *             sw      ON:HIGH出力、OFF:LOW出力
               mnet.c        583    * [戻り値]    −
               mnet.c        584    * 
               mnet.c        585    ******************************************************************************/
               mnet.c        586    void pio_BOUT(UB ch, UB sw)
    000002E0              _pio_BOUT:                       ; function: pio_BOUT
                                                           ; frame size=40
    000002E0 49F0                   MOVMU.L     R9,@-R15
    000002E2 7FF4                   ADD         #-12,R15
    000002E4 604C                   EXTU.B      R4,R0
    000002E6 E601                   MOV         #1,R6      ; H'00000001
    000002E8 3063                   CMP/GE      R6,R0
               mnet.c        587    {
               mnet.c        588      INT waittim = WAITTIM;
               mnet.c        589      INT cnt;
               mnet.c        590      UB rdata = 0;
               mnet.c        591      UB wdata = 0;
               mnet.c        592      UB devno;
               mnet.c        593      UB portno;
               mnet.c        594      UB mskbit;
               mnet.c        595    
               mnet.c        596      if(( ch < MIN_CH )||( ch > MAX_CH )) return;    // 2020/2/12 １はじまり対応
    000002EA 8F77                   BF/S        L75
    000002EC 675C                   EXTU.B      R5,R7
    000002EE E63F                   MOV         #63,R6     ; H'0000003F
    000002F0 3067                   CMP/GT      R6,R0
    000002F2 8973                   BT          L75
               mnet.c        597    
               mnet.c        598      if( ch == O_DAIAPMP )
    000002F4 8801                   CMP/EQ      #1,R0
    000002F6 8B0E                   BF          L78
    000002F8 2778                   TST         R7,R7
               mnet.c        599      {
               mnet.c        600    //        switch( sw )
               mnet.c        601    //        {
               mnet.c        602    //        case 1:     //正転
               mnet.c        603    //            PE.DR.BIT.B0 = 1;
               mnet.c        604    //            PE.DR.BIT.B1 = 0;
               mnet.c        605    //            break;
               mnet.c        606    //        case 2:     //逆転
               mnet.c        607    //            PE.DR.BIT.B0 = 0;
               mnet.c        608    //            PE.DR.BIT.B1 = 1;
               mnet.c        609    //            break;
               mnet.c        610    //        default:    //停止
               mnet.c        611    //            PE.DR.BIT.B0 = 0;
               mnet.c        612    //            PE.DR.BIT.B1 = 0;
               mnet.c        613    //            break;
               mnet.c        614    //        }
               mnet.c        615          
               mnet.c        616          switch( sw )
    000002FA 8F05                   BF/S        L80
    000002FC 6473                   MOV         R7,R4
               mnet.c        617          {
               mnet.c        618          case 0:
               mnet.c        619              DpumpStop();
    000002FE D275                   MOV.L       L620+14,R2 ; _DpumpStop
    00000300 7F0C                   ADD         #12,R15
    00000302 49F4                   MOVMU.L     @R15+,R9
    00000304 422B                   JMP         @R2
    00000306 0009                   NOP
    00000308              L80:
               mnet.c        620              break;
               mnet.c        621          default:
               mnet.c        622              SetDpumpDuty( sw );
    00000308 D173                   MOV.L       L620+18,R1 ; _SetDpumpDuty
    0000030A 414B                   JSR/N       @R1
               mnet.c        623              DpumpStart();
    0000030C D573                   MOV.L       L620+22,R5 ; _DpumpStart
    0000030E 7F0C                   ADD         #12,R15
    00000310 49F4                   MOVMU.L     @R15+,R9
    00000312 452B                   JMP         @R5
    00000314 0009                   NOP
    00000316              L78:
               mnet.c        624              break;
               mnet.c        625          }
               mnet.c        626      }
               mnet.c        627      else
               mnet.c        628      {
               mnet.c        629          // CLRリクエスト
               mnet.c        630          devno  = OUTPUTCH_INFTBL[ch][0];
    00000316 644C                   EXTU.B      R4,R4
    00000318 E003                   MOV         #3,R0      ; H'00000003
    0000031A 4480                   MULR        R0,R4
    0000031C D970                   MOV.L       L620+26,R9 ; _OUTPUTCH_INFTBL
    0000031E E5FF                   MOV         #-1,R5     ; H'FFFFFFFF
    00000320 655C                   EXTU.B      R5,R5
    00000322 6043                   MOV         R4,R0
    00000324 019C                   MOV.B       @(R0,R9),R1; OUTPUTCH_INFTBL[]
               mnet.c        631          portno = OUTPUTCH_INFTBL[ch][1];
    00000326 6493                   MOV         R9,R4
               mnet.c        632          mskbit = OUTPUTCH_INFTBL[ch][2];
    00000328 7902                   ADD         #2,R9
    0000032A 069C                   MOV.B       @(R0,R9),R6; OUTPUTCH_INFTBL[]
               mnet.c        633          
               mnet.c        634          // 出力値作成
               mnet.c        635          if(( devno != NONE )&&( portno != NONE ))
    0000032C 6A1C                   EXTU.B      R1,R10
    0000032E 7401                   ADD         #1,R4
    00000330 3A50                   CMP/EQ      R5,R10
    00000332 044C                   MOV.B       @(R0,R4),R4; OUTPUTCH_INFTBL[]
    00000334 8D52                   BT/S        L75
    00000336 2F60                   MOV.B       R6,@R15    ; mskbit
    00000338 624C                   EXTU.B      R4,R2
    0000033A 3250                   CMP/EQ      R5,R2
    0000033C 894E                   BT          L75
    0000033E D963                   MOV.L       L620+6,R9  ; _pMotionnet
               mnet.c        636          {
               mnet.c        637      // 本モード
               mnet.c        638    #if DEBUG_SIM_MODE == 0
               mnet.c        639              // 書込みデータベース取得
               mnet.c        640              MAC_READ( pMotionnet->portData[devno][portno], wdata );
    00000340 601C                   EXTU.B      R1,R0
    00000342 6D92                   MOV.L       @R9,R13    ; pMotionnet
    00000344 EC01                   MOV         #1,R12     ; H'00000001
    00000346 4008                   SHLL2       R0
    00000348 644C                   EXTU.B      R4,R4
    0000034A E500                   MOV         #0,R5      ; H'00000000
    0000034C 4C18                   SHLL8       R12
    0000034E 304C                   ADD         R4,R0
    00000350 3DCC                   ADD         R12,R13
    00000352 6E03                   MOV         R0,R14
    00000354 02DC                   MOV.B       @(R0,R13),R2; pMotionnet->portData[]
    00000356 EB05                   MOV         #5,R11     ; H'00000005
    00000358 642C                   EXTU.B      R2,R4
    0000035A A009                   BRA         L83
    0000035C 6143                   MOV         R4,R1
    0000035E              L84:
    0000035E 60E3                   MOV         R14,R0
    00000360 02DC                   MOV.B       @(R0,R13),R2; pMotionnet->portData[]
    00000362 662C                   EXTU.B      R2,R6
    00000364 3640                   CMP/EQ      R4,R6
    00000366 8902                   BT          L86
    00000368 E500                   MOV         #0,R5      ; H'00000000
    0000036A 6163                   MOV         R6,R1
    0000036C 6463                   MOV         R6,R4
    0000036E              L86:
    0000036E 7501                   ADD         #1,R5
    00000370              L83:
    00000370 35B3                   CMP/GE      R11,R5
    00000372 8BF4                   BF          L84
               mnet.c        641    #endif
               mnet.c        642    
               mnet.c        643              // SETリクエスト
               mnet.c        644              if( sw )
    00000374 2778                   TST         R7,R7
    00000376 8902                   BT          L89
               mnet.c        645              {
               mnet.c        646                  wdata |= mskbit;
    00000378 62F0                   MOV.B       @R15,R2    ; mskbit
    0000037A A003                   BRA         L90
    0000037C 212B                   OR          R2,R1
    0000037E              L89:
               mnet.c        647              }
               mnet.c        648              // CLRリクエスト
               mnet.c        649              else
               mnet.c        650              {
               mnet.c        651                  wdata &= (~mskbit);
    0000037E 66F0                   MOV.B       @R15,R6    ; mskbit
    00000380 6267                   NOT         R6,R2
    00000382 2129                   AND         R2,R1
    00000384              L90:
    00000384 621C                   EXTU.B      R1,R2
    00000386 EA03                   MOV         #3,R10     ; H'00000003
               mnet.c        652              }
               mnet.c        653    
               mnet.c        654    // 本モード
               mnet.c        655    #if DEBUG_SIM_MODE == 0
               mnet.c        656              // 指定Chへ出力
               mnet.c        657              for( cnt = 0; cnt < READ_RTY_MAX; cnt++ )
    00000388 6013                   MOV         R1,R0
    0000038A 80F4                   MOV.B       R0,@(4,R15); wdata
    0000038C 1F22                   MOV.L       R2,@(8,R15)
    0000038E              L91:
               mnet.c        658              {
               mnet.c        659                  MAC_WRIT( pMotionnet->portData[devno][portno], wdata  );
    0000038E 84F4                   MOV.B       @(4,R15),R0; wdata
    00000390 6103                   MOV         R0,R1
    00000392 60E3                   MOV         R14,R0
    00000394 0D14                   MOV.B       R1,@(R0,R13); pMotionnet->portData[]
    00000396 E605                   MOV         #5,R6      ; H'00000005
    00000398 60E3                   MOV         R14,R0
    0000039A              L93:
    0000039A 6492                   MOV.L       @R9,R4     ; pMotionnet
    0000039C 4610                   DT          R6
    0000039E 34CC                   ADD         R12,R4
    000003A0 8FFB                   BF/S        L93
    000003A2 0414                   MOV.B       R1,@(R0,R4); pMotionnet->portData[]
               mnet.c        660                  g_Sleep(waittim);
    000003A4 D34F                   MOV.L       L620+30,R3 ; _g_Sleep
    000003A6 430B                   JSR         @R3
    000003A8 E43C                   MOV         #60,R4     ; H'0000003C
               mnet.c        661                  MAC_READ( pMotionnet->portData[devno][portno], rdata );
    000003AA 6D92                   MOV.L       @R9,R13    ; pMotionnet
    000003AC 60E3                   MOV         R14,R0
    000003AE E500                   MOV         #0,R5      ; H'00000000
    000003B0 3DCC                   ADD         R12,R13
    000003B2 02DC                   MOV.B       @(R0,R13),R2; pMotionnet->portData[]
    000003B4 642C                   EXTU.B      R2,R4
    000003B6 A009                   BRA         L95
    000003B8 6743                   MOV         R4,R7
    000003BA              L96:
    000003BA 60E3                   MOV         R14,R0
    000003BC 02DC                   MOV.B       @(R0,R13),R2; pMotionnet->portData[]
    000003BE 622C                   EXTU.B      R2,R2
    000003C0 3240                   CMP/EQ      R4,R2
    000003C2 8902                   BT          L98
    000003C4 E500                   MOV         #0,R5      ; H'00000000
    000003C6 6723                   MOV         R2,R7
    000003C8 6423                   MOV         R2,R4
    000003CA              L98:
    000003CA 7501                   ADD         #1,R5
    000003CC              L95:
    000003CC 35B3                   CMP/GE      R11,R5
    000003CE 8BF4                   BF          L96
    000003D0 56F2                   MOV.L       @(8,R15),R6
               mnet.c        662                  if( wdata == rdata )    break;
    000003D2 627C                   EXTU.B      R7,R2
    000003D4 3620                   CMP/EQ      R2,R6
    000003D6 8901                   BT          L75
    000003D8 4A10                   DT          R10
    000003DA 8BD8                   BF          L91
    000003DC              L75:
    000003DC 7F0C                   ADD         #12,R15
    000003DE 49F4                   MOVMU.L     @R15+,R9
    000003E0 006B                   RTS/N
               mnet.c        663              }
               mnet.c        664    #endif
               mnet.c        665          }
               mnet.c        666      }
               mnet.c        667    }
               mnet.c        668    
               mnet.c        669    /******************************************************************************
               mnet.c        670    * 
               mnet.c        671    * [概要]  パトライト専用出力
               mnet.c        672    * [引数]  sw      ON:HIGH出力、OFF:LOW出力
               mnet.c        673    * [戻り値]    −
               mnet.c        674    * 
               mnet.c        675    ******************************************************************************/
               mnet.c        676    void pio_PATOUT(UB sw1, UB sw2, UB sw3)
    000003E2              _pio_PATOUT:                     ; function: pio_PATOUT
                                                           ; frame size=32
    000003E2 2F86                   MOV.L       R8,@-R15
    000003E4 2F96                   MOV.L       R9,@-R15
    000003E6 2FA6                   MOV.L       R10,@-R15
    000003E8 2FB6                   MOV.L       R11,@-R15
    000003EA 2FC6                   MOV.L       R12,@-R15
    000003EC 2FD6                   MOV.L       R13,@-R15
    000003EE 2FE6                   MOV.L       R14,@-R15
    000003F0 7FFC                   ADD         #-4,R15
    000003F2 D93B                   MOV.L       L620+26,R9 ; _OUTPUTCH_INFTBL
               mnet.c        677    {
               mnet.c        678      UB data1 = 0;
               mnet.c        679      UB data2 = 0;
               mnet.c        680      UB mskbit = 0;
               mnet.c        681      UB devcno1 = 0;
               mnet.c        682      UB portno1 = 0;
               mnet.c        683      UB devcno2 = 0;
               mnet.c        684      UB portno2 = 0;
               mnet.c        685    
               mnet.c        686    // 本モード
               mnet.c        687    #if DEBUG_SIM_MODE == 0
               mnet.c        688      devcno1 = OUTPUTCH_INFTBL[O_PATLRED][0];
    000003F4 684C                   EXTU.B      R4,R8
    000003F6 ED01                   MOV         #1,R13     ; H'00000001
    000003F8 32918015               MOVU.B      @(21,R9),R2; OUTPUTCH_INFTBL[]
    000003FC D433                   MOV.L       L620+6,R4  ; _pMotionnet
               mnet.c        689      portno1 = OUTPUTCH_INFTBL[O_PATLRED][1];
    000003FE 3A918016               MOVU.B      @(22,R9),R10; OUTPUTCH_INFTBL[]
    00000402 6B42                   MOV.L       @R4,R11    ; pMotionnet
               mnet.c        690      MAC_READ( pMotionnet->portData[devcno1][portno1], data1 );
    00000404 4208                   SHLL2       R2
    00000406 4D18                   SHLL8       R13
    00000408 EC05                   MOV         #5,R12     ; H'00000005
    0000040A 6053                   MOV         R5,R0
    0000040C 80F3                   MOV.B       R0,@(3,R15); sw2
    0000040E 6023                   MOV         R2,R0
    00000410 30AC                   ADD         R10,R0
    00000412 3BDC                   ADD         R13,R11
    00000414 3A2C                   ADD         R2,R10
    00000416 06BC                   MOV.B       @(R0,R11),R6; pMotionnet->portData[]
    00000418 E500                   MOV         #0,R5      ; H'00000000
    0000041A 616C                   EXTU.B      R6,R1
    0000041C A009                   BRA         L102
    0000041E 6413                   MOV         R1,R4
    00000420              L103:
    00000420 60A3                   MOV         R10,R0
    00000422 02BC                   MOV.B       @(R0,R11),R2; pMotionnet->portData[]
    00000424 622C                   EXTU.B      R2,R2
    00000426 3240                   CMP/EQ      R4,R2
    00000428 8902                   BT          L105
    0000042A E500                   MOV         #0,R5      ; H'00000000
    0000042C 6123                   MOV         R2,R1
    0000042E 6423                   MOV         R2,R4
    00000430              L105:
    00000430 7501                   ADD         #1,R5
    00000432              L102:
    00000432 35C3                   CMP/GE      R12,R5
    00000434 8BF4                   BF          L103
               mnet.c        691      
               mnet.c        692      devcno2 = OUTPUTCH_INFTBL[O_PATLGRN][0];
    00000436 32918018               MOVU.B      @(24,R9),R2; OUTPUTCH_INFTBL[]
               mnet.c        693      portno2 = OUTPUTCH_INFTBL[O_PATLGRN][1];
    0000043A 3E918019               MOVU.B      @(25,R9),R14; OUTPUTCH_INFTBL[]
               mnet.c        694      MAC_READ( pMotionnet->portData[devcno2][portno2], data2 );
    0000043E 4208                   SHLL2       R2
    00000440 E500                   MOV         #0,R5      ; H'00000000
    00000442 6023                   MOV         R2,R0
    00000444 30EC                   ADD         R14,R0
    00000446 06BC                   MOV.B       @(R0,R11),R6; pMotionnet->portData[]
    00000448 3E2C                   ADD         R2,R14
    0000044A 676C                   EXTU.B      R6,R7
    0000044C A009                   BRA         L107
    0000044E 6473                   MOV         R7,R4
    00000450              L108:
    00000450 60E3                   MOV         R14,R0
    00000452 02BC                   MOV.B       @(R0,R11),R2; pMotionnet->portData[]
    00000454 662C                   EXTU.B      R2,R6
    00000456 3640                   CMP/EQ      R4,R6
    00000458 8902                   BT          L110
    0000045A E500                   MOV         #0,R5      ; H'00000000
    0000045C 6763                   MOV         R6,R7
    0000045E 6463                   MOV         R6,R4
    00000460              L110:
    00000460 7501                   ADD         #1,R5
    00000462              L107:
    00000462 35C3                   CMP/GE      R12,R5
    00000464 8BF4                   BF          L108
               mnet.c        695      
               mnet.c        696    #endif
               mnet.c        697    
               mnet.c        698      // 赤
               mnet.c        699      mskbit  = OUTPUTCH_INFTBL[O_PATLRED][2];
               mnet.c        700      if( sw1 )
    00000466 2888                   TST         R8,R8
    00000468 32914017               MOV.B       @(23:12,R9),R2; OUTPUTCH_INFTBL[]
    0000046C 8901                   BT          L113
               mnet.c        701      {
               mnet.c        702          data1 |= mskbit;
    0000046E A002                   BRA         L114
    00000470 212B                   OR          R2,R1
    00000472              L113:
               mnet.c        703      }
               mnet.c        704      else
               mnet.c        705      {
               mnet.c        706          data1 &= (~mskbit);
    00000472 6227                   NOT         R2,R2
    00000474 2129                   AND         R2,R1
    00000476              L114:
               mnet.c        707      }
               mnet.c        708    
               mnet.c        709      // 緑
               mnet.c        710      mskbit  = OUTPUTCH_INFTBL[O_PATLGRN][2];
               mnet.c        711      if( sw2 )
    00000476 84F3                   MOV.B       @(3,R15),R0; sw2
    00000478 3291401A               MOV.B       @(26:12,R9),R2; OUTPUTCH_INFTBL[]
    0000047C 2008                   TST         R0,R0
    0000047E 8901                   BT          L116
               mnet.c        712      {
               mnet.c        713          data2 |= mskbit;
    00000480 A002                   BRA         L117
    00000482 272B                   OR          R2,R7
    00000484              L116:
               mnet.c        714      }
               mnet.c        715      else
               mnet.c        716      {
               mnet.c        717          data2 &= (~mskbit);
    00000484 6227                   NOT         R2,R2
    00000486 2729                   AND         R2,R7
    00000488              L117:
               mnet.c        718      }
               mnet.c        719      
               mnet.c        720    // 本モード
               mnet.c        721    #if DEBUG_SIM_MODE == 0
               mnet.c        722      MAC_WRIT( pMotionnet->portData[devcno1][portno1], data1 );
    00000488 60A3                   MOV         R10,R0
    0000048A 0B14                   MOV.B       R1,@(R0,R11); pMotionnet->portData[]
    0000048C 60A3                   MOV         R10,R0
    0000048E E605                   MOV         #5,R6      ; H'00000005
    00000490 D20E                   MOV.L       L620+6,R2  ; _pMotionnet
    00000492              L118:
    00000492 6522                   MOV.L       @R2,R5     ; pMotionnet
    00000494 4610                   DT          R6
    00000496 35DC                   ADD         R13,R5
    00000498 8FFB                   BF/S        L118
    0000049A 0514                   MOV.B       R1,@(R0,R5); pMotionnet->portData[]
               mnet.c        723      MAC_WRIT( pMotionnet->portData[devcno2][portno2], data2 );
    0000049C 6422                   MOV.L       @R2,R4     ; pMotionnet
    0000049E 60E3                   MOV         R14,R0
    000004A0 D20A                   MOV.L       L620+6,R2  ; _pMotionnet
    000004A2 34DC                   ADD         R13,R4
    000004A4 E605                   MOV         #5,R6      ; H'00000005
    000004A6 0474                   MOV.B       R7,@(R0,R4); pMotionnet->portData[]
    000004A8 60E3                   MOV         R14,R0
    000004AA              L120:
    000004AA 6522                   MOV.L       @R2,R5     ; pMotionnet
    000004AC 4610                   DT          R6
    000004AE 35DC                   ADD         R13,R5
    000004B0 8FFB                   BF/S        L120
    000004B2 0574                   MOV.B       R7,@(R0,R5); pMotionnet->portData[]
    000004B4 7F04                   ADD         #4,R15
    000004B6 6EF6                   MOV.L       @R15+,R14
    000004B8 6DF6                   MOV.L       @R15+,R13
    000004BA 6CF6                   MOV.L       @R15+,R12
    000004BC 6BF6                   MOV.L       @R15+,R11
    000004BE 6AF6                   MOV.L       @R15+,R10
    000004C0 69F6                   MOV.L       @R15+,R9
               mnet.c        724    #endif
               mnet.c        725    }
    000004C2 000B                   RTS
    000004C4 68F6                   MOV.L       @R15+,R8
    000004C6              L620:
    000004C6 00000002               .RES.W      1
    000004C8 0C008000               .DATA.L     H'0C008000
    000004CC <00000000>             .DATA.L     _pMotionnet
    000004D0 <00000000>             .DATA.L     _GetInputDat
    000004D4 <00000000>             .DATA.L     _DpumpStop
    000004D8 <00000000>             .DATA.L     _SetDpumpDuty
    000004DC <00000000>             .DATA.L     _DpumpStart
    000004E0 <00000000>             .DATA.L     _OUTPUTCH_INFTBL
    000004E4 <00000000>             .DATA.L     _g_Sleep
               mnet.c        726    
               mnet.c        727    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        728    // 
               mnet.c        729    // モータ系
               mnet.c        730    // 
               mnet.c        731    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        732    /*-----------------------------------------------------------------------------
               mnet.c        733      機能：速度の設定
               mnet.c        734      機能：no      モータ番号
               mnet.c        735            type    １：Ｓ字、０：台形
               mnet.c        736            resol   速度倍率
               mnet.c        737            lspd    初速[Hz]
               mnet.c        738            hspd    高速[Hz]
               mnet.c        739            tim     加減速時間
               mnet.c        740            sarea   Ｓ字変速領域[Hz] ※台形の時は無視
               mnet.c        741      戻値：エラーコード
               mnet.c        742     ----------------------------------------------------------------------------*/
               mnet.c        743    ER motor_SET(UB pm, ST_MOTOR_PARAM mp)
    000004E8              _motor_SET:                      ; function: motor_SET
                                                           ; frame size=52
    000004E8 4DF0                   MOVMU.L     R13,@-R15
    000004EA 7FD8                   ADD         #-40,R15
               mnet.c        744    {
               mnet.c        745      ER Result = E_SUCCESS ;
               mnet.c        746      PM_REG  pm_reg = {0};
    000004EC D580                   MOV.L       L621+2,R5  ; L654
    000004EE 6252                   MOV.L       @R5,R2
    000004F0 E601                   MOV         #1,R6      ; H'00000001
    000004F2 5151                   MOV.L       @(4,R5),R1
    000004F4 5752                   MOV.L       @(8,R5),R7
    000004F6 5D53                   MOV.L       @(12,R5),R13
    000004F8 2F22                   MOV.L       R2,@R15    ; (part of)pm_reg
    000004FA 1F11                   MOV.L       R1,@(4,R15); (part of)pm_reg
    000004FC 1F72                   MOV.L       R7,@(8,R15); (part of)pm_reg
    000004FE 1FD3                   MOV.L       R13,@(12,R15); (part of)pm_reg
    00000500 5E54                   MOV.L       @(16,R5),R14
    00000502 5D55                   MOV.L       @(20,R5),R13
    00000504 1FE4                   MOV.L       R14,@(16,R15); (part of)pm_reg
    00000506 1FD5                   MOV.L       R13,@(20,R15); (part of)pm_reg
               mnet.c        747    
               mnet.c        748      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000508 6D4C                   EXTU.B      R4,R13
    0000050A 5156                   MOV.L       @(24,R5),R1
    0000050C 3D63                   CMP/GE      R6,R13
    0000050E 5E57                   MOV.L       @(28,R5),R14
    00000510 5758                   MOV.L       @(32,R5),R7
    00000512 5259                   MOV.L       @(36,R5),R2
    00000514 1F16                   MOV.L       R1,@(24,R15); (part of)pm_reg
    00000516 1FE7                   MOV.L       R14,@(28,R15); (part of)pm_reg
    00000518 1F78                   MOV.L       R7,@(32,R15); (part of)pm_reg
    0000051A 8F4B                   BF/S        L124
    0000051C 1F29                   MOV.L       R2,@(36,R15); (part of)pm_reg
    0000051E E207                   MOV         #7,R2      ; H'00000007
    00000520 3D27                   CMP/GT      R2,R13
    00000522 8947                   BT          L124
               mnet.c        749    
               mnet.c        750    // シュミレーションモード
               mnet.c        751    #if DEBUG_SIM_MODE != 0
               mnet.c        752      return (E_SUCCESS );
               mnet.c        753    #endif
               mnet.c        754      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00000524 D673                   MOV.L       L621+6,R6  ; _MNET_DRV_TYPE
    00000526 6E4C                   EXTU.B      R4,R14
    00000528 60E3                   MOV         R14,R0
    0000052A 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    0000052C 880A                   CMP/EQ      #10,R0
    0000052E 8B01                   BF          L127
               mnet.c        755      {
               mnet.c        756          return( E_SUCCESS );
    00000530 A042                   BRA         L128
    00000532 E000                   MOV         #0,R0      ; H'00000000
    00000534              L127:
               mnet.c        757      }
               mnet.c        758    
               mnet.c        759      // PCD4611通信接続時
               mnet.c        760      if( MNET_DRV_TYPE[pm] == PCD4611 )
    00000534 8809                   CMP/EQ      #9,R0
    00000536 65F3                   MOV         R15,R5
    00000538 64F3                   MOV         R15,R4
    0000053A 8F04                   BF/S        L130
    0000053C 7434                   ADD         #52,R4
               mnet.c        761      {
               mnet.c        762          Result = motor_CalcMotorRegPCD4611(&mp, &pm_reg);
    0000053E D36E                   MOV.L       L621+10,R3 ; __$motor_CalcMotorRegPCD4611
    00000540 434B                   JSR/N       @R3
    00000542 A002                   BRA         L131
    00000544 0009                   NOP
    00000546              L130:
               mnet.c        763      }
               mnet.c        764      else
               mnet.c        765      {
               mnet.c        766          Result = motor_CalcMotorReg(&mp, &pm_reg);
    00000546 D36D                   MOV.L       L621+14,R3 ; __$motor_CalcMotorReg
    00000548 434B                   JSR/N       @R3
    0000054A              L131:
    0000054A 2008                   TST         R0,R0
               mnet.c        767      }
               mnet.c        768    
               mnet.c        769      if( Result != E_SUCCESS)                                return( Result );
    0000054C 8F30                   BF/S        L133
    0000054E 6203                   MOV         R0,R2
               mnet.c        770      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm )); // デバイス接続確認
    00000550 B626                   BSR         _IsExist
    00000552 64D3                   MOV         R13,R4
    00000554 2008                   TST         R0,R0
    00000556 8B04                   BF          L135
    00000558 E604                   MOV         #4,R6      ; H'00000004
    0000055A 4618                   SHLL8       R6
    0000055C 3E6C                   ADD         R6,R14
    0000055E A02B                   BRA         L128
    00000560 60E3                   MOV         R14,R0
    00000562              L135:
               mnet.c        771      if (motor_IsBusy(pm))                                   return(( E_BUSY + pm ));    // ビジー確認
    00000562 B661                   BSR         _motor_IsBusy
    00000564 64D3                   MOV         R13,R4
    00000566 2008                   TST         R0,R0
    00000568 8904                   BT          L137
    0000056A E601                   MOV         #1,R6      ; H'00000001
    0000056C 4618                   SHLL8       R6
    0000056E 3E6C                   ADD         R6,R14
    00000570 A022                   BRA         L128
    00000572 60E3                   MOV         R14,R0
    00000574              L137:
               mnet.c        772    
               mnet.c        773      _pmInfo[pm].reg[R1] = pm_reg.reg[R1];
    00000574 E064                   MOV         #100,R0    ; H'00000064
    00000576 57F1                   MOV.L       @(4,R15),R7; pm_reg.reg[]
    00000578 4E80                   MULR        R0,R14
    0000057A D661                   MOV.L       L621+18,R6 ; __$_pmInfo
    0000057C 6163                   MOV         R6,R1
    0000057E 7128                   ADD         #40,R1
    00000580 6563                   MOV         R6,R5
    00000582 752C                   ADD         #44,R5
    00000584 60E3                   MOV         R14,R0
               mnet.c        774      _pmInfo[pm].reg[R2] = pm_reg.reg[R2];
    00000586 5EF2                   MOV.L       @(8,R15),R14; pm_reg.reg[]
    00000588 0176                   MOV.L       R7,@(R0,R1); _pmInfo[].reg[]
    0000058A 6763                   MOV         R6,R7
               mnet.c        775      _pmInfo[pm].reg[R3] = pm_reg.reg[R3];
    0000058C 51F3                   MOV.L       @(12,R15),R1; pm_reg.reg[]
    0000058E 7730                   ADD         #48,R7
    00000590 05E6                   MOV.L       R14,@(R0,R5); _pmInfo[].reg[]
    00000592 6E63                   MOV         R6,R14
               mnet.c        776      _pmInfo[pm].reg[R4] = pm_reg.reg[R4];
    00000594 52F4                   MOV.L       @(16,R15),R2; pm_reg.reg[]
    00000596 7E34                   ADD         #52,R14
               mnet.c        777      _pmInfo[pm].reg[R5] = pm_reg.reg[R5];
    00000598 54F5                   MOV.L       @(20,R15),R4; pm_reg.reg[]
               mnet.c        778      _pmInfo[pm].reg[R6] = pm_reg.reg[R6];
    0000059A 55F6                   MOV.L       @(24,R15),R5; pm_reg.reg[]
    0000059C 0716                   MOV.L       R1,@(R0,R7); _pmInfo[].reg[]
    0000059E 6163                   MOV         R6,R1
    000005A0 7138                   ADD         #56,R1
    000005A2 763C                   ADD         #60,R6
    000005A4 0E26                   MOV.L       R2,@(R0,R14); _pmInfo[].reg[]
    000005A6 0146                   MOV.L       R4,@(R0,R1); _pmInfo[].reg[]
               mnet.c        779    
               mnet.c        780      Result =  motor_SetAllRegister(pm);
    000005A8 64D3                   MOV         R13,R4
    000005AA B755                   BSR         __$motor_SetAllRegister
    000005AC 0656                   MOV.L       R5,@(R0,R6); _pmInfo[].reg[]
    000005AE 6203                   MOV         R0,R2
    000005B0              L133:
    000005B0 A002                   BRA         L128
    000005B2 6023                   MOV         R2,R0
    000005B4              L124:
    000005B4 00000801               MOVI20      #2049,R0   ; H'00000801
    000005B8              L128:
    000005B8 7F28                   ADD         #40,R15
    000005BA 4DF4                   MOVMU.L     @R15+,R13
               mnet.c        781      if( Result != E_SUCCESS )                               return( Result );
               mnet.c        782    
               mnet.c        783      return Result;
               mnet.c        784    }
    000005BC 006B                   RTS/N
               mnet.c        785    
               mnet.c        786    /******************************************************************************
               mnet.c        787    * 
               mnet.c        788    * [概要]  アドレスカウンタのリセット
               mnet.c        789    * [引数]  pm:モータ番号、cnt:カウント設定値、enc:エンコーダ設定値、dv:未使用、def:偏差カウンタ
               mnet.c        790    * [戻値]  エラーコード
               mnet.c        791    * 
               mnet.c        792    ******************************************************************************/
               mnet.c        793    ER motor_PSET(UB pm, INT cnt, INT enc, INT def)
    000005BE              _motor_PSET:                     ; function: motor_PSET
                                                           ; frame size=20
    000005BE 4BF0                   MOVMU.L     R11,@-R15
    000005C0 6E4C                   EXTU.B      R4,R14
    000005C2 E101                   MOV         #1,R1      ; H'00000001
    000005C4 3E13                   CMP/GE      R1,R14
               mnet.c        794    {
               mnet.c        795      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    000005C6 6B73                   MOV         R7,R11
    000005C8 6C63                   MOV         R6,R12
    000005CA 8F4D                   BF/S        L140
    000005CC 6D53                   MOV         R5,R13
    000005CE E207                   MOV         #7,R2      ; H'00000007
    000005D0 3E27                   CMP/GT      R2,R14
    000005D2 8949                   BT          L140
               mnet.c        796    
               mnet.c        797    // シュミレーションモード
               mnet.c        798    #if DEBUG_SIM_MODE != 0
               mnet.c        799      return (E_SUCCESS );
               mnet.c        800    #endif
               mnet.c        801      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    000005D4 D547                   MOV.L       L621+6,R5  ; _MNET_DRV_TYPE
    000005D6 60E3                   MOV         R14,R0
    000005D8 005C                   MOV.B       @(R0,R5),R0; MNET_DRV_TYPE[]
    000005DA 880A                   CMP/EQ      #10,R0
    000005DC 8942                   BT          L143
               mnet.c        802      {
               mnet.c        803          return( E_SUCCESS );
               mnet.c        804      }
               mnet.c        805    
               mnet.c        806      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm )); // デバイス接続確認
    000005DE B5DF                   BSR         _IsExist
    000005E0 64E3                   MOV         R14,R4
    000005E2 2008                   TST         R0,R0
    000005E4 8B04                   BF          L145
    000005E6 E604                   MOV         #4,R6      ; H'00000004
    000005E8 4618                   SHLL8       R6
    000005EA 3E6C                   ADD         R6,R14
    000005EC A03E                   BRA         L146
    000005EE 60E3                   MOV         R14,R0
    000005F0              L145:
               mnet.c        807      if (motor_IsBusy(pm))                                   return(( E_BUSY + pm ));    // ビジー確認
    000005F0 B61A                   BSR         _motor_IsBusy
    000005F2 64E3                   MOV         R14,R4
    000005F4 2008                   TST         R0,R0
    000005F6 8904                   BT          L148
    000005F8 E601                   MOV         #1,R6      ; H'00000001
    000005FA 4618                   SHLL8       R6
    000005FC 3E6C                   ADD         R6,R14
    000005FE A035                   BRA         L146
    00000600 60E3                   MOV         R14,R0
    00000602              L148:
    00000602 E064                   MOV         #100,R0    ; H'00000064
    00000604 64E3                   MOV         R14,R4
    00000606 4480                   MULR        R0,R4
               mnet.c        808    
               mnet.c        809      _pmInfo[pm].pos = cnt;
    00000608 D23E                   MOV.L       L621+22,R2 ; H'00000050+__$_pmInfo
    0000060A E5A3                   MOV         #-93,R5    ; H'FFFFFFA3
    0000060C 66D3                   MOV         R13,R6
    0000060E 655C                   EXTU.B      R5,R5
    00000610 6043                   MOV         R4,R0
    00000612 02D6                   MOV.L       R13,@(R0,R2); _pmInfo[].pos
               mnet.c        810    
               mnet.c        811      // PCD4611通信接続時
               mnet.c        812      if( MNET_DRV_TYPE[pm] == PCD4611 )
    00000614 D237                   MOV.L       L621+6,R2  ; _MNET_DRV_TYPE
    00000616 60E3                   MOV         R14,R0
    00000618 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    0000061A 8809                   CMP/EQ      #9,R0
    0000061C 8F06                   BF/S        L150
    0000061E 64E3                   MOV         R14,R4
               mnet.c        813      {
               mnet.c        814          if (!SetMotorRegisterInt(pm, WRG_RCUN1, cnt))       return(( E_MNT_ACCESS + WRG_RCUN1 ));
    00000620 B4CD                   BSR         _SetMotorRegisterInt
    00000622 0009                   NOP
    00000624 2008                   TST         R0,R0
    00000626 8919                   BT          L151
    00000628 A01C                   BRA         L143
    0000062A 0009                   NOP
    0000062C              L150:
               mnet.c        815      }
               mnet.c        816      else
               mnet.c        817      {
               mnet.c        818          if (!SetMotorRegisterInt(pm, WRG_RCUN1, cnt))       return(( E_MNT_ACCESS + WRG_RCUN1 ));
    0000062C B4C7                   BSR         _SetMotorRegisterInt
    0000062E 0009                   NOP
    00000630 2008                   TST         R0,R0
    00000632 8913                   BT          L151
               mnet.c        819          if (!SetMotorRegisterInt(pm, WRG_RCUN2, enc))       return(( E_MNT_ACCESS + WRG_RCUN2 ));
    00000634 E5A4                   MOV         #-92,R5    ; H'FFFFFFA4
    00000636 66C3                   MOV         R12,R6
    00000638 655C                   EXTU.B      R5,R5
    0000063A B4C0                   BSR         _SetMotorRegisterInt
    0000063C 64E3                   MOV         R14,R4
    0000063E 2008                   TST         R0,R0
    00000640 000005A4               MOVI20      #1444,R0   ; H'000005A4
    00000644 8912                   BT          L146
               mnet.c        820          if (!SetMotorRegisterInt(pm, WRG_RCUN3, def))       return(( E_MNT_ACCESS + WRG_RCUN3 ));
    00000646 E5A5                   MOV         #-91,R5    ; H'FFFFFFA5
    00000648 66B3                   MOV         R11,R6
    0000064A 655C                   EXTU.B      R5,R5
    0000064C B4B7                   BSR         _SetMotorRegisterInt
    0000064E 64E3                   MOV         R14,R4
    00000650 2008                   TST         R0,R0
    00000652 8B07                   BF          L143
    00000654 000005A5               MOVI20      #1445,R0   ; H'000005A5
    00000658 A008                   BRA         L146
    0000065A 0009                   NOP
    0000065C              L151:
    0000065C 000005A3               MOVI20      #1443,R0   ; H'000005A3
    00000660 A004                   BRA         L146
    00000662 0009                   NOP
    00000664              L143:
    00000664 A002                   BRA         L146
    00000666 E000                   MOV         #0,R0      ; H'00000000
    00000668              L140:
    00000668 00000801               MOVI20      #2049,R0   ; H'00000801
    0000066C              L146:
    0000066C 4BF4                   MOVMU.L     @R15+,R11
               mnet.c        821      }
               mnet.c        822    
               mnet.c        823      return( E_SUCCESS );
               mnet.c        824    }
    0000066E 006B                   RTS/N
               mnet.c        825    
               mnet.c        826    /*-----------------------------------------------------------------------------
               mnet.c        827      機能：絶対アドレス移動
               mnet.c        828      機能：pm      モータ番号
               mnet.c        829            pos     目的地パルス
               mnet.c        830            status  動作指定
               mnet.c        831      戻値：エラーコード
               mnet.c        832     ----------------------------------------------------------------------------*/
               mnet.c        833    ER motor_ABSMV(UB pm, INT pos, UB status)
    00000670              _motor_ABSMV:                    ; function: motor_ABSMV
                                                           ; frame size=28
    00000670 4BF0                   MOVMU.L     R11,@-R15
    00000672 7FF8                   ADD         #-8,R15
    00000674 4511                   CMP/PZ      R5
               mnet.c        834    {
               mnet.c        835      INT rcnt1 = 0;
               mnet.c        836      ER  Result = E_SUCCESS;
               mnet.c        837      UH  dir = (pos >=0 ? CW : CCW);
    00000676 6B53                   MOV         R5,R11
    00000678 6D4C                   EXTU.B      R4,R13
    0000067A EE02                   MOV         #2,R14     ; H'00000002
    0000067C 8F01                   BF/S        L157
    0000067E 6C63                   MOV         R6,R12
    00000680 EE01                   MOV         #1,R14     ; H'00000001
    00000682              L157:
               mnet.c        838    
               mnet.c        839      if (pm < DVMIN || DVMAX < pm)           return((E_PAR_OUTRNG + PARAM1));
    00000682 E601                   MOV         #1,R6      ; H'00000001
    00000684 3D63                   CMP/GE      R6,R13
    00000686 8901                   BT          L632
    00000688 A088                   BRA         L158
    0000068A 0009                   NOP
    0000068C              L632:
    0000068C E207                   MOV         #7,R2      ; H'00000007
    0000068E 3D27                   CMP/GT      R2,R13
    00000690 8B01                   BF          L633
    00000692 A083                   BRA         L158
    00000694 0009                   NOP
    00000696              L633:
               mnet.c        840    
               mnet.c        841    // シュミレーションモード
               mnet.c        842    #if DEBUG_SIM_MODE != 0
               mnet.c        843      return (E_SUCCESS );
               mnet.c        844    #endif
               mnet.c        845      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00000696 D117                   MOV.L       L621+6,R1  ; _MNET_DRV_TYPE
    00000698 60D3                   MOV         R13,R0
    0000069A 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    0000069C 880A                   CMP/EQ      #10,R0
    0000069E 897B                   BT          L162
               mnet.c        846      {
               mnet.c        847          return( E_SUCCESS );
               mnet.c        848      }
               mnet.c        849    
               mnet.c        850      if (!IsExist( pm ))                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    000006A0 B57E                   BSR         _IsExist
    000006A2 64D3                   MOV         R13,R4
    000006A4 2008                   TST         R0,R0
    000006A6 8972                   BT          L164
               mnet.c        851      if (motor_IsBusy(pm))                   return(( E_BUSY + pm ));        // ビジー確認
    000006A8 B5BE                   BSR         _motor_IsBusy
    000006AA 64D3                   MOV         R13,R4
    000006AC 2008                   TST         R0,R0
    000006AE 8B69                   BF          L166
               mnet.c        852      if (motor_IsLimit(pm, dir))             return( E_SUCCESS );            // 現在リミットか確認
    000006B0 65ED                   EXTU.W      R14,R5
    000006B2 B5FB                   BSR         _motor_IsLimit
    000006B4 64D3                   MOV         R13,R4
    000006B6 2008                   TST         R0,R0
    000006B8 8B6E                   BF          L162
               mnet.c        853    
               mnet.c        854      motor_SetAllRegister(pm);                                               // Limit後だとLimit時の速さのままとなるため、ここで通常の設定速度に変更
    000006BA B6CD                   BSR         __$motor_SetAllRegister
    000006BC 64D3                   MOV         R13,R4
               mnet.c        855      SetMotorCommand (pm, CMD_INTRS);                                        // 割込み出力リセット
    000006BE E508                   MOV         #8,R5      ; H'00000008
    000006C0 B45F                   BSR         __$SetMotorCommand
    000006C2 64D3                   MOV         R13,R4
               mnet.c        856      _pmInfo[pm].reg[R0]     = (INT)pos;
    000006C4 E064                   MOV         #100,R0    ; H'00000064
    000006C6 66D3                   MOV         R13,R6
    000006C8 4680                   MULR        R0,R6
    000006CA D40D                   MOV.L       L621+18,R4 ; __$_pmInfo
    000006CC 6143                   MOV         R4,R1
    000006CE 7124                   ADD         #36,R1
               mnet.c        857    
               mnet.c        858      _pmInfo[pm].startParam  = CMD_STAUD;                                    // スタートコマンド動作指定
    000006D0 6543                   MOV         R4,R5
    000006D2 7560                   ADD         #96,R5
    000006D4 E753                   MOV         #83,R7     ; H'00000053
    000006D6 6063                   MOV         R6,R0
    000006D8 01B6                   MOV.L       R11,@(R0,R1); _pmInfo[].reg[]
    000006DA 0575                   MOV.W       R7,@(R0,R5); _pmInfo[].startParam
               mnet.c        859      if( status == REQ_STAFH )   _pmInfo[pm].startParam  = CMD_STAFH;
    000006DC 60CC                   EXTU.B      R12,R0
    000006DE 8801                   CMP/EQ      #1,R0
    000006E0 8912                   BT          L169
    000006E2 8802                   CMP/EQ      #2,R0
    000006E4 8B13                   BF          L170
               mnet.c        860      if( status == REQ_STAFL )   _pmInfo[pm].startParam  = CMD_STAFL;
    000006E6 E250                   MOV         #80,R2     ; H'00000050
    000006E8 6063                   MOV         R6,R0
    000006EA A010                   BRA         L170
    000006EC 0525                   MOV.W       R2,@(R0,R5); _pmInfo[].startParam
    000006EE              L621:
    000006EE 00000002               .RES.W      1
    000006F0 <00000000>             .DATA.L     L654
    000006F4 <00000000>             .DATA.L     _MNET_DRV_TYPE
    000006F8 <00000000>             .DATA.L     __$motor_CalcMotorRegPCD4611
    000006FC <00000000>             .DATA.L     __$motor_CalcMotorReg
    00000700 <00000000>             .DATA.L     __$_pmInfo
    00000704 <00000050>             .DATA.L     H'00000050+__$_pmInfo
    00000708              L169:
    00000708 E251                   MOV         #81,R2     ; H'00000051
    0000070A 6063                   MOV         R6,R0
    0000070C 0525                   MOV.W       R2,@(R0,R5); _pmInfo[].startParam
    0000070E              L170:
               mnet.c        861      _pmInfo[pm].paused      = FALSE;
    0000070E 7458                   ADD         #88,R4
    00000710 E500                   MOV         #0,R5      ; H'00000000
               mnet.c        862    
               mnet.c        863      
               mnet.c        864      // PCD4611通信接続時
               mnet.c        865      if( MNET_DRV_TYPE[pm] == PCD4611 )
    00000712 D178                   MOV.L       L622+2,R1  ; _MNET_DRV_TYPE
    00000714 6063                   MOV         R6,R0
    00000716 0456                   MOV.L       R5,@(R0,R4); _pmInfo[].paused
    00000718 60D3                   MOV         R13,R0
    0000071A 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    0000071C 8809                   CMP/EQ      #9,R0
    0000071E 8915                   BT          L173
               mnet.c        866      {
               mnet.c        867          WriteMemoryPCD4611(RRG_RCUN1);
               mnet.c        868          rcnt1 = ReadMemoryPCD4611();
               mnet.c        869    
               mnet.c        870          SetMotorRegisterInt( MT_Y0, WRG_RMD, MOD41 );
               mnet.c        871          SetMotorRegisterInt( MT_Y0, WRG_RMV, (pos - rcnt1) );
               mnet.c        872          
               mnet.c        873          WriteMemoryPCD4611( CMD_STAUD );
               mnet.c        874      }
               mnet.c        875      // MNET_BCD4020FU(A)接続時
               mnet.c        876      else
               mnet.c        877      {
               mnet.c        878          Result = SetRenv1Fu( pm );          if( Result != E_SUCCESS )   return( Result );   // RENV1設定
    00000720 D375                   MOV.L       L622+6,R3  ; __$SetRenv1Fu
    00000722 430B                   JSR         @R3
    00000724 64D3                   MOV         R13,R4
    00000726 2008                   TST         R0,R0
    00000728 8F0E                   BF/S        L175
    0000072A 6203                   MOV         R0,R2
               mnet.c        879          Result = SetRmdFu( pm, MOD42 );     if( Result != E_SUCCESS )   return( Result );   // RMD設定
    0000072C E542                   MOV         #66,R5     ; H'00000042
    0000072E D373                   MOV.L       L622+10,R3 ; __$SetRmdFu
    00000730 430B                   JSR         @R3
    00000732 64D3                   MOV         R13,R4
    00000734 2008                   TST         R0,R0
    00000736 8F07                   BF/S        L175
    00000738 6203                   MOV         R0,R2
               mnet.c        880          Result = SetRmv( pm, pos );         if( Result != E_SUCCESS )   return( Result );   // RMV設定
    0000073A 65B3                   MOV         R11,R5
    0000073C D370                   MOV.L       L622+14,R3 ; __$SetRmv
    0000073E 430B                   JSR         @R3
    00000740 64D3                   MOV         R13,R4
    00000742 2008                   TST         R0,R0
    00000744 8D18                   BT/S        L177
    00000746 6203                   MOV         R0,R2
    00000748              L175:
    00000748 A02A                   BRA         L178
    0000074A 6023                   MOV         R2,R0
    0000074C              L173:
    0000074C B3E1                   BSR         __$WriteMemoryPCD4611
    0000074E E4E3                   MOV         #-29,R4    ; H'FFFFFFE3
    00000750 B3F7                   BSR         __$ReadMemoryPCD4611
    00000752 0009                   NOP
    00000754 E597                   MOV         #-105,R5   ; H'FFFFFF97
    00000756 2F02                   MOV.L       R0,@R15
    00000758 655C                   EXTU.B      R5,R5
    0000075A E641                   MOV         #65,R6     ; H'00000041
    0000075C 6053                   MOV         R5,R0
    0000075E 81F2                   MOV.W       R0,@(4,R15)
    00000760 B42D                   BSR         _SetMotorRegisterInt
    00000762 E401                   MOV         #1,R4      ; H'00000001
    00000764 61F2                   MOV.L       @R15,R1
    00000766 E401                   MOV         #1,R4      ; H'00000001
    00000768 85F2                   MOV.W       @(4,R15),R0
    0000076A 3B18                   SUB         R1,R11
    0000076C 70F9                   ADD         #-7,R0
    0000076E 66B3                   MOV         R11,R6
    00000770 B425                   BSR         _SetMotorRegisterInt
    00000772 6503                   MOV         R0,R5
    00000774 B3CD                   BSR         __$WriteMemoryPCD4611
    00000776 E453                   MOV         #83,R4     ; H'00000053
    00000778              L177:
               mnet.c        881    
               mnet.c        882      }
               mnet.c        883      motor_RegistCommand(pm, CMD_ABSMV);
    00000778 E50A                   MOV         #10,R5     ; H'0000000A
    0000077A D362                   MOV.L       L622+18,R3 ; __$motor_RegistCommand
    0000077C 430B                   JSR         @R3
    0000077E 64D3                   MOV         R13,R4
    00000780 A00A                   BRA         L162
    00000782 0009                   NOP
    00000784              L166:
    00000784 E601                   MOV         #1,R6      ; H'00000001
    00000786 4618                   SHLL8       R6
    00000788 3D6C                   ADD         R6,R13
    0000078A A009                   BRA         L178
    0000078C 60D3                   MOV         R13,R0
    0000078E              L164:
    0000078E E604                   MOV         #4,R6      ; H'00000004
    00000790 4618                   SHLL8       R6
    00000792 3D6C                   ADD         R6,R13
    00000794 A004                   BRA         L178
    00000796 60D3                   MOV         R13,R0
    00000798              L162:
    00000798 A002                   BRA         L178
    0000079A E000                   MOV         #0,R0      ; H'00000000
    0000079C              L158:
    0000079C 00000801               MOVI20      #2049,R0   ; H'00000801
    000007A0              L178:
    000007A0 7F08                   ADD         #8,R15
    000007A2 4BF4                   MOVMU.L     @R15+,R11
               mnet.c        884      
               mnet.c        885      return( E_SUCCESS );
               mnet.c        886    }
    000007A4 006B                   RTS/N
               mnet.c        887    /*-----------------------------------------------------------------------------
               mnet.c        888      機能：相対アドレス移動
               mnet.c        889      機能：pm      モータ番号
               mnet.c        890            pos     目的地パルス
               mnet.c        891            status  動作指定
               mnet.c        892      戻値：エラーコード
               mnet.c        893     ----------------------------------------------------------------------------*/
               mnet.c        894    ER motor_RELMV(UB pm, INT pos, UB status)
    000007A6              _motor_RELMV:                    ; function: motor_RELMV
                                                           ; frame size=28
    000007A6 4AF0                   MOVMU.L     R10,@-R15
    000007A8 7FFC                   ADD         #-4,R15
    000007AA 4511                   CMP/PZ      R5
               mnet.c        895    {
               mnet.c        896      unsigned long   setValue;
               mnet.c        897      UB  mod;
               mnet.c        898      ER  Result = E_SUCCESS;
               mnet.c        899      UH  dir = (pos >=0 ? CW : CCW);
    000007AC 6B53                   MOV         R5,R11
    000007AE 6D43                   MOV         R4,R13
    000007B0 EE02                   MOV         #2,R14     ; H'00000002
    000007B2 8F01                   BF/S        L181
    000007B4 6C63                   MOV         R6,R12
    000007B6 EE01                   MOV         #1,R14     ; H'00000001
    000007B8              L181:
               mnet.c        900    
               mnet.c        901      if (pm < DVMIN || DVMAX < pm)           return(( E_PAR_OUTRNG + PARAM1 ));
    000007B8 6ADC                   EXTU.B      R13,R10
    000007BA E601                   MOV         #1,R6      ; H'00000001
    000007BC 3A63                   CMP/GE      R6,R10
    000007BE 8B6B                   BF          L182
    000007C0 E207                   MOV         #7,R2      ; H'00000007
    000007C2 3A27                   CMP/GT      R2,R10
    000007C4 8968                   BT          L182
               mnet.c        902    
               mnet.c        903    // シュミレーションモード
               mnet.c        904    #if DEBUG_SIM_MODE != 0
               mnet.c        905      return (E_SUCCESS );
               mnet.c        906    #endif
               mnet.c        907      if (!IsExist( pm ))                     return(( E_CON_ERR + pm )); // デバイス接続確認
    000007C6 B4EB                   BSR         _IsExist
    000007C8 64A3                   MOV         R10,R4
    000007CA 2008                   TST         R0,R0
    000007CC 895F                   BT          L186
               mnet.c        908      if (motor_IsBusy(pm))                   return(( E_BUSY + pm ));    // ビジー確認
    000007CE B52B                   BSR         _motor_IsBusy
    000007D0 64A3                   MOV         R10,R4
    000007D2 2008                   TST         R0,R0
    000007D4 8B56                   BF          L188
               mnet.c        909      if (motor_IsLimit(pm, dir))             return( E_SUCCESS );        // 現在リミットか確認
    000007D6 65ED                   EXTU.W      R14,R5
    000007D8 B568                   BSR         _motor_IsLimit
    000007DA 64A3                   MOV         R10,R4
    000007DC 2008                   TST         R0,R0
    000007DE 8B4F                   BF          L190
               mnet.c        910    
               mnet.c        911      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    000007E0 D644                   MOV.L       L622+2,R6  ; _MNET_DRV_TYPE
    000007E2 6DDC                   EXTU.B      R13,R13
    000007E4 60D3                   MOV         R13,R0
    000007E6 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    000007E8 880A                   CMP/EQ      #10,R0
    000007EA 8949                   BT          L190
               mnet.c        912      {
               mnet.c        913          return( E_SUCCESS );
               mnet.c        914      }
               mnet.c        915      
               mnet.c        916      // PCD4611通信接続時
               mnet.c        917      if( MNET_DRV_TYPE[pm] == PCD4611 )
    000007EC 8809                   CMP/EQ      #9,R0
    000007EE 893B                   BT          L193
               mnet.c        918      {
               mnet.c        919          WriteMemoryIntPCD4611( MOD41 );
               mnet.c        920          WriteMemoryPCD4611( WRG_RMD );
               mnet.c        921    
               mnet.c        922          WriteMemoryIntPCD4611( pos );
               mnet.c        923          WriteMemoryPCD4611( WRG_RMV );
               mnet.c        924          
               mnet.c        925          WriteMemoryPCD4611( CMD_STAUD );
               mnet.c        926      }
               mnet.c        927      // MNET_BCD4020FU(A)接続時
               mnet.c        928      else
               mnet.c        929      {
               mnet.c        930          motor_SetAllRegister(pm);                                           // Limit後だとLimit時の速さのままとなるため、ここで通常の設定速度に変更
    000007F0 B632                   BSR         __$motor_SetAllRegister
    000007F2 64A3                   MOV         R10,R4
               mnet.c        931          SetMotorCommand (pm, CMD_INTRS);                                    // 割込み出力リセット
    000007F4 E508                   MOV         #8,R5      ; H'00000008
    000007F6 B3C4                   BSR         __$SetMotorCommand
    000007F8 64A3                   MOV         R10,R4
               mnet.c        932          _pmInfo[pm].reg[R0]     = (INT)pos;
    000007FA E064                   MOV         #100,R0    ; H'00000064
    000007FC E653                   MOV         #83,R6     ; H'00000053
    000007FE 4D80                   MULR        R0,R13
    00000800 D441                   MOV.L       L622+22,R4 ; __$_pmInfo
    00000802 6143                   MOV         R4,R1
    00000804 7124                   ADD         #36,R1
               mnet.c        933    
               mnet.c        934          _pmInfo[pm].startParam  = CMD_STAUD;                                // スタートコマンド動作指定
    00000806 6543                   MOV         R4,R5
    00000808 7560                   ADD         #96,R5
    0000080A 60D3                   MOV         R13,R0
    0000080C 01B6                   MOV.L       R11,@(R0,R1); _pmInfo[].reg[]
    0000080E 0565                   MOV.W       R6,@(R0,R5); _pmInfo[].startParam
               mnet.c        935          if( status == REQ_STAFH )   _pmInfo[pm].startParam  = CMD_STAFH;
    00000810 60CC                   EXTU.B      R12,R0
    00000812 8801                   CMP/EQ      #1,R0
    00000814 8905                   BT          L195
    00000816 8802                   CMP/EQ      #2,R0
    00000818 8B06                   BF          L196
               mnet.c        936          if( status == REQ_STAFL )   _pmInfo[pm].startParam  = CMD_STAFL;
    0000081A E250                   MOV         #80,R2     ; H'00000050
    0000081C 60D3                   MOV         R13,R0
    0000081E A003                   BRA         L196
    00000820 0525                   MOV.W       R2,@(R0,R5); _pmInfo[].startParam
    00000822              L195:
    00000822 E251                   MOV         #81,R2     ; H'00000051
    00000824 60D3                   MOV         R13,R0
    00000826 0525                   MOV.W       R2,@(R0,R5); _pmInfo[].startParam
    00000828              L196:
               mnet.c        937          
               mnet.c        938          _pmInfo[pm].paused      = FALSE;
    00000828 7458                   ADD         #88,R4
    0000082A E500                   MOV         #0,R5      ; H'00000000
    0000082C 60D3                   MOV         R13,R0
    0000082E 0456                   MOV.L       R5,@(R0,R4); _pmInfo[].paused
               mnet.c        939    
               mnet.c        940          Result = SetRenv1Fu( pm );          if( Result != E_SUCCESS )   return( Result );   // RENV1設定
    00000830 D331                   MOV.L       L622+6,R3  ; __$SetRenv1Fu
    00000832 430B                   JSR         @R3
    00000834 64A3                   MOV         R10,R4
    00000836 2008                   TST         R0,R0
    00000838 8F14                   BF/S        L199
    0000083A 6203                   MOV         R0,R2
               mnet.c        941          Result = SetRmdFu( pm, MOD41 );     if( Result != E_SUCCESS )   return( Result );   // RMD設定
    0000083C E541                   MOV         #65,R5     ; H'00000041
    0000083E D32F                   MOV.L       L622+10,R3 ; __$SetRmdFu
    00000840 430B                   JSR         @R3
    00000842 64A3                   MOV         R10,R4
    00000844 2008                   TST         R0,R0
    00000846 8F0D                   BF/S        L199
    00000848 6203                   MOV         R0,R2
               mnet.c        942          Result = SetRmv( pm, pos );         if( Result != E_SUCCESS )   return( Result );   // RMV設定
    0000084A 65B3                   MOV         R11,R5
    0000084C D32C                   MOV.L       L622+14,R3 ; __$SetRmv
    0000084E 430B                   JSR         @R3
    00000850 64A3                   MOV         R10,R4
    00000852 2008                   TST         R0,R0
    00000854 8F06                   BF/S        L199
    00000856 6203                   MOV         R0,R2
               mnet.c        943          
               mnet.c        944          motor_RegistCommand(pm, CMD_RELMV); 
    00000858 E509                   MOV         #9,R5      ; H'00000009
    0000085A D32A                   MOV.L       L622+18,R3 ; __$motor_RegistCommand
    0000085C 430B                   JSR         @R3
    0000085E 64A3                   MOV         R10,R4
    00000860 A00E                   BRA         L190
    00000862 0009                   NOP
    00000864              L199:
    00000864 A01A                   BRA         L202
    00000866 6023                   MOV         R2,R0
    00000868              L193:
    00000868 B358                   BSR         __$WriteMemoryIntPCD4611
    0000086A E441                   MOV         #65,R4     ; H'00000041
    0000086C E497                   MOV         #-105,R4   ; H'FFFFFF97
    0000086E B350                   BSR         __$WriteMemoryPCD4611
    00000870 2F40                   MOV.B       R4,@R15
    00000872 B353                   BSR         __$WriteMemoryIntPCD4611
    00000874 64B3                   MOV         R11,R4
    00000876 64F0                   MOV.B       @R15,R4
    00000878 B34B                   BSR         __$WriteMemoryPCD4611
    0000087A 74F9                   ADD         #-7,R4
    0000087C B349                   BSR         __$WriteMemoryPCD4611
    0000087E E453                   MOV         #83,R4     ; H'00000053
    00000880              L190:
    00000880 A00C                   BRA         L202
    00000882 E000                   MOV         #0,R0      ; H'00000000
    00000884              L188:
    00000884 E601                   MOV         #1,R6      ; H'00000001
    00000886 60DC                   EXTU.B      R13,R0
    00000888 4618                   SHLL8       R6
    0000088A A007                   BRA         L202
    0000088C 306C                   ADD         R6,R0
    0000088E              L186:
    0000088E E604                   MOV         #4,R6      ; H'00000004
    00000890 60DC                   EXTU.B      R13,R0
    00000892 4618                   SHLL8       R6
    00000894 A002                   BRA         L202
    00000896 306C                   ADD         R6,R0
    00000898              L182:
    00000898 00000801               MOVI20      #2049,R0   ; H'00000801
    0000089C              L202:
    0000089C 7F04                   ADD         #4,R15
    0000089E 4AF4                   MOVMU.L     @R15+,R10
               mnet.c        945      }
               mnet.c        946      return( E_SUCCESS );
               mnet.c        947    }
    000008A0 006B                   RTS/N
               mnet.c        948    
               mnet.c        949    /*-----------------------------------------------------------------------------
               mnet.c        950      機能：リミット位置移動
               mnet.c        951      機能：no      モータ番号
               mnet.c        952            dir     方向(MOTOR_CW/MOTOR_CCW)
               mnet.c        953            spd     速度(定速)
               mnet.c        954            st      リザーブ
               mnet.c        955      戻値：エラーコード
               mnet.c        956     ----------------------------------------------------------------------------*/
               mnet.c        957    ER motor_LIMIT(UB mm, UB dr, UB md, INT sp )
    000008A2              _motor_LIMIT:                    ; function: motor_LIMIT
                                                           ; frame size=20
    000008A2 4BF0                   MOVMU.L     R11,@-R15
    000008A4 6E4C                   EXTU.B      R4,R14
    000008A6 E101                   MOV         #1,R1      ; H'00000001
    000008A8 3E13                   CMP/GE      R1,R14
               mnet.c        958    {
               mnet.c        959      ER  Result = E_SUCCESS;
               mnet.c        960      UB  mod;
               mnet.c        961      
               mnet.c        962      if (mm < DVMIN || DVMAX < mm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    000008AA 6B73                   MOV         R7,R11
    000008AC 6C53                   MOV         R5,R12
    000008AE 8D02                   BT/S        L634
    000008B0 6D63                   MOV         R6,R13
    000008B2 A091                   BRA         L205
    000008B4 0009                   NOP
    000008B6              L634:
    000008B6 E207                   MOV         #7,R2      ; H'00000007
    000008B8 3E27                   CMP/GT      R2,R14
    000008BA 8B01                   BF          L635
    000008BC A08C                   BRA         L205
    000008BE 0009                   NOP
    000008C0              L635:
               mnet.c        963    
               mnet.c        964    // シュミレーションモード
               mnet.c        965    #if DEBUG_SIM_MODE != 0
               mnet.c        966      return (E_SUCCESS );
               mnet.c        967    #endif
               mnet.c        968    
               mnet.c        969      if( MNET_DRV_TYPE[mm] == NCPRSUNIT )// 圧力ユニット
    000008C0 D10C                   MOV.L       L622+2,R1  ; _MNET_DRV_TYPE
    000008C2 60E3                   MOV         R14,R0
    000008C4 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    000008C6 880A                   CMP/EQ      #10,R0
    000008C8 8B01                   BF          L636
    000008CA A083                   BRA         L208
    000008CC 0009                   NOP
    000008CE              L636:
               mnet.c        970      {
               mnet.c        971          return( E_SUCCESS );
               mnet.c        972      }
               mnet.c        973      
               mnet.c        974      if (!IsExist( mm ))                                     return(( E_CON_ERR + mm )); // デバイス接続確認
    000008CE B467                   BSR         _IsExist
    000008D0 64E3                   MOV         R14,R4
    000008D2 2008                   TST         R0,R0
    000008D4 8B04                   BF          L210
    000008D6 E604                   MOV         #4,R6      ; H'00000004
    000008D8 4618                   SHLL8       R6
    000008DA 3E6C                   ADD         R6,R14
    000008DC A07E                   BRA         L211
    000008DE 60E3                   MOV         R14,R0
    000008E0              L210:
               mnet.c        975      if (motor_IsBusy(mm))                                   return(( E_BUSY + mm ));    // ビジー確認
    000008E0 B4A2                   BSR         _motor_IsBusy
    000008E2 64E3                   MOV         R14,R4
    000008E4 2008                   TST         R0,R0
    000008E6 8911                   BT          L213
    000008E8 E601                   MOV         #1,R6      ; H'00000001
    000008EA 4618                   SHLL8       R6
    000008EC 3E6C                   ADD         R6,R14
    000008EE A075                   BRA         L211
    000008F0 60E3                   MOV         R14,R0
    000008F2              L622:
    000008F2 00000002               .RES.W      1
    000008F4 <00000000>             .DATA.L     _MNET_DRV_TYPE
    000008F8 <00000000>             .DATA.L     __$SetRenv1Fu
    000008FC <00000000>             .DATA.L     __$SetRmdFu
    00000900 <00000000>             .DATA.L     __$SetRmv
    00000904 <00000000>             .DATA.L     __$motor_RegistCommand
    00000908 <00000000>             .DATA.L     __$_pmInfo
    0000090C              L213:
               mnet.c        976    
               mnet.c        977      // PCD4611通信接続時
               mnet.c        978      if( MNET_DRV_TYPE[mm] == PCD4611 )
    0000090C D187                   MOV.L       L623,R1    ; _MNET_DRV_TYPE
    0000090E 60E3                   MOV         R14,R0
    00000910 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    00000912 8809                   CMP/EQ      #9,R0
    00000914 8919                   BT          L214
               mnet.c        979      {
               mnet.c        980    //        if( dr == CW )  mod = MOD00;
               mnet.c        981    //        else            mod = MOD08;
               mnet.c        982          if( dr == CW )  mod = MOD10;
               mnet.c        983          else            mod = MOD18;
               mnet.c        984    
               mnet.c        985          WriteMemoryIntPCD4611( mod );
               mnet.c        986          WriteMemoryPCD4611( WRG_RMD );
               mnet.c        987          
               mnet.c        988          WriteMemoryPCD4611( CMD_STAFL );
               mnet.c        989      }
               mnet.c        990      // MNET_BCD4020FU(A)接続時
               mnet.c        991      else
               mnet.c        992      {
               mnet.c        993          SetMotorCommand (mm, CMD_INTRS);            // 割込み出力リセット
    00000916 E508                   MOV         #8,R5      ; H'00000008
    00000918 B333                   BSR         __$SetMotorCommand
    0000091A 64E3                   MOV         R14,R4
               mnet.c        994    
               mnet.c        995          _pmInfo[mm].reg[R0]     = 0xFFFFFF;
    0000091C E064                   MOV         #100,R0    ; H'00000064
    0000091E 65E3                   MOV         R14,R5
    00000920 4580                   MULR        R0,R5
    00000922 02110000               MOVI20S     #16777216,R2; H'01000000
    00000926 E650                   MOV         #80,R6     ; H'00000050
    00000928 D481                   MOV.L       L623+4,R4  ; __$_pmInfo
    0000092A 6743                   MOV         R4,R7
    0000092C 7724                   ADD         #36,R7
    0000092E 72FF                   ADD         #-1,R2
               mnet.c        996          _pmInfo[mm].startParam  = CMD_STAFL;
    00000930 6143                   MOV         R4,R1
    00000932 7160                   ADD         #96,R1
    00000934 6053                   MOV         R5,R0
    00000936 0726                   MOV.L       R2,@(R0,R7); _pmInfo[].reg[]
               mnet.c        997          _pmInfo[mm].paused      = FALSE;
    00000938 7458                   ADD         #88,R4
    0000093A 0165                   MOV.W       R6,@(R0,R1); _pmInfo[].startParam
    0000093C E200                   MOV         #0,R2      ; H'00000000
               mnet.c        998    
               mnet.c        999          if( MNET_DRV_TYPE[mm] == PCD4611 )          // PCD4611通信接続時
    0000093E D17B                   MOV.L       L623,R1    ; _MNET_DRV_TYPE
    00000940 0426                   MOV.L       R2,@(R0,R4); _pmInfo[].paused
    00000942 60E3                   MOV         R14,R0
    00000944 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    00000946 8809                   CMP/EQ      #9,R0
    00000948 8B0C                   BF          L216
    0000094A              L214:
               mnet.c       1000          {
               mnet.c       1001              if( dr == CW )  mod = MOD10;
    0000094A 60CC                   EXTU.B      R12,R0
    0000094C 8801                   CMP/EQ      #1,R0
    0000094E 8F01                   BF/S        L218
    00000950 E218                   MOV         #24,R2     ; H'00000018
    00000952 E210                   MOV         #16,R2     ; H'00000010
    00000954              L218:
    00000954 B2E2                   BSR         __$WriteMemoryIntPCD4611
    00000956 6423                   MOV         R2,R4
    00000958 B2DB                   BSR         __$WriteMemoryPCD4611
    0000095A E497                   MOV         #-105,R4   ; H'FFFFFF97
    0000095C B2D9                   BSR         __$WriteMemoryPCD4611
    0000095E E450                   MOV         #80,R4     ; H'00000050
    00000960 A038                   BRA         L208
    00000962 0009                   NOP
    00000964              L216:
               mnet.c       1002              else            mod = MOD18;
               mnet.c       1003              
               mnet.c       1004              WriteMemoryIntPCD4611( mod );
               mnet.c       1005              WriteMemoryPCD4611( WRG_RMD );
               mnet.c       1006              WriteMemoryPCD4611( CMD_STAFL );
               mnet.c       1007          }
               mnet.c       1008          // MNET_BCD4020FU(A)接続時
               mnet.c       1009          else
               mnet.c       1010          {
               mnet.c       1011              Result = SetRenv1Fu( mm );                          if( Result != E_SUCCESS )   return( Result );   // RENV1設定
    00000964 D373                   MOV.L       L623+8,R3  ; __$SetRenv1Fu
    00000966 430B                   JSR         @R3
    00000968 64E3                   MOV         R14,R4
    0000096A 2008                   TST         R0,R0
    0000096C 8F30                   BF/S        L220
    0000096E 6603                   MOV         R0,R6
    00000970 6DDC                   EXTU.B      R13,R13
    00000972 E003                   MOV         #3,R0      ; H'00000003
    00000974 4D80                   MULR        R0,R13
    00000976 60CC                   EXTU.B      R12,R0
               mnet.c       1012              Result = SetRmdFu( mm, LMMOD_TBL[md][dr] );         if( Result != E_SUCCESS )   return( Result );   // RMD設定
    00000978 D76F                   MOV.L       L623+12,R7 ; __$LMMOD_TBL
    0000097A 64E3                   MOV         R14,R4
    0000097C 30DC                   ADD         R13,R0
    0000097E D36F                   MOV.L       L623+16,R3 ; __$SetRmdFu
    00000980 430B                   JSR         @R3
    00000982 057C                   MOV.B       @(R0,R7),R5; LMMOD_TBL[]
    00000984 2008                   TST         R0,R0
    00000986 8F23                   BF/S        L220
    00000988 6603                   MOV         R0,R6
               mnet.c       1013    
               mnet.c       1014              if (!SetMotorRegisterInt(mm, WRG_RFL, sp))          return(( E_MNT_ACCESS + WRG_RFL ));
    0000098A E591                   MOV         #-111,R5   ; H'FFFFFF91
    0000098C 66B3                   MOV         R11,R6
    0000098E 655C                   EXTU.B      R5,R5
    00000990 B315                   BSR         _SetMotorRegisterInt
    00000992 64E3                   MOV         R14,R4
    00000994 2008                   TST         R0,R0
    00000996 00000591               MOVI20      #1425,R0   ; H'00000591
    0000099A 891F                   BT          L211
               mnet.c       1015              if (!SetMotorRegisterInt(mm, WRG_RFH, sp))          return(( E_MNT_ACCESS + WRG_RFH ));
    0000099C E592                   MOV         #-110,R5   ; H'FFFFFF92
    0000099E 66B3                   MOV         R11,R6
    000009A0 655C                   EXTU.B      R5,R5
    000009A2 B30C                   BSR         _SetMotorRegisterInt
    000009A4 64E3                   MOV         R14,R4
    000009A6 2008                   TST         R0,R0
    000009A8 00000592               MOVI20      #1426,R0   ; H'00000592
    000009AC 8916                   BT          L211
               mnet.c       1016              if (!SetMotorRegisterInt(mm, WRG_RMG, 199))         return(( E_MNT_ACCESS + WRG_RMG ));
    000009AE E6C7                   MOV         #-57,R6    ; H'FFFFFFC7
    000009B0 E595                   MOV         #-107,R5   ; H'FFFFFF95
    000009B2 666C                   EXTU.B      R6,R6
    000009B4 655C                   EXTU.B      R5,R5
    000009B6 B302                   BSR         _SetMotorRegisterInt
    000009B8 64E3                   MOV         R14,R4
    000009BA 2008                   TST         R0,R0
    000009BC 8B03                   BF          L225
    000009BE 00000595               MOVI20      #1429,R0   ; H'00000595
    000009C2 A00B                   BRA         L211
    000009C4 0009                   NOP
    000009C6              L225:
               mnet.c       1017              motor_RegistCommand(mm, CMD_LIMIT);
    000009C6 E50C                   MOV         #12,R5     ; H'0000000C
    000009C8 B763                   BSR         __$motor_RegistCommand
    000009CA 64E3                   MOV         R14,R4
    000009CC A002                   BRA         L208
    000009CE 0009                   NOP
    000009D0              L220:
    000009D0 A004                   BRA         L211
    000009D2 6063                   MOV         R6,R0
    000009D4              L208:
    000009D4 A002                   BRA         L211
    000009D6 E000                   MOV         #0,R0      ; H'00000000
    000009D8              L205:
    000009D8 00000801               MOVI20      #2049,R0   ; H'00000801
    000009DC              L211:
    000009DC 4BF4                   MOVMU.L     @R15+,R11
               mnet.c       1018          }
               mnet.c       1019      }
               mnet.c       1020      return( E_SUCCESS );
               mnet.c       1021    }
    000009DE 006B                   RTS/N
               mnet.c       1022    
               mnet.c       1023    
               mnet.c       1024    /*-----------------------------------------------------------------------------
               mnet.c       1025      機能：減速停止
               mnet.c       1026      機能：no      モータ番号
               mnet.c       1027      戻値：エラーコード
               mnet.c       1028     ----------------------------------------------------------------------------*/
               mnet.c       1029    ER motor_STOP(UB pm)
    000009E0              _motor_STOP:                     ; function: motor_STOP
                                                           ; frame size=12
    000009E0 4DF0                   MOVMU.L     R13,@-R15
               mnet.c       1030    {
               mnet.c       1031      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    000009E2 6D4C                   EXTU.B      R4,R13
    000009E4 E601                   MOV         #1,R6      ; H'00000001
    000009E6 3D63                   CMP/GE      R6,R13
    000009E8 8B20                   BF          L228
    000009EA E207                   MOV         #7,R2      ; H'00000007
    000009EC 3D27                   CMP/GT      R2,R13
    000009EE 891D                   BT          L228
               mnet.c       1032    
               mnet.c       1033    // シュミレーションモード
               mnet.c       1034    #if DEBUG_SIM_MODE != 0
               mnet.c       1035      return (E_SUCCESS );
               mnet.c       1036    #endif
               mnet.c       1037      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    000009F0 D64E                   MOV.L       L623,R6    ; _MNET_DRV_TYPE
    000009F2 6E4C                   EXTU.B      R4,R14
    000009F4 60E3                   MOV         R14,R0
    000009F6 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    000009F8 880A                   CMP/EQ      #10,R0
    000009FA 8915                   BT          L231
               mnet.c       1038      {
               mnet.c       1039          return( E_SUCCESS );
               mnet.c       1040      }
               mnet.c       1041      
               mnet.c       1042    
               mnet.c       1043      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    000009FC B3D0                   BSR         _IsExist
    000009FE 64D3                   MOV         R13,R4
    00000A00 2008                   TST         R0,R0
    00000A02 8B04                   BF          L233
    00000A04 E604                   MOV         #4,R6      ; H'00000004
    00000A06 4618                   SHLL8       R6
    00000A08 3E6C                   ADD         R6,R14
    00000A0A A011                   BRA         L234
    00000A0C 60E3                   MOV         R14,R0
    00000A0E              L233:
               mnet.c       1044      motor_RegistCommand(pm, CMD_STOP);
    00000A0E E549                   MOV         #73,R5     ; H'00000049
    00000A10 B73F                   BSR         __$motor_RegistCommand
    00000A12 64D3                   MOV         R13,R4
               mnet.c       1045      if( !SetMotorCommand(pm, CMD_SDSTP) )                   return(( E_BUSY + pm ));
    00000A14 E54A                   MOV         #74,R5     ; H'0000004A
    00000A16 B2B4                   BSR         __$SetMotorCommand
    00000A18 64D3                   MOV         R13,R4
    00000A1A 2008                   TST         R0,R0
    00000A1C 8B04                   BF          L231
    00000A1E E601                   MOV         #1,R6      ; H'00000001
    00000A20 4618                   SHLL8       R6
    00000A22 3E6C                   ADD         R6,R14
    00000A24 A004                   BRA         L234
    00000A26 60E3                   MOV         R14,R0
    00000A28              L231:
    00000A28 A002                   BRA         L234
    00000A2A E000                   MOV         #0,R0      ; H'00000000
    00000A2C              L228:
    00000A2C 00000801               MOVI20      #2049,R0   ; H'00000801
    00000A30              L234:
    00000A30 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1046    
               mnet.c       1047      return( E_SUCCESS );
               mnet.c       1048    }
    00000A32 006B                   RTS/N
               mnet.c       1049    
               mnet.c       1050    /*-----------------------------------------------------------------------------
               mnet.c       1051      機能：即停止
               mnet.c       1052      機能：no      モータ番号
               mnet.c       1053      戻値：エラーコード
               mnet.c       1054     ----------------------------------------------------------------------------*/
               mnet.c       1055    ER motor_ABORT(UB pm)
    00000A34              _motor_ABORT:                    ; function: motor_ABORT
                                                           ; frame size=12
    00000A34 4DF0                   MOVMU.L     R13,@-R15
               mnet.c       1056    {
               mnet.c       1057      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000A36 6D4C                   EXTU.B      R4,R13
    00000A38 E601                   MOV         #1,R6      ; H'00000001
    00000A3A 3D63                   CMP/GE      R6,R13
    00000A3C 8B1D                   BF          L238
    00000A3E E207                   MOV         #7,R2      ; H'00000007
    00000A40 3D27                   CMP/GT      R2,R13
    00000A42 891A                   BT          L238
               mnet.c       1058    
               mnet.c       1059    // シュミレーションモード
               mnet.c       1060    #if DEBUG_SIM_MODE != 0
               mnet.c       1061      return (E_SUCCESS );
               mnet.c       1062    #endif
               mnet.c       1063      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00000A44 D639                   MOV.L       L623,R6    ; _MNET_DRV_TYPE
    00000A46 6E4C                   EXTU.B      R4,R14
    00000A48 60E3                   MOV         R14,R0
    00000A4A 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00000A4C 880A                   CMP/EQ      #10,R0
    00000A4E 8912                   BT          L241
               mnet.c       1064      {
               mnet.c       1065          return( E_SUCCESS );
               mnet.c       1066      }
               mnet.c       1067      
               mnet.c       1068      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    00000A50 B3A6                   BSR         _IsExist
    00000A52 64D3                   MOV         R13,R4
    00000A54 2008                   TST         R0,R0
    00000A56 8B04                   BF          L243
    00000A58 E604                   MOV         #4,R6      ; H'00000004
    00000A5A 4618                   SHLL8       R6
    00000A5C 3E6C                   ADD         R6,R14
    00000A5E A00E                   BRA         L244
    00000A60 60E3                   MOV         R14,R0
    00000A62              L243:
               mnet.c       1069      if( !SetMotorCommand(pm, CMD_STOP))                     return(( E_BUSY + pm ));
    00000A62 E549                   MOV         #73,R5     ; H'00000049
    00000A64 B28D                   BSR         __$SetMotorCommand
    00000A66 64D3                   MOV         R13,R4
    00000A68 2008                   TST         R0,R0
    00000A6A 8B04                   BF          L241
    00000A6C E601                   MOV         #1,R6      ; H'00000001
    00000A6E 4618                   SHLL8       R6
    00000A70 3E6C                   ADD         R6,R14
    00000A72 A004                   BRA         L244
    00000A74 60E3                   MOV         R14,R0
    00000A76              L241:
    00000A76 A002                   BRA         L244
    00000A78 E000                   MOV         #0,R0      ; H'00000000
    00000A7A              L238:
    00000A7A 00000801               MOVI20      #2049,R0   ; H'00000801
    00000A7E              L244:
    00000A7E 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1070    
               mnet.c       1071      return( E_SUCCESS );
               mnet.c       1072    }
    00000A80 006B                   RTS/N
               mnet.c       1073    
               mnet.c       1074    /*-----------------------------------------------------------------------------
               mnet.c       1075      機能：励磁のON/OFF設定
               mnet.c       1076      機能：no      モータ番号
               mnet.c       1077            sw      １：励磁ON、０：励磁OFF
               mnet.c       1078      戻値：エラーコード
               mnet.c       1079     ----------------------------------------------------------------------------*/
               mnet.c       1080    ER motor_POWER(UB pm, UB sw)
    00000A82              _motor_POWER:                    ; function: motor_POWER
                                                           ; frame size=16
    00000A82 4CF0                   MOVMU.L     R12,@-R15
    00000A84 6D4C                   EXTU.B      R4,R13
    00000A86 E601                   MOV         #1,R6      ; H'00000001
    00000A88 3D63                   CMP/GE      R6,R13
               mnet.c       1081    {
               mnet.c       1082      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000A8A 8F2D                   BF/S        L248
    00000A8C 6C53                   MOV         R5,R12
    00000A8E E207                   MOV         #7,R2      ; H'00000007
    00000A90 3D27                   CMP/GT      R2,R13
    00000A92 8929                   BT          L248
               mnet.c       1083    
               mnet.c       1084    // シュミレーションモード
               mnet.c       1085    #if DEBUG_SIM_MODE != 0
               mnet.c       1086      return (E_SUCCESS );
               mnet.c       1087    #endif
               mnet.c       1088      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00000A94 D625                   MOV.L       L623,R6    ; _MNET_DRV_TYPE
    00000A96 6E4C                   EXTU.B      R4,R14
    00000A98 60E3                   MOV         R14,R0
    00000A9A 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00000A9C 880A                   CMP/EQ      #10,R0
    00000A9E 8921                   BT          L251
               mnet.c       1089      {
               mnet.c       1090          return( E_SUCCESS );
               mnet.c       1091      }
               mnet.c       1092    
               mnet.c       1093      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    00000AA0 B37E                   BSR         _IsExist
    00000AA2 64D3                   MOV         R13,R4
    00000AA4 2008                   TST         R0,R0
    00000AA6 8B04                   BF          L253
    00000AA8 E604                   MOV         #4,R6      ; H'00000004
    00000AAA 4618                   SHLL8       R6
    00000AAC 3E6C                   ADD         R6,R14
    00000AAE A01D                   BRA         L254
    00000AB0 60E3                   MOV         R14,R0
    00000AB2              L253:
               mnet.c       1094      if (motor_IsBusy(pm))                                   return(( E_BUSY + pm ));        // ビジー確認
    00000AB2 B3B9                   BSR         _motor_IsBusy
    00000AB4 64D3                   MOV         R13,R4
    00000AB6 2008                   TST         R0,R0
    00000AB8 8904                   BT          L256
    00000ABA E601                   MOV         #1,R6      ; H'00000001
    00000ABC 4618                   SHLL8       R6
    00000ABE 3E6C                   ADD         R6,R14
    00000AC0 A014                   BRA         L254
    00000AC2 60E3                   MOV         R14,R0
    00000AC4              L256:
               mnet.c       1095      if (!motor_PowerUp(pm, sw))                             return(( E_CUR_ERR + pm ));     // 励磁
    00000AC4 65CC                   EXTU.B      R12,R5
    00000AC6 B452                   BSR         _motor_PowerUp
    00000AC8 64D3                   MOV         R13,R4
    00000ACA 2008                   TST         R0,R0
    00000ACC 8B04                   BF          L258
    00000ACE E602                   MOV         #2,R6      ; H'00000002
    00000AD0 4618                   SHLL8       R6
    00000AD2 3E6C                   ADD         R6,R14
    00000AD4 A00A                   BRA         L254
    00000AD6 60E3                   MOV         R14,R0
    00000AD8              L258:
    00000AD8 E064                   MOV         #100,R0    ; H'00000064
    00000ADA 6CCC                   EXTU.B      R12,R12
    00000ADC 4E80                   MULR        R0,R14
               mnet.c       1096    
               mnet.c       1097      _pmInfo[pm].power = sw;
    00000ADE D218                   MOV.L       L623+20,R2 ; H'00000054+__$_pmInfo
    00000AE0 60E3                   MOV         R14,R0
    00000AE2 02C5                   MOV.W       R12,@(R0,R2); _pmInfo[].power
    00000AE4              L251:
    00000AE4 A002                   BRA         L254
    00000AE6 E000                   MOV         #0,R0      ; H'00000000
    00000AE8              L248:
    00000AE8 00000801               MOVI20      #2049,R0   ; H'00000801
    00000AEC              L254:
    00000AEC 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1098    
               mnet.c       1099      return ( E_SUCCESS );
               mnet.c       1100    }
    00000AEE 006B                   RTS/N
               mnet.c       1101    
               mnet.c       1102    /*-----------------------------------------------------------------------------
               mnet.c       1103      機能：モータ状態の読み出し
               mnet.c       1104      機能：no      モータ番号
               mnet.c       1105      戻値：エラーコード
               mnet.c       1106     ----------------------------------------------------------------------------*/
               mnet.c       1107    ER motor_STATUS(UB pm, ST_MOTOR_STATUS *status)
    00000AF0              _motor_STATUS:                   ; function: motor_STATUS
                                                           ; frame size=40
    00000AF0 4CF0                   MOVMU.L     R12,@-R15
    00000AF2 7FE8                   ADD         #-24,R15
               mnet.c       1108    {
               mnet.c       1109      INT pos  = 0;
               mnet.c       1110      INT enc  = 0;
               mnet.c       1111      INT dev  = 0;
               mnet.c       1112      INT rsts = 0;
               mnet.c       1113      INT rest = 0;
               mnet.c       1114      INT rcnt1= 0;
               mnet.c       1115      UB mnet_drv_typ;
               mnet.c       1116      MNETSubStatus substs;
               mnet.c       1117      
               mnet.c       1118      // モータ番号範囲外
               mnet.c       1119      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000AF4 6D4C                   EXTU.B      R4,R13
    00000AF6 E601                   MOV         #1,R6      ; H'00000001
    00000AF8 E200                   MOV         #0,R2      ; H'00000000
    00000AFA 3D63                   CMP/GE      R6,R13
    00000AFC 6C53                   MOV         R5,R12
    00000AFE 1F22                   MOV.L       R2,@(8,R15); pos
    00000B00 6E43                   MOV         R4,R14
    00000B02 1F23                   MOV.L       R2,@(12,R15); enc
    00000B04 1F24                   MOV.L       R2,@(16,R15); dev
    00000B06 1F21                   MOV.L       R2,@(4,R15); rsts
    00000B08 8D02                   BT/S        L637
    00000B0A 2F22                   MOV.L       R2,@R15    ; rest
    00000B0C A0B6                   BRA         L261
    00000B0E 0009                   NOP
    00000B10              L637:
    00000B10 E207                   MOV         #7,R2      ; H'00000007
    00000B12 3D27                   CMP/GT      R2,R13
    00000B14 8B01                   BF          L638
    00000B16 A0B1                   BRA         L261
    00000B18 0009                   NOP
    00000B1A              L638:
               mnet.c       1120    
               mnet.c       1121    // シュミレーションモード
               mnet.c       1122    #if DEBUG_SIM_MODE != 0
               mnet.c       1123      // ステータスセット
               mnet.c       1124      status->busy      = 0;
               mnet.c       1125      status->cw_limit  = 0;
               mnet.c       1126      status->ccw_limit = 0;
               mnet.c       1127      status->enc       = 0;
               mnet.c       1128      status->dev       = 0;
               mnet.c       1129      status->pos       = _pmInfo[pm].pos = (INT)pos;
               mnet.c       1130      return (E_SUCCESS );
               mnet.c       1131    #endif
               mnet.c       1132    
               mnet.c       1133      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));             // デバイス接続異常
    00000B1A B341                   BSR         _IsExist
    00000B1C 64D3                   MOV         R13,R4
    00000B1E 2008                   TST         R0,R0
    00000B20 8B10                   BF          L264
    00000B22 E604                   MOV         #4,R6      ; H'00000004
    00000B24 60EC                   EXTU.B      R14,R0
    00000B26 4618                   SHLL8       R6
    00000B28 A0AA                   BRA         L265
    00000B2A 306C                   ADD         R6,R0
    00000B2C              L623:
    00000B2C <00000000>             .DATA.L     _MNET_DRV_TYPE
    00000B30 <00000000>             .DATA.L     __$_pmInfo
    00000B34 <00000000>             .DATA.L     __$SetRenv1Fu
    00000B38 <00000000>             .DATA.L     __$LMMOD_TBL
    00000B3C <00000000>             .DATA.L     __$SetRmdFu
    00000B40 <00000054>             .DATA.L     H'00000054+__$_pmInfo
    00000B44              L264:
               mnet.c       1134    
               mnet.c       1135      mnet_drv_typ = MNET_DRV_TYPE[pm];                       // デバイス情報取得
    00000B44 D697                   MOV.L       L624+2,R6  ; _MNET_DRV_TYPE
    00000B46 6EEC                   EXTU.B      R14,R14
    00000B48 60E3                   MOV         R14,R0
    00000B4A 026C                   MOV.B       @(R0,R6),R2; MNET_DRV_TYPE[]
    00000B4C 602C                   EXTU.B      R2,R0
               mnet.c       1136    
               mnet.c       1137      if( mnet_drv_typ == PCD4611 )                           // PCD4611通信接続時
    00000B4E 8809                   CMP/EQ      #9,R0
    00000B50 8B28                   BF          L267
               mnet.c       1138      {
               mnet.c       1139          WriteMemoryPCD4611(RRG_REST);
    00000B52 B1DE                   BSR         __$WriteMemoryPCD4611
    00000B54 E4F2                   MOV         #-14,R4    ; H'FFFFFFF2
               mnet.c       1140          rest = ReadMemoryPCD4611();
    00000B56 B1F4                   BSR         __$ReadMemoryPCD4611
    00000B58 0009                   NOP
               mnet.c       1141    
               mnet.c       1142          status->cw_limit  = (rest & 0x00000001) ? 1 : 0;
    00000B5A 8708                   BLD         #0,R0
    00000B5C 2F02                   MOV.L       R0,@R15    ; rest
    00000B5E 0129                   MOVT        R1
               mnet.c       1143          status->ccw_limit = (rest & 0x00000002) ? 1 : 0;
    00000B60 84F3                   MOV.B       @(3,R15),R0; (part of)rest
    00000B62 1C14                   MOV.L       R1,@(16,R12); (status)->cw_limit
    00000B64 C802                   TST         #2,R0
    00000B66 0539                   MOVRT       R5
               mnet.c       1144          if((rest & 0x00000004))     return( E_CON_HEAD_Y0 );
    00000B68 3F293003               BLD.B       #2,@(3,R15); (part of)rest
    00000B6C 8F04                   BF/S        L269
    00000B6E 1C55                   MOV.L       R5,@(20,R12); (status)->ccw_limit
    00000B70 00000401               MOVI20      #1025,R0   ; H'00000401
    00000B74 A084                   BRA         L265
    00000B76 0009                   NOP
    00000B78              L269:
               mnet.c       1145          
               mnet.c       1146    //        WriteMemoryPCD4611(RRG_RSTS);
               mnet.c       1147    //        pcd_rsts = ReadMemoryPCD4611();
               mnet.c       1148          
               mnet.c       1149          WriteMemoryPCD4611(RRG_RCUN1);
    00000B78 B1CB                   BSR         __$WriteMemoryPCD4611
    00000B7A E4E3                   MOV         #-29,R4    ; H'FFFFFFE3
               mnet.c       1150          rcnt1 = ReadMemoryPCD4611();
    00000B7C B1E1                   BSR         __$ReadMemoryPCD4611
    00000B7E 0009                   NOP
    00000B80 1F05                   MOV.L       R0,@(20,R15)
               mnet.c       1151          
               mnet.c       1152          // ステータスセット
               mnet.c       1153          status->busy      = motor_IsBusy(pm);
    00000B82 B351                   BSR         _motor_IsBusy
    00000B84 64D3                   MOV         R13,R4
    00000B86 1C03                   MOV.L       R0,@(12,R12); (status)->busy
               mnet.c       1154          status->cw_limit  = motor_IsLimit(pm , CW );
    00000B88 E501                   MOV         #1,R5      ; H'00000001
    00000B8A B38F                   BSR         _motor_IsLimit
    00000B8C 64D3                   MOV         R13,R4
    00000B8E 1C04                   MOV.L       R0,@(16,R12); (status)->cw_limit
               mnet.c       1155          status->ccw_limit = motor_IsLimit(pm , CCW);
    00000B90 E502                   MOV         #2,R5      ; H'00000002
    00000B92 B38B                   BSR         _motor_IsLimit
    00000B94 64D3                   MOV         R13,R4
               mnet.c       1156          status->enc       = 0;
               mnet.c       1157          status->dev       = 0;
               mnet.c       1158          status->pos       = rcnt1;
    00000B96 56F5                   MOV.L       @(20,R15),R6
    00000B98 E200                   MOV         #0,R2      ; H'00000000
    00000B9A 1C05                   MOV.L       R0,@(20,R12); (status)->ccw_limit
    00000B9C 1C21                   MOV.L       R2,@(4,R12); (status)->enc
    00000B9E 1C22                   MOV.L       R2,@(8,R12); (status)->dev
    00000BA0 A05E                   BRA         L270
    00000BA2 2C62                   MOV.L       R6,@R12    ; (status)->pos
    00000BA4              L267:
               mnet.c       1159      }
               mnet.c       1160      else
               mnet.c       1161      {
               mnet.c       1162    #ifdef DEBUG_INFO
               mnet.c       1163          DebugMnetInfo( pm );
    00000BA4 B7E8                   BSR         __$DebugMnetInfo
    00000BA6 64D3                   MOV         R13,R4
    00000BA8 E5F2                   MOV         #-14,R5    ; H'FFFFFFF2
               mnet.c       1164    #endif
               mnet.c       1165    
               mnet.c       1166          // エラー割込要因取得
               mnet.c       1167          if (!GetMotorRegister(pm, RRG_REST, &rest))             return(( E_MNT_ACCESS + RRG_REST ));    // レジスタアクセス異常
    00000BAA 66F3                   MOV         R15,R6
    00000BAC 655C                   EXTU.B      R5,R5
    00000BAE B25B                   BSR         _GetMotorRegister
    00000BB0 64D3                   MOV         R13,R4
    00000BB2 2008                   TST         R0,R0
    00000BB4 000005F2               MOVI20      #1522,R0   ; H'000005F2
    00000BB8 8962                   BT          L265
    00000BBA E5F1                   MOV         #-15,R5    ; H'FFFFFFF1
               mnet.c       1168    
               mnet.c       1169          if (!GetMotorRegister(pm, RRG_RSTS, &rsts)) // 状態取得
    00000BBC 66F3                   MOV         R15,R6
    00000BBE 7604                   ADD         #4,R6
    00000BC0 655C                   EXTU.B      R5,R5
    00000BC2 B251                   BSR         _GetMotorRegister
    00000BC4 64D3                   MOV         R13,R4
    00000BC6 2008                   TST         R0,R0
    00000BC8 000005F1               MOVI20      #1521,R0   ; H'000005F1
    00000BCC 8958                   BT          L265
    00000BCE E5E3                   MOV         #-29,R5    ; H'FFFFFFE3
               mnet.c       1170          {
               mnet.c       1171              return(( E_MNT_ACCESS + RRG_RSTS ));    // レジスタアクセス異常
               mnet.c       1172          }
               mnet.c       1173          
               mnet.c       1174          if (!GetMotorRegister(pm, RRG_RCUN1, &pos)) // 移動量取得
    00000BD0 66F3                   MOV         R15,R6
    00000BD2 7608                   ADD         #8,R6
    00000BD4 655C                   EXTU.B      R5,R5
    00000BD6 B247                   BSR         _GetMotorRegister
    00000BD8 64D3                   MOV         R13,R4
    00000BDA 2008                   TST         R0,R0
    00000BDC 000005E3               MOVI20      #1507,R0   ; H'000005E3
    00000BE0 894E                   BT          L265
               mnet.c       1175          {
               mnet.c       1176              return(( E_MNT_ACCESS + RRG_RCUN1 ));   // レジスタアクセス異常
               mnet.c       1177          }
               mnet.c       1178          
               mnet.c       1179          if( IsEncoderExist(pm) == TRUE )            // エンンコーダ付き
    00000BE2 B3A8                   BSR         _IsEncoderExist
    00000BE4 64D3                   MOV         R13,R4
    00000BE6 8801                   CMP/EQ      #1,R0
    00000BE8 8B18                   BF          L275
    00000BEA E5E4                   MOV         #-28,R5    ; H'FFFFFFE4
               mnet.c       1180          {
               mnet.c       1181              // エンコーダ値取得
               mnet.c       1182              if (!GetMotorRegister(pm, RRG_RCUN2, &enc))         return(( E_MNT_ACCESS + RRG_RCUN2 ));   // レジスタアクセス異常
    00000BEC 66F3                   MOV         R15,R6
    00000BEE 760C                   ADD         #12,R6
    00000BF0 655C                   EXTU.B      R5,R5
    00000BF2 B239                   BSR         _GetMotorRegister
    00000BF4 64D3                   MOV         R13,R4
    00000BF6 2008                   TST         R0,R0
    00000BF8 000005E4               MOVI20      #1508,R0   ; H'000005E4
    00000BFC 8940                   BT          L265
    00000BFE E5E5                   MOV         #-27,R5    ; H'FFFFFFE5
               mnet.c       1183    
               mnet.c       1184              // 偏差値取得
               mnet.c       1185              if (!GetMotorRegister(pm, RRG_RCUN3, &dev))         return(( E_MNT_ACCESS + RRG_RCUN3 ));   // レジスタアクセス異常
    00000C00 66F3                   MOV         R15,R6
    00000C02 7610                   ADD         #16,R6
    00000C04 655C                   EXTU.B      R5,R5
    00000C06 B22F                   BSR         _GetMotorRegister
    00000C08 64D3                   MOV         R13,R4
    00000C0A 2008                   TST         R0,R0
    00000C0C 8B03                   BF          L278
    00000C0E 000005E5               MOVI20      #1509,R0   ; H'000005E5
    00000C12 A035                   BRA         L265
    00000C14 0009                   NOP
    00000C16              L278:
               mnet.c       1186    
               mnet.c       1187              // 脱調検知
               mnet.c       1188              if(( rest & 0x00000004))                            return(( E_DTY_ERR | pm ));             // REST bit2(ESC3)
    00000C16 3F293003               BLD.B       #2,@(3,R15); (part of)rest
    00000C1A 892A                   BT          L279
    00000C1C              L275:
               mnet.c       1189    
               mnet.c       1190              // 脱調検知
               mnet.c       1191              if(( rsts & 0xf0000000) == 0)       // 固定値０エリアに書き込まれている場合は、FIFOの読込が出来なかったと判断し監視しない
               mnet.c       1192              {
               mnet.c       1193                  if( (rsts & 0x00400000) )                           
               mnet.c       1194                  {
               mnet.c       1195    //                return(( E_DTY_ERR | pm ));             // RSTS bit22(SCP3)
               mnet.c       1196                  }
               mnet.c       1197              }
               mnet.c       1198          }
               mnet.c       1199    
               mnet.c       1200          // 通信エラー
               mnet.c       1201          if( (rest & 0x00000400) )                               return(( E_CON_ERR | pm ));             // REST bit10(ESNT)
    00000C1C E604                   MOV         #4,R6      ; H'00000004
    00000C1E 62F2                   MOV.L       @R15,R2    ; rest
    00000C20 4618                   SHLL8       R6
    00000C22 2268                   TST         R6,R2
    00000C24 8902                   BT          L281
    00000C26 2D6B                   OR          R6,R13
    00000C28 A02A                   BRA         L265
    00000C2A 60D3                   MOV         R13,R0
    00000C2C              L281:
               mnet.c       1202    
               mnet.c       1203          // 脱調検知(オーバーライド失敗のため脱調と判断)
               mnet.c       1204          if( (rest & 0x00001000) )                               return(( E_DTY_ERR | pm ));             // REST bit12(ESOR)
    00000C2C E610                   MOV         #16,R6     ; H'00000010
    00000C2E 4618                   SHLL8       R6
    00000C30 2268                   TST         R6,R2
    00000C32 8B1E                   BF          L279
               mnet.c       1205    
               mnet.c       1206          // ステータスセット
               mnet.c       1207          status->busy      = motor_IsBusy(pm);
    00000C34 B2F8                   BSR         _motor_IsBusy
    00000C36 64D3                   MOV         R13,R4
    00000C38 1C03                   MOV.L       R0,@(12,R12); (status)->busy
               mnet.c       1208          status->cw_limit  = (rsts & 0x00000040) ? 1 : 0;
    00000C3A 84F7                   MOV.B       @(7,R15),R0; (part of)rsts
    00000C3C C840                   TST         #64,R0
    00000C3E 0639                   MOVRT       R6
               mnet.c       1209          status->ccw_limit = (rsts & 0x00000080) ? 1 : 0;
    00000C40 C880                   TST         #128,R0
    00000C42 1C64                   MOV.L       R6,@(16,R12); (status)->cw_limit
    00000C44 0739                   MOVRT       R7
    00000C46 1C75                   MOV.L       R7,@(20,R12); (status)->ccw_limit
    00000C48 E064                   MOV         #100,R0    ; H'00000064
    00000C4A 64E3                   MOV         R14,R4
               mnet.c       1210          status->enc       = enc;
    00000C4C 5DF3                   MOV.L       @(12,R15),R13; enc
    00000C4E 4480                   MULR        R0,R4
    00000C50 1CD1                   MOV.L       R13,@(4,R12); (status)->enc
               mnet.c       1211          status->dev       = dev;
               mnet.c       1212          status->pos       = _pmInfo[pm].pos = (INT)pos;
    00000C52 D255                   MOV.L       L624+6,R2  ; H'00000050+__$_pmInfo
    00000C54 51F4                   MOV.L       @(16,R15),R1; dev
    00000C56 6043                   MOV         R4,R0
    00000C58 1C12                   MOV.L       R1,@(8,R12); (status)->dev
    00000C5A 55F2                   MOV.L       @(8,R15),R5; pos
    00000C5C 0256                   MOV.L       R5,@(R0,R2); _pmInfo[].pos
    00000C5E 2C52                   MOV.L       R5,@R12    ; (status)->pos
    00000C60              L270:
               mnet.c       1213          
               mnet.c       1214      }
               mnet.c       1215    
               mnet.c       1216      if( status->busy == TRUE )                                  return(( E_BUSY + pm ));                // デバイスビジー
    00000C60 50C3                   MOV.L       @(12,R12),R0; (status)->busy
    00000C62 8801                   CMP/EQ      #1,R0
    00000C64 8F0C                   BF/S        L265
    00000C66 E000                   MOV         #0,R0      ; H'00000000
    00000C68 E601                   MOV         #1,R6      ; H'00000001
    00000C6A 4618                   SHLL8       R6
    00000C6C 3E6C                   ADD         R6,R14
    00000C6E A007                   BRA         L265
    00000C70 60E3                   MOV         R14,R0
    00000C72              L279:
    00000C72 E203                   MOV         #3,R2      ; H'00000003
    00000C74 4218                   SHLL8       R2
    00000C76 2D2B                   OR          R2,R13
    00000C78 A002                   BRA         L265
    00000C7A 60D3                   MOV         R13,R0
    00000C7C              L261:
    00000C7C 00000801               MOVI20      #2049,R0   ; H'00000801
    00000C80              L265:
    00000C80 7F18                   ADD         #24,R15
    00000C82 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1217    
               mnet.c       1218      return ( E_SUCCESS );
               mnet.c       1219    }
    00000C84 006B                   RTS/N
               mnet.c       1220    /******************************************************************************
               mnet.c       1221    * 
               mnet.c       1222    * [概要]  エンコーダ設定
               mnet.c       1223    * [引数]  mm:モータ番号、ec:逓倍設定値、dtyp:未使用、dv:未使用、so:脱腸検出ﾊﾟﾙｽ
               mnet.c       1224    * [戻値]  エラーコード
               mnet.c       1225    * 
               mnet.c       1226    ******************************************************************************/
               mnet.c       1227    ER motor_ENCODER(UB mm, UB ec, UB dtyp, UB dv, INT so)
    00000C86              _motor_ENCODER:                  ; function: motor_ENCODER
                                                           ; frame size=32
    00000C86 4CF0                   MOVMU.L     R12,@-R15
    00000C88 7FF0                   ADD         #-16,R15
               mnet.c       1228    {
               mnet.c       1229      RENV2       renv2;
               mnet.c       1230      RENV4       renv4;
               mnet.c       1231      RENV2PCD    renv2pcd;
               mnet.c       1232      INT         pos = 0;
               mnet.c       1233      UB          mnet_drv_typ;
               mnet.c       1234    
               mnet.c       1235      // モータ番号範囲外
               mnet.c       1236      if (mm < DVMIN || DVMAX < mm)                                   return(( E_PAR_OUTRNG + PARAM1 ));
    00000C8A 6C4C                   EXTU.B      R4,R12
    00000C8C E601                   MOV         #1,R6      ; H'00000001
    00000C8E E200                   MOV         #0,R2      ; H'00000000
    00000C90 3C63                   CMP/GE      R6,R12
    00000C92 6E53                   MOV         R5,R14
    00000C94 8D02                   BT/S        L639
    00000C96 1F22                   MOV.L       R2,@(8,R15); pos
    00000C98 A09E                   BRA         L291
    00000C9A 0009                   NOP
    00000C9C              L639:
    00000C9C E207                   MOV         #7,R2      ; H'00000007
    00000C9E 3C27                   CMP/GT      R2,R12
    00000CA0 8B01                   BF          L640
    00000CA2 A099                   BRA         L291
    00000CA4 0009                   NOP
    00000CA6              L640:
               mnet.c       1237    
               mnet.c       1238    // シュミレーションモード
               mnet.c       1239    #if DEBUG_SIM_MODE != 0
               mnet.c       1240      return (E_SUCCESS );
               mnet.c       1241    #endif
               mnet.c       1242    
               mnet.c       1243      if( MNET_DRV_TYPE[mm] == NCPRSUNIT )// 圧力ユニット
    00000CA6 D63F                   MOV.L       L624+2,R6  ; _MNET_DRV_TYPE
    00000CA8 6D4C                   EXTU.B      R4,R13
    00000CAA 60D3                   MOV         R13,R0
    00000CAC 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00000CAE 880A                   CMP/EQ      #10,R0
    00000CB0 8B01                   BF          L641
    00000CB2 A08F                   BRA         L294
    00000CB4 0009                   NOP
    00000CB6              L641:
               mnet.c       1244      {
               mnet.c       1245          return( E_SUCCESS );
               mnet.c       1246      }
               mnet.c       1247      
               mnet.c       1248      if (!IsExist( mm ))                                             return(( E_CON_ERR + mm ));
    00000CB6 B273                   BSR         _IsExist
    00000CB8 64C3                   MOV         R12,R4
    00000CBA 2008                   TST         R0,R0
    00000CBC 8B04                   BF          L296
    00000CBE E604                   MOV         #4,R6      ; H'00000004
    00000CC0 4618                   SHLL8       R6
    00000CC2 3D6C                   ADD         R6,R13
    00000CC4 A08A                   BRA         L297
    00000CC6 60D3                   MOV         R13,R0
    00000CC8              L296:
               mnet.c       1249      if (motor_IsBusy(mm))                                           return(( E_BUSY + mm ));
    00000CC8 B2AE                   BSR         _motor_IsBusy
    00000CCA 64C3                   MOV         R12,R4
    00000CCC 2008                   TST         R0,R0
    00000CCE 8901                   BT          L642
    00000CD0 A07B                   BRA         L299
    00000CD2 0009                   NOP
    00000CD4              L642:
               mnet.c       1250    
               mnet.c       1251      mnet_drv_typ = MNET_DRV_TYPE[mm];   // デバイス情報取得
    00000CD4 D633                   MOV.L       L624+2,R6  ; _MNET_DRV_TYPE
    00000CD6 60D3                   MOV         R13,R0
    00000CD8 026C                   MOV.B       @(R0,R6),R2; MNET_DRV_TYPE[]
    00000CDA 602C                   EXTU.B      R2,R0
               mnet.c       1252    
               mnet.c       1253      if(
    00000CDC 8801                   CMP/EQ      #1,R0
    00000CDE 8901                   BT          L301
    00000CE0 2008                   TST         R0,R0
    00000CE2 8B77                   BF          L294
    00000CE4              L301:
    00000CE4 E5DD                   MOV         #-35,R5    ; H'FFFFFFDD
               mnet.c       1254          ( mnet_drv_typ == BCD4020FUA )||
               mnet.c       1255          ( mnet_drv_typ == BCD4020FU )
               mnet.c       1256      )
               mnet.c       1257      {
               mnet.c       1258          if (!GetMotorRegister(mm, RRG_RENV2, &renv2.UNID.data))     return(( E_MNT_ACCESS + RRG_RENV2 ));// RENV2読込
    00000CE6 66F3                   MOV         R15,R6
    00000CE8 655C                   EXTU.B      R5,R5
    00000CEA B1BD                   BSR         _GetMotorRegister
    00000CEC 64C3                   MOV         R12,R4
    00000CEE 2008                   TST         R0,R0
    00000CF0 000005DD               MOVI20      #1501,R0   ; H'000005DD
    00000CF4 8972                   BT          L297
    00000CF6 E5DF                   MOV         #-33,R5    ; H'FFFFFFDF
               mnet.c       1259          if (!GetMotorRegister(mm, RRG_RENV4, &renv4.UNID.data))     return(( E_MNT_ACCESS + RRG_RENV4 ));// RENV4読込
    00000CF8 66F3                   MOV         R15,R6
    00000CFA 7604                   ADD         #4,R6
    00000CFC 655C                   EXTU.B      R5,R5
    00000CFE B1B3                   BSR         _GetMotorRegister
    00000D00 64C3                   MOV         R12,R4
    00000D02 2008                   TST         R0,R0
    00000D04 000005DF               MOVI20      #1503,R0   ; H'000005DF
    00000D08 8968                   BT          L297
               mnet.c       1260          
               mnet.c       1261          // Encoder 逓倍設定
               mnet.c       1262          switch( ec )
    00000D0A 60EC                   EXTU.B      R14,R0
    00000D0C 8802                   CMP/EQ      #2,R0
    00000D0E 8F06                   BF/S        L304
    00000D10 1F03                   MOV.L       R0,@(12,R15)
               mnet.c       1263          {
               mnet.c       1264              case EC_1:// １逓倍
               mnet.c       1265              default:
               mnet.c       1266                  renv2.UNID.BIT.EIM1 = 0;
               mnet.c       1267                  renv2.UNID.BIT.EIM0 = 0;
               mnet.c       1268                  break;
               mnet.c       1269              case EC_2:// ２逓倍
               mnet.c       1270                  renv2.UNID.BIT.EIM1 = 0;
    00000D12 3F290002               BCLR.B      #2,@(2,R15); (part of)renv2
               mnet.c       1271                  renv2.UNID.BIT.EIM0 = 1;
    00000D16 3F191002               BSET.B      #1,@(2,R15); (part of)renv2
    00000D1A A005                   BRA         L306
    00000D1C 0009                   NOP
    00000D1E              L304:
    00000D1E 8803                   CMP/EQ      #3,R0
    00000D20 3F292002               BST.B       #2,@(2,R15); (part of)renv2
    00000D24 3F190002               BCLR.B      #1,@(2,R15); (part of)renv2
    00000D28              L306:
               mnet.c       1272                  break;
               mnet.c       1273              case EC_3:// ４逓倍
               mnet.c       1274                  renv2.UNID.BIT.EIM1 = 1;
               mnet.c       1275                  renv2.UNID.BIT.EIM0 = 0;
               mnet.c       1276                  break;
               mnet.c       1277          }
               mnet.c       1278          if (!SetMotorRegisterInt(mm, WRG_RENV2, renv2.UNID.data))   return(( E_MNT_ACCESS + WRG_RENV2 ));
    00000D28 66F2                   MOV.L       @R15,R6    ; renv2.UNID.data
    00000D2A E59D                   MOV         #-99,R5    ; H'FFFFFF9D
    00000D2C 655C                   EXTU.B      R5,R5
    00000D2E B146                   BSR         _SetMotorRegisterInt
    00000D30 64C3                   MOV         R12,R4
    00000D32 2008                   TST         R0,R0
    00000D34 0000059D               MOVI20      #1437,R0   ; H'0000059D
    00000D38 8950                   BT          L297
    00000D3A E5E3                   MOV         #-29,R5    ; H'FFFFFFE3
               mnet.c       1279    
               mnet.c       1280          // 脱腸検出設定
               mnet.c       1281          if (!GetMotorRegister(mm, RRG_RCUN1, &pos))                 return(( E_MNT_ACCESS + RRG_RCUN1 ));       // カウンタ合わせ
    00000D3C 66F3                   MOV         R15,R6
    00000D3E 7608                   ADD         #8,R6
    00000D40 655C                   EXTU.B      R5,R5
    00000D42 B191                   BSR         _GetMotorRegister
    00000D44 64C3                   MOV         R12,R4
    00000D46 2008                   TST         R0,R0
    00000D48 000005E3               MOVI20      #1507,R0   ; H'000005E3
    00000D4C 8946                   BT          L297
               mnet.c       1282          if (!SetMotorRegisterInt(mm, WRG_RCUN2, pos))               return(( E_MNT_ACCESS + WRG_RCUN2 ));
    00000D4E E5A4                   MOV         #-92,R5    ; H'FFFFFFA4
    00000D50 56F2                   MOV.L       @(8,R15),R6; pos
    00000D52 655C                   EXTU.B      R5,R5
    00000D54 B133                   BSR         _SetMotorRegisterInt
    00000D56 64C3                   MOV         R12,R4
    00000D58 2008                   TST         R0,R0
    00000D5A 000005A4               MOVI20      #1444,R0   ; H'000005A4
    00000D5E 893D                   BT          L297
               mnet.c       1283          if( !SetMotorCommand(mm, CMD_CUN3R) )                       return(( E_BUSY + mm ));                    // COUNTER3リセット
    00000D60 E522                   MOV         #34,R5     ; H'00000022
    00000D62 B10E                   BSR         __$SetMotorCommand
    00000D64 64C3                   MOV         R12,R4
    00000D66 2008                   TST         R0,R0
    00000D68 892F                   BT          L299
               mnet.c       1284          if (!SetMotorRegisterInt(mm, WRG_RCMP3, so))                return(( E_MNT_ACCESS + WRG_RCMP3 ));       // RCMP3データ
    00000D6A 56F8                   MOV.L       @(32,R15),R6
    00000D6C E5A9                   MOV         #-87,R5    ; H'FFFFFFA9
    00000D6E 655C                   EXTU.B      R5,R5
    00000D70 B125                   BSR         _SetMotorRegisterInt
    00000D72 64C3                   MOV         R12,R4
    00000D74 6203                   MOV         R0,R2
    00000D76 2228                   TST         R2,R2
    00000D78 8B03                   BF          L312
    00000D7A 000005A9               MOVI20      #1449,R0   ; H'000005A9
    00000D7E A02D                   BRA         L297
    00000D80 0009                   NOP
    00000D82              L312:
               mnet.c       1285          if(( so )&&(ec != EC_N))    // 脱調パルス有かつエンコーダ無効以外
    00000D82 56F8                   MOV.L       @(32,R15),R6
    00000D84 2668                   TST         R6,R6
    00000D86 8911                   BT          L314
    00000D88 51F3                   MOV.L       @(12,R15),R1
    00000D8A 2118                   TST         R1,R1
    00000D8C 890E                   BT          L314
               mnet.c       1286          {
               mnet.c       1287              // 脱腸検出ﾊﾟﾙｽ≠0の場合、RCMP3 ＜ 比較カウンタで条件成立
               mnet.c       1288              renv4.UNID.BIT.C3S0 = 1;
    00000D8E 3F291005               BSET.B      #2,@(5,R15); (part of)renv4
               mnet.c       1289              renv4.UNID.BIT.C3S1 = 0;
    00000D92 3F390005               BCLR.B      #3,@(5,R15); (part of)renv4
               mnet.c       1290              renv4.UNID.BIT.C3S2 = 1;
    00000D96 3F491005               BSET.B      #4,@(5,R15); (part of)renv4
               mnet.c       1291              renv4.UNID.BIT.C3S3 = 0;
    00000D9A 3F590005               BCLR.B      #5,@(5,R15); (part of)renv4
    00000D9E A009                   BRA         L316
    00000DA0 0009                   NOP
    00000DA2              L624:
    00000DA2 00000002               .RES.W      1
    00000DA4 <00000000>             .DATA.L     _MNET_DRV_TYPE
    00000DA8 <00000050>             .DATA.L     H'00000050+__$_pmInfo
    00000DAC              L314:
               mnet.c       1292          }
               mnet.c       1293          else
               mnet.c       1294          {
               mnet.c       1295              // 脱腸検出ﾊﾟﾙｽ＝0の場合、常に比較条件不成立にしておく
               mnet.c       1296              renv4.UNID.BIT.C3S0 = 0;
    00000DAC 84F5                   MOV.B       @(5,R15),R0; (part of)renv4
    00000DAE E6C3                   MOV         #-61,R6    ; H'FFFFFFC3
    00000DB0 2069                   AND         R6,R0
    00000DB2 80F5                   MOV.B       R0,@(5,R15); (part of)renv4
    00000DB4              L316:
               mnet.c       1297              renv4.UNID.BIT.C3S1 = 0;
               mnet.c       1298              renv4.UNID.BIT.C3S2 = 0;
               mnet.c       1299              renv4.UNID.BIT.C3S3 = 0;
               mnet.c       1300          }
               mnet.c       1301          if (!SetMotorRegisterInt(mm,WRG_RENV4,renv4.UNID.data))     return(( E_MNT_ACCESS + WRG_RENV4 ));       // 設定
    00000DB4 56F1                   MOV.L       @(4,R15),R6; renv4.UNID.data
    00000DB6 E59F                   MOV         #-97,R5    ; H'FFFFFF9F
    00000DB8 655C                   EXTU.B      R5,R5
    00000DBA B100                   BSR         _SetMotorRegisterInt
    00000DBC 64C3                   MOV         R12,R4
    00000DBE 2008                   TST         R0,R0
    00000DC0 8B08                   BF          L294
    00000DC2 0000059F               MOVI20      #1439,R0   ; H'0000059F
    00000DC6 A009                   BRA         L297
    00000DC8 0009                   NOP
    00000DCA              L299:
    00000DCA E601                   MOV         #1,R6      ; H'00000001
    00000DCC 4618                   SHLL8       R6
    00000DCE 3D6C                   ADD         R6,R13
    00000DD0 A004                   BRA         L297
    00000DD2 60D3                   MOV         R13,R0
    00000DD4              L294:
    00000DD4 A002                   BRA         L297
    00000DD6 E000                   MOV         #0,R0      ; H'00000000
    00000DD8              L291:
    00000DD8 00000801               MOVI20      #2049,R0   ; H'00000801
    00000DDC              L297:
    00000DDC 7F10                   ADD         #16,R15
    00000DDE 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1302      }
               mnet.c       1303      // PCD4611通信接続時
               mnet.c       1304      else if( MNET_DRV_TYPE[mm] == PCD4611 )
               mnet.c       1305      {
               mnet.c       1306          // 本案件は、エンコードないため処理不要
               mnet.c       1307      }
               mnet.c       1308    
               mnet.c       1309      return( E_SUCCESS );
               mnet.c       1310    }
    00000DE0 006B                   RTS/N
               mnet.c       1311    
               mnet.c       1312    
               mnet.c       1313    
               mnet.c       1314    /******************************************************************************
               mnet.c       1315    * 
               mnet.c       1316    * [概要]  モータ速度倍率取得
               mnet.c       1317    * [引数]  速度番号
               mnet.c       1318    * [戻値]  倍率値
               mnet.c       1319    * 
               mnet.c       1320    ******************************************************************************/
               mnet.c       1321    INT GetFactor( UB factor )
    00000DE2              _GetFactor:                      ; function: GetFactor
                                                           ; frame size=0
               mnet.c       1322    {
               mnet.c       1323      INT Result = 0;
               mnet.c       1324    
               mnet.c       1325      if( ( factor >= 0)&&( factor <= 10 ))
    00000DE2 654C                   EXTU.B      R4,R5
    00000DE4 E600                   MOV         #0,R6      ; H'00000000
    00000DE6 4511                   CMP/PZ      R5
    00000DE8 8F07                   BF/S        L320
    00000DEA 6243                   MOV         R4,R2
    00000DEC E40A                   MOV         #10,R4     ; H'0000000A
    00000DEE 3547                   CMP/GT      R4,R5
    00000DF0 8903                   BT          L320
    00000DF2 602C                   EXTU.B      R2,R0
               mnet.c       1326      {
               mnet.c       1327          Result = MOTORSPD_TBL[factor];
    00000DF4 D580                   MOV.L       L625,R5    ; __$MOTORSPD_TBL
    00000DF6 4008                   SHLL2       R0
    00000DF8 065E                   MOV.L       @(R0,R5),R6; MOTORSPD_TBL[]
    00000DFA              L320:
               mnet.c       1328      }
               mnet.c       1329      return( Result );
               mnet.c       1330    }
    00000DFA 067B                   RTV/N       R6
               mnet.c       1331    /******************************************************************************
               mnet.c       1332    * 
               mnet.c       1333    * [概要]  モータ速度倍率取得
               mnet.c       1334    * [引数]  速度番号
               mnet.c       1335    * [戻値]  倍率値
               mnet.c       1336    * 
               mnet.c       1337    ******************************************************************************/
               mnet.c       1338    INT GetFactorPCD4611( UB factor )
    00000DFC              _GetFactorPCD4611:               ; function: GetFactorPCD4611
                                                           ; frame size=0
               mnet.c       1339    {
               mnet.c       1340      INT Result = 0;
               mnet.c       1341    
               mnet.c       1342      if( ( factor >= 0)&&( factor <= 10 ))
    00000DFC 654C                   EXTU.B      R4,R5
    00000DFE E600                   MOV         #0,R6      ; H'00000000
    00000E00 4511                   CMP/PZ      R5
    00000E02 8F07                   BF/S        L324
    00000E04 6243                   MOV         R4,R2
    00000E06 E40A                   MOV         #10,R4     ; H'0000000A
    00000E08 3547                   CMP/GT      R4,R5
    00000E0A 8903                   BT          L324
    00000E0C 602C                   EXTU.B      R2,R0
               mnet.c       1343      {
               mnet.c       1344          Result = MOTORSPD_TBL_PCD4611[factor];
    00000E0E D57B                   MOV.L       L625+4,R5  ; __$MOTORSPD_TBL_PCD4611
    00000E10 4008                   SHLL2       R0
    00000E12 065E                   MOV.L       @(R0,R5),R6; MOTORSPD_TBL_PCD4611[]
    00000E14              L324:
               mnet.c       1345      }
               mnet.c       1346      return( Result );
               mnet.c       1347    }
    00000E14 067B                   RTV/N       R6
               mnet.c       1348    
               mnet.c       1349    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c       1350    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c       1351    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c       1352    
               mnet.c       1353    
               mnet.c       1354    /***********************************************************************
               mnet.c       1355    *
               mnet.c       1356    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1357    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1358    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1359    * 
               mnet.c       1360    ***********************************************************************/
               mnet.c       1361    static BOOL WriteMemory(INT addr, UH data)
    00000E16              __$WriteMemory:                  ; function: __$WriteMemory
                                                           ; frame size=12
    00000E16 4DF0                   MOVMU.L     R13,@-R15
    00000E18 D179                   MOV.L       L625+8,R1  ; H'0C008000
               mnet.c       1362    {
               mnet.c       1363      volatile UB *p = (UB *)(MNET_BASE_ADDRESS + addr);
    00000E1A 6D53                   MOV         R5,R13
    00000E1C E5FF                   MOV         #-1,R5     ; H'FFFFFFFF
    00000E1E 341C                   ADD         R1,R4
    00000E20 6E43                   MOV         R4,R14
               mnet.c       1364      ER  result = E_SUCCESS;
               mnet.c       1365    
               mnet.c       1366      // バス経由によるデータ通知のためアクセス頻度がある
               mnet.c       1367      // 場合、データ競合の可能性もでてくるため排他制御追加
               mnet.c       1368      MAC_WAI_SEM( ID_SEM_MEMRW );
    00000E22 D778                   MOV.L       L625+12,R7 ; _v4_twai_sem
    00000E24 470B                   JSR         @R7
    00000E26 E414                   MOV         #20,R4     ; H'00000014
    00000E28 2008                   TST         R0,R0
    00000E2A 8F14                   BF/S        L328
    00000E2C 6603                   MOV         R0,R6
               mnet.c       1369    
               mnet.c       1370      *p++ = (UB)(data >> 0);
    00000E2E 60DD                   EXTU.W      R13,R0
               mnet.c       1371      *p   = (UB)(data >> 8);
    00000E30 E6F8                   MOV         #-8,R6     ; H'FFFFFFF8
    00000E32 2E00                   MOV.B       R0,@R14
    00000E34 406C                   SHAD        R6,R0
               mnet.c       1372    
               mnet.c       1373    #ifdef WAIT_TYPE_IFB
               mnet.c       1374      // TRUE:ビジー  
               mnet.c       1375      if( IfbIdleWait() == TRUE )
    00000E36 B54B                   BSR         __$IfbIdleWait
    00000E38 80E1                   MOV.B       R0,@(1,R14); *(p)
    00000E3A 8801                   CMP/EQ      #1,R0
    00000E3C 8B01                   BF          L330
               mnet.c       1376      {
               mnet.c       1377          return FALSE;
    00000E3E A00D                   BRA         L331
    00000E40 0039                   MOVRT       R0
    00000E42              L330:
               mnet.c       1378      }
               mnet.c       1379    #endif
               mnet.c       1380    
               mnet.c       1381    #ifdef WAIT_TYPE_RW
               mnet.c       1382      g_Sleep(50);
    00000E42 B53E                   BSR         _g_Sleep
    00000E44 E432                   MOV         #50,R4     ; H'00000032
               mnet.c       1383    #endif
               mnet.c       1384    
               mnet.c       1385      MAC_SIG_SEM( ID_SEM_MEMRW );
    00000E46 D270                   MOV.L       L625+16,R2 ; _v4_sig_sem
    00000E48 420B                   JSR         @R2
    00000E4A E414                   MOV         #20,R4     ; H'00000014
    00000E4C 2008                   TST         R0,R0
    00000E4E 8F02                   BF/S        L328
    00000E50 6603                   MOV         R0,R6
               mnet.c       1386    
               mnet.c       1387      return TRUE;
    00000E52 A003                   BRA         L331
    00000E54 0029                   MOVT        R0
    00000E56              L328:
    00000E56 E005                   MOV         #5,R0      ; H'00000005
    00000E58 4018                   SHLL8       R0
    00000E5A 3068                   SUB         R6,R0
    00000E5C              L331:
    00000E5C 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1388    }
    00000E5E 006B                   RTS/N
               mnet.c       1389    /***********************************************************************
               mnet.c       1390    *
               mnet.c       1391    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1392    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1393    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1394    * 
               mnet.c       1395    ***********************************************************************/
               mnet.c       1396    static BOOL WriteMemoryInt(INT addr, INT data)
    00000E60              __$WriteMemoryInt:               ; function: __$WriteMemoryInt
                                                           ; frame size=12
    00000E60 4DF0                   MOVMU.L     R13,@-R15
    00000E62 D167                   MOV.L       L625+8,R1  ; H'0C008000
               mnet.c       1397    { 
               mnet.c       1398      volatile UB *p = (UB *)(MNET_BASE_ADDRESS + addr);
    00000E64 6D53                   MOV         R5,R13
    00000E66 E5FF                   MOV         #-1,R5     ; H'FFFFFFFF
    00000E68 341C                   ADD         R1,R4
    00000E6A 6E43                   MOV         R4,R14
               mnet.c       1399      ER  result = E_SUCCESS;
               mnet.c       1400    
               mnet.c       1401      // バス経由によるデータ通知のためアクセス頻度がある
               mnet.c       1402      // 場合、データ競合の可能性もでてくるため排他制御追加
               mnet.c       1403      MAC_WAI_SEM( ID_SEM_MEMRW );
    00000E6C D765                   MOV.L       L625+12,R7 ; _v4_twai_sem
    00000E6E 470B                   JSR         @R7
    00000E70 E414                   MOV         #20,R4     ; H'00000014
    00000E72 2008                   TST         R0,R0
    00000E74 8F1B                   BF/S        L335
    00000E76 6603                   MOV         R0,R6
    00000E78 E1F8                   MOV         #-8,R1     ; H'FFFFFFF8
               mnet.c       1404    
               mnet.c       1405      *(p+0) = (UB)(data >> 0);
               mnet.c       1406      *(p+1) = (UB)(data >> 8);
               mnet.c       1407      *(p+0) = (UB)(data >> 16);
               mnet.c       1408      *(p+1) = (UB)(data >> 24);
    00000E7A E4E8                   MOV         #-24,R4    ; H'FFFFFFE8
    00000E7C 2ED0                   MOV.B       R13,@R14   ; p[]
    00000E7E 60D3                   MOV         R13,R0
    00000E80 401C                   SHAD        R1,R0
    00000E82 62D3                   MOV         R13,R2
    00000E84 80E1                   MOV.B       R0,@(1,R14); p[]
    00000E86 4229                   SHLR16      R2
    00000E88 4D4C                   SHAD        R4,R13
    00000E8A 2E20                   MOV.B       R2,@R14    ; p[]
    00000E8C 60D3                   MOV         R13,R0
               mnet.c       1409    
               mnet.c       1410      // TRUE:ビジー  
               mnet.c       1411      if( IfbIdleWait() == TRUE )
    00000E8E B51F                   BSR         __$IfbIdleWait
    00000E90 80E1                   MOV.B       R0,@(1,R14); p[]
    00000E92 8801                   CMP/EQ      #1,R0
    00000E94 8B01                   BF          L337
               mnet.c       1412      {
               mnet.c       1413          return FALSE;
    00000E96 A00D                   BRA         L338
    00000E98 0039                   MOVRT       R0
    00000E9A              L337:
               mnet.c       1414      }
               mnet.c       1415    
               mnet.c       1416    #ifdef WAIT_TYPE_RW
               mnet.c       1417      g_Sleep(50);
    00000E9A B512                   BSR         _g_Sleep
    00000E9C E432                   MOV         #50,R4     ; H'00000032
               mnet.c       1418    #endif
               mnet.c       1419      MAC_SIG_SEM( ID_SEM_MEMRW );
    00000E9E D25A                   MOV.L       L625+16,R2 ; _v4_sig_sem
    00000EA0 420B                   JSR         @R2
    00000EA2 E414                   MOV         #20,R4     ; H'00000014
    00000EA4 2008                   TST         R0,R0
    00000EA6 8F02                   BF/S        L335
    00000EA8 6603                   MOV         R0,R6
               mnet.c       1420    
               mnet.c       1421      return TRUE;
    00000EAA A003                   BRA         L338
    00000EAC 0029                   MOVT        R0
    00000EAE              L335:
    00000EAE E005                   MOV         #5,R0      ; H'00000005
    00000EB0 4018                   SHLL8       R0
    00000EB2 3068                   SUB         R6,R0
    00000EB4              L338:
    00000EB4 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1422    }
    00000EB6 006B                   RTS/N
               mnet.c       1423    /***********************************************************************
               mnet.c       1424    *
               mnet.c       1425    * [概要]  センターデバイスのメモリーからデータを読み出します
               mnet.c       1426    * [引数]  addr：読み出しアドレス、data：読み出しデータ
               mnet.c       1427    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1428    * 
               mnet.c       1429    ***********************************************************************/
               mnet.c       1430    static BOOL ReadMemory(INT addr,  UH *data)
    00000EB8              __$ReadMemory:                   ; function: __$ReadMemory
                                                           ; frame size=12
    00000EB8 4DF0                   MOVMU.L     R13,@-R15
    00000EBA D151                   MOV.L       L625+8,R1  ; H'0C008000
               mnet.c       1431    {
               mnet.c       1432      UB  b0;
               mnet.c       1433      UB  b1;
               mnet.c       1434      ER  result = E_SUCCESS;
               mnet.c       1435    
               mnet.c       1436      volatile UB *p = (UB *)(MNET_BASE_ADDRESS + addr);
    00000EBC 6D53                   MOV         R5,R13
    00000EBE E5FF                   MOV         #-1,R5     ; H'FFFFFFFF
    00000EC0 341C                   ADD         R1,R4
    00000EC2 6E43                   MOV         R4,R14
               mnet.c       1437    
               mnet.c       1438      // バス経由によるデータ通知のためアクセス頻度がある
               mnet.c       1439      // 場合、データ競合の可能性もでてくるため排他制御追加
               mnet.c       1440      MAC_WAI_SEM( ID_SEM_MEMRW );
    00000EC4 D74F                   MOV.L       L625+12,R7 ; _v4_twai_sem
    00000EC6 470B                   JSR         @R7
    00000EC8 E414                   MOV         #20,R4     ; H'00000014
    00000ECA 2008                   TST         R0,R0
    00000ECC 8F16                   BF/S        L342
    00000ECE 6603                   MOV         R0,R6
               mnet.c       1441    
               mnet.c       1442      b0 = (UB)*p++;
    00000ED0 35E18000               MOVU.B      @(0,R14),R5
               mnet.c       1443      b1 = (UB)*p;
    00000ED4 30E18001               MOVU.B      @(1,R14),R0; *(p)
               mnet.c       1444      *data      = (b1 << 8) | b0;
    00000ED8 4018                   SHLL8       R0
    00000EDA 205B                   OR          R5,R0
               mnet.c       1445    
               mnet.c       1446    #ifdef WAIT_TYPE_IFB
               mnet.c       1447      // TRUE:ビジー  
               mnet.c       1448      if( IfbIdleWait() == TRUE )
    00000EDC B4F8                   BSR         __$IfbIdleWait
    00000EDE 2D01                   MOV.W       R0,@R13    ; *(data)
    00000EE0 8801                   CMP/EQ      #1,R0
    00000EE2 8B01                   BF          L344
               mnet.c       1449      {
               mnet.c       1450          return FALSE;
    00000EE4 A00D                   BRA         L345
    00000EE6 0039                   MOVRT       R0
    00000EE8              L344:
               mnet.c       1451      }
               mnet.c       1452    #endif
               mnet.c       1453    #ifdef WAIT_TYPE_RW
               mnet.c       1454      g_Sleep(50);
    00000EE8 B4EB                   BSR         _g_Sleep
    00000EEA E432                   MOV         #50,R4     ; H'00000032
               mnet.c       1455    #endif
               mnet.c       1456      MAC_SIG_SEM( ID_SEM_MEMRW );
    00000EEC D246                   MOV.L       L625+16,R2 ; _v4_sig_sem
    00000EEE 420B                   JSR         @R2
    00000EF0 E414                   MOV         #20,R4     ; H'00000014
    00000EF2 2008                   TST         R0,R0
    00000EF4 8F02                   BF/S        L342
    00000EF6 6603                   MOV         R0,R6
               mnet.c       1457    
               mnet.c       1458      return TRUE;
    00000EF8 A003                   BRA         L345
    00000EFA 0029                   MOVT        R0
    00000EFC              L342:
    00000EFC E005                   MOV         #5,R0      ; H'00000005
    00000EFE 4018                   SHLL8       R0
    00000F00 3068                   SUB         R6,R0
    00000F02              L345:
    00000F02 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1459    }
    00000F04 006B                   RTS/N
               mnet.c       1460    /***********************************************************************
               mnet.c       1461    *
               mnet.c       1462    * [概要]  センターデバイスにコマンドを書き込みます
               mnet.c       1463    * [引数]  command：コマンド
               mnet.c       1464    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1465    * 
               mnet.c       1466    ***********************************************************************/
               mnet.c       1467    static BOOL  SetMainCommand(UH command)
    00000F06              __$SetMainCommand:               ; function: __$SetMainCommand
                                                           ; frame size=0
               mnet.c       1468    {
               mnet.c       1469      return WriteMemory(MNET_COMMAND, command);
    00000F06 654D                   EXTU.W      R4,R5
    00000F08 AF85                   BRA         __$WriteMemory
    00000F0A E400                   MOV         #0,R4      ; H'00000000
               mnet.c       1470    }
               mnet.c       1471    /***********************************************************************
               mnet.c       1472    *
               mnet.c       1473    * [概要]  センターデバイスのステータスを取得します
               mnet.c       1474    * [引数]  status：MNET状態格納先
               mnet.c       1475    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1476    * 
               mnet.c       1477    ***********************************************************************/
               mnet.c       1478    static BOOL GetMainStatus(MNETStatus* status)
    00000F0C              __$GetMainStatus:                ; function: __$GetMainStatus
                                                           ; frame size=0
               mnet.c       1479    {
               mnet.c       1480      return ReadMemory(MNET_STATUS, &status->UNID.data);
    00000F0C 6543                   MOV         R4,R5
    00000F0E AFD3                   BRA         __$ReadMemory
    00000F10 E400                   MOV         #0,R4      ; H'00000000
               mnet.c       1481    }
               mnet.c       1482    
               mnet.c       1483    
               mnet.c       1484    
               mnet.c       1485    // --- PCD4611 ---------------------------------------------------------------------------------------------
               mnet.c       1486    
               mnet.c       1487    /***********************************************************************
               mnet.c       1488    *
               mnet.c       1489    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1490    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1491    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1492    * 
               mnet.c       1493    ***********************************************************************/
               mnet.c       1494    static void WriteMemoryPCD4611(UB data)
    00000F12              __$WriteMemoryPCD4611:           ; function: __$WriteMemoryPCD4611
                                                           ; frame size=0
               mnet.c       1495    {
               mnet.c       1496      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000F12 D23E                   MOV.L       L625+20,R2 ; H'0C009000
    00000F14 D53E                   MOV.L       L625+24,R5 ; _pPulseMotor
    00000F16 2522                   MOV.L       R2,@R5     ; pPulseMotor
               mnet.c       1497    
               mnet.c       1498      pPulseMotor->unCmdSts.stWrite.COMB0 = (unsigned char)data;
               mnet.c       1499    }
    00000F18 000B                   RTS
    00000F1A 2240                   MOV.B       R4,@R2     ; (pPulseMotor)->COMB0
               mnet.c       1500    /***********************************************************************
               mnet.c       1501    *
               mnet.c       1502    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1503    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1504    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1505    * 
               mnet.c       1506    ***********************************************************************/
               mnet.c       1507    static void WriteMemoryIntPCD4611(INT data)
    00000F1C              __$WriteMemoryIntPCD4611:        ; function: __$WriteMemoryIntPCD4611
                                                           ; frame size=0
               mnet.c       1508    { 
               mnet.c       1509      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000F1C D13B                   MOV.L       L625+20,R1 ; H'0C009000
               mnet.c       1510    
               mnet.c       1511      pPulseMotor->BUFB0 = (unsigned char)( data >> 0 );
    00000F1E 6043                   MOV         R4,R0
    00000F20 D53B                   MOV.L       L625+24,R5 ; _pPulseMotor
    00000F22 2512                   MOV.L       R1,@R5     ; pPulseMotor
               mnet.c       1512      pPulseMotor->BUFB1 = (unsigned char)( data >> 8 );
               mnet.c       1513      pPulseMotor->BUFB2 = (unsigned char)( data >> 16 );
               mnet.c       1514      pPulseMotor->BUFB3 = (unsigned char)( data >> 24 );
    00000F24 E7E8                   MOV         #-24,R7    ; H'FFFFFFE8
    00000F26 8014                   MOV.B       R0,@(4,R1) ; (pPulseMotor)->BUFB0
    00000F28 E1F8                   MOV         #-8,R1     ; H'FFFFFFF8
    00000F2A 401C                   SHAD        R1,R0
    00000F2C 6252                   MOV.L       @R5,R2     ; pPulseMotor
    00000F2E 8025                   MOV.B       R0,@(5,R2) ; (pPulseMotor)->BUFB1
    00000F30 6043                   MOV         R4,R0
    00000F32 4029                   SHLR16      R0
    00000F34 6652                   MOV.L       @R5,R6     ; pPulseMotor
    00000F36 447C                   SHAD        R7,R4
    00000F38 8066                   MOV.B       R0,@(6,R6) ; (pPulseMotor)->BUFB2
    00000F3A 6043                   MOV         R4,R0
    00000F3C 6252                   MOV.L       @R5,R2     ; pPulseMotor
               mnet.c       1515    }
    00000F3E 000B                   RTS
    00000F40 8027                   MOV.B       R0,@(7,R2) ; (pPulseMotor)->BUFB3
               mnet.c       1516    
               mnet.c       1517    /***********************************************************************
               mnet.c       1518    *
               mnet.c       1519    * [概要]  センターデバイスのメモリーからデータを読み出します
               mnet.c       1520    * [引数]  addr：読み出しアドレス、data：読み出しデータ
               mnet.c       1521    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1522    * 
               mnet.c       1523    ***********************************************************************/
               mnet.c       1524    static INT ReadMemoryPCD4611()
    00000F42              __$ReadMemoryPCD4611:            ; function: __$ReadMemoryPCD4611
                                                           ; frame size=0
               mnet.c       1525    {
               mnet.c       1526      INT result = 0x00;
               mnet.c       1527      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000F42 D532                   MOV.L       L625+20,R5 ; H'0C009000
    00000F44 D132                   MOV.L       L625+24,R1 ; _pPulseMotor
    00000F46 2152                   MOV.L       R5,@R1     ; pPulseMotor
               mnet.c       1528    
               mnet.c       1529      result |=   ( (INT)( pPulseMotor->BUFB0 ) << 0 );
    00000F48 32518004               MOVU.B      @(4,R5),R2 ; (pPulseMotor)->BUFB0
               mnet.c       1530      result |=   ( (INT)( pPulseMotor->BUFB1 ) << 8 );
    00000F4C 30518005               MOVU.B      @(5,R5),R0 ; (pPulseMotor)->BUFB1
    00000F50 4018                   SHLL8       R0
    00000F52 220B                   OR          R0,R2
               mnet.c       1531      result |=   ( (INT)( pPulseMotor->BUFB2 ) << 16 );
    00000F54 30518006               MOVU.B      @(6,R5),R0 ; (pPulseMotor)->BUFB2
    00000F58 4028                   SHLL16      R0
    00000F5A 220B                   OR          R0,R2
               mnet.c       1532      result |=   ( (INT)( pPulseMotor->BUFB3 ) << 24 );
    00000F5C 8457                   MOV.B       @(7,R5),R0 ; (pPulseMotor)->BUFB3
               mnet.c       1533      
               mnet.c       1534      return result;
    00000F5E 4028                   SHLL16      R0
    00000F60 4018                   SHLL8       R0
               mnet.c       1535    }
    00000F62 000B                   RTS
    00000F64 202B                   OR          R2,R0
               mnet.c       1536    // --- PCD4611 ---------------------------------------------------------------------------------------------
               mnet.c       1537    
               mnet.c       1538    
               mnet.c       1539    
               mnet.c       1540    ///<summary>
               mnet.c       1541    /// メインデバイスのレジスターにデータを書き込みます
               mnet.c       1542    ///</summary>
               mnet.c       1543    static BOOL  SetMainRegister(UH reg, UH data)
    00000F66              __$SetMainRegister:              ; function: __$SetMainRegister
                                                           ; frame size=8
    00000F66 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       1544    {
               mnet.c       1545      // FALSE:書込み失敗?
               mnet.c       1546      if( WriteMemory(MNET_IO_BUFFER, data) == FALSE )
    00000F68 6E43                   MOV         R4,R14
    00000F6A E404                   MOV         #4,R4      ; H'00000004
    00000F6C BF53                   BSR         __$WriteMemory
    00000F6E 655D                   EXTU.W      R5,R5
    00000F70 2008                   TST         R0,R0
    00000F72 8D04                   BT/S        L354
    00000F74 E000                   MOV         #0,R0      ; H'00000000
               mnet.c       1547      {
               mnet.c       1548          return FALSE;
               mnet.c       1549      }
               mnet.c       1550      return SetMainCommand(reg);
    00000F76 64ED                   EXTU.W      R14,R4
    00000F78 4EF4                   MOVMU.L     @R15+,R14
    00000F7A AFC4                   BRA         __$SetMainCommand
    00000F7C 0009                   NOP
    00000F7E              L354:
    00000F7E 4EF4                   MOVMU.L     @R15+,R14
    00000F80 006B                   RTS/N
               mnet.c       1551    }
               mnet.c       1552    
               mnet.c       1553    
               mnet.c       1554    ///<summary>
               mnet.c       1555    /// 指定モーターデバイスにコマンドを書き込みます
               mnet.c       1556    ///</summary>
               mnet.c       1557    static BOOL   SetMotorCommand(UB dev_no, UH command)
    00000F82              __$SetMotorCommand:              ; function: __$SetMotorCommand
                                                           ; frame size=8
    00000F82 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       1558    {
               mnet.c       1559      if( MNET_DRV_TYPE[dev_no] == PCD4611 )
    00000F84 D623                   MOV.L       L625+28,R6 ; _MNET_DRV_TYPE
    00000F86 6E4C                   EXTU.B      R4,R14
    00000F88 60E3                   MOV         R14,R0
    00000F8A 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00000F8C 8809                   CMP/EQ      #9,R0
    00000F8E 8B03                   BF          L357
               mnet.c       1560      {
               mnet.c       1561          WriteMemoryPCD4611( (UB)command );
    00000F90 BFBF                   BSR         __$WriteMemoryPCD4611
    00000F92 6453                   MOV         R5,R4
    00000F94 A00E                   BRA         L358
    00000F96 0009                   NOP
    00000F98              L357:
               mnet.c       1562      }
               mnet.c       1563      else
               mnet.c       1564      {
               mnet.c       1565          WriteMemory(MNET_FIFO, command);                                // レジスタ書き込み
    00000F98 655D                   EXTU.W      R5,R5
    00000F9A BF3C                   BSR         __$WriteMemory
    00000F9C E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1566    
               mnet.c       1567          if( !SetMainCommand((MNET_DATA_COMMUNICATION_BASE + dev_no)) )  // FALSE:コマンドセット失敗?
    00000F9E E240                   MOV         #64,R2     ; H'00000040
    00000FA0 4218                   SHLL8       R2
    00000FA2 3E2C                   ADD         R2,R14
    00000FA4 BFAF                   BSR         __$SetMainCommand
    00000FA6 64E3                   MOV         R14,R4
    00000FA8 2008                   TST         R0,R0
    00000FAA 8905                   BT          L360
               mnet.c       1568          {
               mnet.c       1569              return FALSE;
               mnet.c       1570          }
               mnet.c       1571    
               mnet.c       1572    #ifdef WAIT_END_CHK
               mnet.c       1573          
               mnet.c       1574          if( EndIdleWait()  == TRUE )                                    // TRUE:ビジー  
    00000FAC B4A5                   BSR         __$EndIdleWait
    00000FAE 0009                   NOP
    00000FB0 8801                   CMP/EQ      #1,R0
    00000FB2 8901                   BT          L360
    00000FB4              L358:
               mnet.c       1575          {
               mnet.c       1576              return FALSE;
               mnet.c       1577          }
               mnet.c       1578    #endif
               mnet.c       1579      }
               mnet.c       1580      return TRUE;
    00000FB4 A001                   BRA         L361
    00000FB6 E001                   MOV         #1,R0      ; H'00000001
    00000FB8              L360:
    00000FB8 0039                   MOVRT       R0
    00000FBA              L361:
    00000FBA 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       1581    }
    00000FBC 006B                   RTS/N
               mnet.c       1582    
               mnet.c       1583    ///<summary>
               mnet.c       1584    /// 指定モーターデバイスのレジスターにデータを書き込みます
               mnet.c       1585    ///</summary>
               mnet.c       1586    static BOOL   SetMotorRegisterInt(UB dev_no, UH reg, INT value)
    00000FBE              _SetMotorRegisterInt:            ; function: SetMotorRegisterInt
                                                           ; frame size=12
    00000FBE 4DF0                   MOVMU.L     R13,@-R15
    00000FC0 D114                   MOV.L       L625+28,R1 ; _MNET_DRV_TYPE
    00000FC2 604C                   EXTU.B      R4,R0
    00000FC4 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
               mnet.c       1587    {
               mnet.c       1588      if( MNET_DRV_TYPE[dev_no] == PCD4611 )
    00000FC6 6D63                   MOV         R6,R13
    00000FC8 8809                   CMP/EQ      #9,R0
    00000FCA 8F06                   BF/S        L364
    00000FCC 6E53                   MOV         R5,R14
               mnet.c       1589      {
               mnet.c       1590          WriteMemoryIntPCD4611(value);
    00000FCE BFA5                   BSR         __$WriteMemoryIntPCD4611
    00000FD0 64D3                   MOV         R13,R4
               mnet.c       1591          WriteMemoryPCD4611((UB)reg);
    00000FD2 BF9E                   BSR         __$WriteMemoryPCD4611
    00000FD4 64E3                   MOV         R14,R4
    00000FD6 A00C                   BRA         L365
    00000FD8 0009                   NOP
    00000FDA              L364:
               mnet.c       1592      }
               mnet.c       1593      else
               mnet.c       1594      {
               mnet.c       1595          WriteMemory   (MNET_FIFO, reg);     // レジスタ書き込み
    00000FDA 65ED                   EXTU.W      R14,R5
    00000FDC BF1B                   BSR         __$WriteMemory
    00000FDE E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1596          WriteMemoryInt(MNET_FIFO, value);   // データ書き込み
    00000FE0 E406                   MOV         #6,R4      ; H'00000006
    00000FE2 BF3D                   BSR         __$WriteMemoryInt
    00000FE4 65D3                   MOV         R13,R5
               mnet.c       1597          
               mnet.c       1598          if( EndIdleWait()  == TRUE )        // TRUE:ビジーのまま
    00000FE6 B488                   BSR         __$EndIdleWait
    00000FE8 0009                   NOP
    00000FEA 8801                   CMP/EQ      #1,R0
    00000FEC 8B01                   BF          L365
               mnet.c       1599          {
               mnet.c       1600              return ( FALSE );
    00000FEE A001                   BRA         L367
    00000FF0 0039                   MOVRT       R0
    00000FF2              L365:
               mnet.c       1601          }
               mnet.c       1602      }
               mnet.c       1603      
               mnet.c       1604      return TRUE;
    00000FF2 E001                   MOV         #1,R0      ; H'00000001
    00000FF4              L367:
    00000FF4 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1605    }
    00000FF6 006B                   RTS/N
    00000FF8              L625:
    00000FF8 <00000000>             .DATA.L     __$MOTORSPD_TBL
    00000FFC <00000000>             .DATA.L     __$MOTORSPD_TBL_PCD4611
    00001000 0C008000               .DATA.L     H'0C008000
    00001004 <00000000>             .DATA.L     _v4_twai_sem
    00001008 <00000000>             .DATA.L     _v4_sig_sem
    0000100C 0C009000               .DATA.L     H'0C009000
    00001010 <00000000>             .DATA.L     _pPulseMotor
    00001014 <00000000>             .DATA.L     _MNET_DRV_TYPE
               mnet.c       1606    
               mnet.c       1607    ///<summary>
               mnet.c       1608    /// 指定モーターデバイスのレジスターにデータを書き込みます
               mnet.c       1609    ///</summary>
               mnet.c       1610    static BOOL   SetMotorRegister(UB dev_no, UH reg, UH value)
    00001018              __$SetMotorRegister:             ; function: __$SetMotorRegister
                                                           ; frame size=16
    00001018 4CF0                   MOVMU.L     R12,@-R15
    0000101A D180                   MOV.L       L626,R1    ; _MNET_NO
    0000101C 604C                   EXTU.B      R4,R0
    0000101E 021C                   MOV.B       @(R0,R1),R2; MNET_NO[]
               mnet.c       1611    {
               mnet.c       1612      UB mnetno;
               mnet.c       1613    
               mnet.c       1614      mnetno = MNET_NO[dev_no];
    00001020 6C53                   MOV         R5,R12
    00001022 6E2C                   EXTU.B      R2,R14
               mnet.c       1615    
               mnet.c       1616      if( MNET_DRV_TYPE[mnetno] == PCD4611 )
    00001024 D27E                   MOV.L       L626+4,R2  ; _MNET_DRV_TYPE
    00001026 60E3                   MOV         R14,R0
    00001028 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    0000102A 8809                   CMP/EQ      #9,R0
    0000102C 8F06                   BF/S        L370
    0000102E 6D63                   MOV         R6,R13
               mnet.c       1617      {
               mnet.c       1618          WriteMemoryPCD4611(value);
    00001030 BF6F                   BSR         __$WriteMemoryPCD4611
    00001032 64D3                   MOV         R13,R4
               mnet.c       1619          WriteMemoryPCD4611(reg);
    00001034 BF6D                   BSR         __$WriteMemoryPCD4611
    00001036 64C3                   MOV         R12,R4
    00001038 A011                   BRA         L371
    0000103A 0009                   NOP
    0000103C              L370:
               mnet.c       1620      }
               mnet.c       1621      else
               mnet.c       1622      {
               mnet.c       1623          WriteMemory   (MNET_FIFO, reg);     // レジスタ書き込み
    0000103C 65CD                   EXTU.W      R12,R5
    0000103E BEEA                   BSR         __$WriteMemory
    00001040 E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1624          WriteMemoryInt(MNET_FIFO, value);   // データ書き込み
    00001042 65DD                   EXTU.W      R13,R5
    00001044 BF0C                   BSR         __$WriteMemoryInt
    00001046 E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1625    
               mnet.c       1626          if( !SetMainCommand((MNET_DATA_COMMUNICATION_BASE + mnetno)) )// FALSE:コマンドセット失敗?
    00001048 E240                   MOV         #64,R2     ; H'00000040
    0000104A 4218                   SHLL8       R2
    0000104C 3E2C                   ADD         R2,R14
    0000104E BF5A                   BSR         __$SetMainCommand
    00001050 64E3                   MOV         R14,R4
    00001052 2008                   TST         R0,R0
    00001054 8905                   BT          L373
               mnet.c       1627          {
               mnet.c       1628              return ( FALSE );
               mnet.c       1629          }
               mnet.c       1630          
               mnet.c       1631          if( EndIdleWait()  == TRUE )        // TRUE:ビジー  
    00001056 B450                   BSR         __$EndIdleWait
    00001058 0009                   NOP
    0000105A 8801                   CMP/EQ      #1,R0
    0000105C 8901                   BT          L373
    0000105E              L371:
               mnet.c       1632          {
               mnet.c       1633              return ( FALSE );
               mnet.c       1634          }
               mnet.c       1635      }
               mnet.c       1636    
               mnet.c       1637    
               mnet.c       1638      return TRUE;
    0000105E A001                   BRA         L374
    00001060 E001                   MOV         #1,R0      ; H'00000001
    00001062              L373:
    00001062 0039                   MOVRT       R0
    00001064              L374:
    00001064 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1639    }
    00001066 006B                   RTS/N
               mnet.c       1640    ///<summary>
               mnet.c       1641    /// 指定モーターデバイスのレジスターからデータを読み込みます
               mnet.c       1642    ///</summary>
               mnet.c       1643    // FALSE:異常、TRUE:成功
               mnet.c       1644    BOOL  GetMotorRegister(UB dev_no, UH reg, INT* value)
    00001068              _GetMotorRegister:               ; function: GetMotorRegister
                                                           ; frame size=24
    00001068 4CF0                   MOVMU.L     R12,@-R15
    0000106A 7FF8                   ADD         #-8,R15
    0000106C D16B                   MOV.L       L626,R1    ; _MNET_NO
    0000106E 604C                   EXTU.B      R4,R0
    00001070 021C                   MOV.B       @(R0,R1),R2; MNET_NO[]
               mnet.c       1645    {
               mnet.c       1646      INT fifo_dat;
               mnet.c       1647      UB mnetno;
               mnet.c       1648      MNETStatus status;
               mnet.c       1649    
               mnet.c       1650      mnetno = MNET_NO[dev_no];
    00001072 6C63                   MOV         R6,R12
    00001074 6E2C                   EXTU.B      R2,R14
               mnet.c       1651    
               mnet.c       1652      if( MNET_DRV_TYPE[mnetno] == PCD4611 )
    00001076 D26A                   MOV.L       L626+4,R2  ; _MNET_DRV_TYPE
    00001078 60E3                   MOV         R14,R0
    0000107A 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    0000107C 8809                   CMP/EQ      #9,R0
    0000107E 8F06                   BF/S        L377
    00001080 6D53                   MOV         R5,R13
               mnet.c       1653      {
               mnet.c       1654          WriteMemoryPCD4611((UB)reg);
    00001082 BF46                   BSR         __$WriteMemoryPCD4611
    00001084 64D3                   MOV         R13,R4
               mnet.c       1655          *value  =  ReadMemoryPCD4611();
    00001086 BF5C                   BSR         __$ReadMemoryPCD4611
    00001088 0009                   NOP
    0000108A A045                   BRA         L378
    0000108C 2C02                   MOV.L       R0,@R12    ; *(value)
    0000108E              L377:
               mnet.c       1656      }
               mnet.c       1657      else
               mnet.c       1658      {
               mnet.c       1659          if (!SetMainCommand(MNET_CMD_CLEAR_RECV_FIFO))      return FALSE;
    0000108E E403                   MOV         #3,R4      ; H'00000003
    00001090 BF39                   BSR         __$SetMainCommand
    00001092 4418                   SHLL8       R4
    00001094 2008                   TST         R0,R0
    00001096 8941                   BT          L380
               mnet.c       1660    
               mnet.c       1661          // リードコマンドをＦＩＦＯへ書き込む
               mnet.c       1662          WriteMemory(MNET_FIFO, reg);
    00001098 65DD                   EXTU.W      R13,R5
    0000109A BEBC                   BSR         __$WriteMemory
    0000109C E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1663          // リードコマンドをＦＩＦＯへ書き込む
               mnet.c       1664          if( !SetMainCommand((MNET_DATA_COMMUNICATION_BASE + mnetno)) )
    0000109E E640                   MOV         #64,R6     ; H'00000040
    000010A0 4618                   SHLL8       R6
    000010A2 3E6C                   ADD         R6,R14
    000010A4 BF2F                   BSR         __$SetMainCommand
    000010A6 64E3                   MOV         R14,R4
    000010A8 2008                   TST         R0,R0
    000010AA 8937                   BT          L380
    000010AC              L381:
               mnet.c       1665          {
               mnet.c       1666              return ( FALSE );
               mnet.c       1667          }
               mnet.c       1668          // ステータスリード処理
               mnet.c       1669          while (TRUE)
               mnet.c       1670          {
               mnet.c       1671              // ステータスリード
               mnet.c       1672              GetMainStatus(&status);
    000010AC BF2E                   BSR         __$GetMainStatus
    000010AE 64F3                   MOV         R15,R4
               mnet.c       1673    
               mnet.c       1674              // CEND = 1?
               mnet.c       1675              if( status.UNID.BIT.CEND == 1 )
    000010B0 84F1                   MOV.B       @(1,R15),R0; (part of)status
    000010B2 8708                   BLD         #0,R0
    000010B4 8FFA                   BF/S        L381
    000010B6 6603                   MOV         R0,R6
               mnet.c       1676              {
               mnet.c       1677                  // EDTE = 0?
               mnet.c       1678                  if(status.UNID.BIT.EDTE == 0 )
    000010B8 876C                   BLD         #4,R6
    000010BA 892F                   BT          L380
               mnet.c       1679                  {
               mnet.c       1680                      // 正常
               mnet.c       1681                      break;
               mnet.c       1682                  }
               mnet.c       1683                  else
               mnet.c       1684                  {
               mnet.c       1685                      // 異常
               mnet.c       1686                      return FALSE;
               mnet.c       1687                  }
               mnet.c       1688              }
               mnet.c       1689          }
               mnet.c       1690          *value  = ((INT)(pMotionnet->fifo0) <<  0);
    000010BC D159                   MOV.L       L626+8,R1  ; _pMotionnet
    000010BE 6212                   MOV.L       @R1,R2     ; pMotionnet
    000010C0 8426                   MOV.B       @(6,R2),R0 ; (pMotionnet)->fifo0
    000010C2 2C02                   MOV.L       R0,@R12    ; *(value)
    000010C4 6603                   MOV         R0,R6
               mnet.c       1691          *value |= ((INT)(pMotionnet->fifo1) <<  8);
    000010C6 6512                   MOV.L       @R1,R5     ; pMotionnet
    000010C8 8457                   MOV.B       @(7,R5),R0 ; (pMotionnet)->fifo1
    000010CA 4018                   SHLL8       R0
    000010CC 260B                   OR          R0,R6
               mnet.c       1692    #ifdef WAIT_TYPE_IFB
               mnet.c       1693          // TRUE:ビジー  
               mnet.c       1694          if( IfbIdleWait() == TRUE )
    000010CE B3FF                   BSR         __$IfbIdleWait
    000010D0 2C62                   MOV.L       R6,@R12    ; *(value)
    000010D2 8801                   CMP/EQ      #1,R0
    000010D4 8922                   BT          L380
               mnet.c       1695          {
               mnet.c       1696              return FALSE;
               mnet.c       1697          }
               mnet.c       1698    #endif
               mnet.c       1699    
               mnet.c       1700          fifo_dat  =  (pMotionnet->fifo0 & 0x000000ff);
    000010D6 D753                   MOV.L       L626+8,R7  ; _pMotionnet
    000010D8 6272                   MOV.L       @R7,R2     ; pMotionnet
               mnet.c       1701          fifo_dat |= ((pMotionnet->fifo1 <<  8) & 0x0000ff00);
               mnet.c       1702          g_Sleep(30);
    000010DA E41E                   MOV         #30,R4     ; H'0000001E
    000010DC 0E00FF00               MOVI20      #65280,R14 ; H'0000FF00
    000010E0 35218006               MOVU.B      @(6,R2),R5 ; (pMotionnet)->fifo0
    000010E4 8427                   MOV.B       @(7,R2),R0 ; (pMotionnet)->fifo1
               mnet.c       1703          fifo_dat |= ((pMotionnet->fifo0 << 16) & 0x00ff0000);
    000010E6 DD4F                   MOV.L       L626+8,R13 ; _pMotionnet
    000010E8 4018                   SHLL8       R0
    000010EA 20E9                   AND         R14,R0
    000010EC 250B                   OR          R0,R5
    000010EE B3E8                   BSR         _g_Sleep
    000010F0 1F51                   MOV.L       R5,@(4,R15); fifo_dat
    000010F2 64D2                   MOV.L       @R13,R4    ; pMotionnet
    000010F4 0101FF00               MOVI20S     #16711680,R1; H'00FF0000
    000010F8 8446                   MOV.B       @(6,R4),R0 ; (pMotionnet)->fifo0
    000010FA 56F1                   MOV.L       @(4,R15),R6; fifo_dat
    000010FC 4028                   SHLL16      R0
               mnet.c       1704          fifo_dat |= ((pMotionnet->fifo1 << 24) & 0xff000000);
               mnet.c       1705          *value  =  fifo_dat;
    000010FE 05F10000               MOVI20S     #-16777216,R5; H'FF000000
    00001102 2019                   AND         R1,R0
    00001104 260B                   OR          R0,R6
    00001106 8447                   MOV.B       @(7,R4),R0 ; (pMotionnet)->fifo1
    00001108 4028                   SHLL16      R0
    0000110A 4018                   SHLL8       R0
    0000110C 2059                   AND         R5,R0
    0000110E 260B                   OR          R0,R6
               mnet.c       1706    #ifdef WAIT_END_CHK
               mnet.c       1707          // TRUE:ビジー  
               mnet.c       1708          if( EndIdleWait()  == TRUE )
    00001110 B3F3                   BSR         __$EndIdleWait
    00001112 2C62                   MOV.L       R6,@R12    ; *(value)
    00001114 8801                   CMP/EQ      #1,R0
    00001116 8901                   BT          L380
    00001118              L378:
               mnet.c       1709          {
               mnet.c       1710              return FALSE;
               mnet.c       1711          }
               mnet.c       1712    #endif
               mnet.c       1713      }
               mnet.c       1714    
               mnet.c       1715      
               mnet.c       1716      return( TRUE );
    00001118 A001                   BRA         L385
    0000111A E001                   MOV         #1,R0      ; H'00000001
    0000111C              L380:
    0000111C 0039                   MOVRT       R0
    0000111E              L385:
    0000111E 7F08                   ADD         #8,R15
    00001120 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1717    }
    00001122 006B                   RTS/N
               mnet.c       1718    
               mnet.c       1719    
               mnet.c       1720    ///<summary>
               mnet.c       1721    /// 指定モーターデバイスのステータスを読み込みます( PCD4611以外 )
               mnet.c       1722    ///</summary>
               mnet.c       1723    BOOL GetMotorStatus(UB dev_no, MotorStatus* status)
    00001124              _GetMotorStatus:                 ; function: GetMotorStatus
                                                           ; frame size=20
    00001124 4BF0                   MOVMU.L     R11,@-R15
    00001126 6E43                   MOV         R4,R14
    00001128 644C                   EXTU.B      R4,R4
               mnet.c       1724    {
               mnet.c       1725      UB Data_H = 0;
               mnet.c       1726      UB Data_L = 0;
               mnet.c       1727      UH Data_HL;
               mnet.c       1728    
               mnet.c       1729      if (!IsExist( dev_no ))
    0000112A B039                   BSR         _IsExist
    0000112C 6B53                   MOV         R5,R11
    0000112E 2008                   TST         R0,R0
    00001130 8D34                   BT/S        L388
    00001132 E000                   MOV         #0,R0      ; H'00000000
               mnet.c       1730      {
               mnet.c       1731          return FALSE;
               mnet.c       1732      }
               mnet.c       1733      
               mnet.c       1734      //  struct
               mnet.c       1735      //  {
               mnet.c       1736      //      UH  reserve2: 7;    // 常に0になります。
               mnet.c       1737      //      UH  SBSY    : 1;    // パルス出力開始で１になります。動作停止で０になります。（＝ＢＳＹ）
               mnet.c       1738      //      UH  reserve1: 4;    // 常に0になります。
               mnet.c       1739      //      UH  SEVT    : 1;    // イベント割り込み発生により１になり、ＲＩＳＴ読み出しで０になります。
               mnet.c       1740      //      UH  SERR    : 1;    // エラー割り込み発生により１になり、ＲＥＳＴ読み出しで０になります。
               mnet.c       1741      //      UH  SEND    : 1;    // 動作停止により割り込みを発生し、１になります。割り込みリセットコマンド(0008h)で０になります。
               mnet.c       1742      //      UH  SINT    : 1;    // 割り込み発生により１になります。(ビット１,２,３のいずれかが１)
               mnet.c       1743      //  }BIT;
               mnet.c       1744      MAC_READ( pMotionnet->portData[dev_no][0], Data_L )
    00001134 6DEC                   EXTU.B      R14,R13
    00001136 E201                   MOV         #1,R2      ; H'00000001
    00001138 DE3A                   MOV.L       L626+8,R14 ; _pMotionnet
    0000113A 61E2                   MOV.L       @R14,R1    ; pMotionnet
    0000113C 4218                   SHLL8       R2
    0000113E 4D08                   SHLL2       R13
    00001140 E500                   MOV         #0,R5      ; H'00000000
    00001142 312C                   ADD         R2,R1
    00001144 60D3                   MOV         R13,R0
    00001146 021C                   MOV.B       @(R0,R1),R2; pMotionnet->portData[]
    00001148 EC05                   MOV         #5,R12     ; H'00000005
    0000114A 642C                   EXTU.B      R2,R4
    0000114C A009                   BRA         L389
    0000114E 6743                   MOV         R4,R7
    00001150              L390:
    00001150 60D3                   MOV         R13,R0
    00001152 021C                   MOV.B       @(R0,R1),R2; pMotionnet->portData[]
    00001154 622C                   EXTU.B      R2,R2
    00001156 3240                   CMP/EQ      R4,R2
    00001158 8902                   BT          L392
    0000115A E500                   MOV         #0,R5      ; H'00000000
    0000115C 6723                   MOV         R2,R7
    0000115E 6423                   MOV         R2,R4
    00001160              L392:
    00001160 7501                   ADD         #1,R5
    00001162              L389:
    00001162 35C3                   CMP/GE      R12,R5
    00001164 8BF4                   BF          L390
               mnet.c       1745      MAC_READ( pMotionnet->portData[dev_no][1], Data_H )
    00001166 6EE2                   MOV.L       @R14,R14   ; pMotionnet
    00001168 60D3                   MOV         R13,R0
    0000116A 04000101               MOVI20      #257,R4    ; H'00000101
    0000116E 3E4C                   ADD         R4,R14
    00001170 E500                   MOV         #0,R5      ; H'00000000
    00001172 02EC                   MOV.B       @(R0,R14),R2; pMotionnet->portData[]
    00001174 612C                   EXTU.B      R2,R1
    00001176 A009                   BRA         L394
    00001178 6413                   MOV         R1,R4
    0000117A              L395:
    0000117A 60D3                   MOV         R13,R0
    0000117C 02EC                   MOV.B       @(R0,R14),R2; pMotionnet->portData[]
    0000117E 662C                   EXTU.B      R2,R6
    00001180 3610                   CMP/EQ      R1,R6
    00001182 8902                   BT          L397
    00001184 E500                   MOV         #0,R5      ; H'00000000
    00001186 6463                   MOV         R6,R4
    00001188 6163                   MOV         R6,R1
    0000118A              L397:
    0000118A 7501                   ADD         #1,R5
    0000118C              L394:
    0000118C 35C3                   CMP/GE      R12,R5
    0000118E 8BF4                   BF          L395
               mnet.c       1746    
               mnet.c       1747      status->UNID.data = ( ( Data_H * 0x100 ) + Data_L ) ;
    00001190 644C                   EXTU.B      R4,R4
               mnet.c       1748    
               mnet.c       1749      return TRUE;
    00001192 E001                   MOV         #1,R0      ; H'00000001
    00001194 4418                   SHLL8       R4
    00001196 677C                   EXTU.B      R7,R7
    00001198 347C                   ADD         R7,R4
    0000119A 2B41                   MOV.W       R4,@R11    ; (status)->data
    0000119C              L388:
    0000119C 4BF4                   MOVMU.L     @R15+,R11
               mnet.c       1750    }
    0000119E 006B                   RTS/N
               mnet.c       1751    /******************************************************************************
               mnet.c       1752    * 
               mnet.c       1753    * [概要]  指定デバイスが存在するかチェックします
               mnet.c       1754    * [引数]  モーター番号
               mnet.c       1755    * [戻値]  TRUE:デバイス有、FALSE:デバイス無
               mnet.c       1756    * 
               mnet.c       1757    ******************************************************************************/
               mnet.c       1758    BOOL IsExist(UB dev_no)
    000011A0              _IsExist:                        ; function: IsExist
                                                           ; frame size=8
    000011A0 2FD6                   MOV.L       R13,@-R15
    000011A2 2FE6                   MOV.L       R14,@-R15
               mnet.c       1759    {
               mnet.c       1760      UB result = 0;
               mnet.c       1761      UB mnetno ;
               mnet.c       1762    
               mnet.c       1763      // 接続上限を超えている？
               mnet.c       1764      if( ( dev_no > DVMAX )||( ( dev_no < DVMIN ) ))
    000011A4 644C                   EXTU.B      R4,R4
    000011A6 E607                   MOV         #7,R6      ; H'00000007
    000011A8 3467                   CMP/GT      R6,R4
    000011AA 8933                   BT          L408
    000011AC E601                   MOV         #1,R6      ; H'00000001
    000011AE 3463                   CMP/GE      R6,R4
    000011B0 8B30                   BF          L408
               mnet.c       1765      {
               mnet.c       1766          return( FALSE );
               mnet.c       1767      }
               mnet.c       1768    
               mnet.c       1769      switch( MNET_DRV_TYPE[dev_no] )
    000011B2 D61B                   MOV.L       L626+4,R6  ; _MNET_DRV_TYPE
    000011B4 6043                   MOV         R4,R0
    000011B6 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    000011B8 2008                   TST         R0,R0
    000011BA 8901                   BT          L411
    000011BC 8801                   CMP/EQ      #1,R0
    000011BE 8B01                   BF          L412
    000011C0              L411:
               mnet.c       1770      {
               mnet.c       1771      case BCD4020FU:
               mnet.c       1772      case BCD4020FUA:
               mnet.c       1773          mnetno = dev_no;
    000011C0 A00E                   BRA         L413
    000011C2 6743                   MOV         R4,R7
    000011C4              L412:
    000011C4 8809                   CMP/EQ      #9,R0
    000011C6 8909                   BT          L415
    000011C8 8808                   CMP/EQ      #8,R0
    000011CA 8903                   BT          L417
    000011CC 880A                   CMP/EQ      #10,R0
    000011CE 8905                   BT          L415
    000011D0 A006                   BRA         L413
    000011D2 0009                   NOP
    000011D4              L417:
               mnet.c       1774          break;
               mnet.c       1775    
               mnet.c       1776      case PCD4611:
               mnet.c       1777          return TRUE;
               mnet.c       1778          break;
               mnet.c       1779    
               mnet.c       1780      case M204DUM:
               mnet.c       1781          mnetno = MNET_NO[dev_no]; 
    000011D4 D211                   MOV.L       L626,R2    ; _MNET_NO
    000011D6 6043                   MOV         R4,R0
    000011D8 A002                   BRA         L413
    000011DA 072C                   MOV.B       @(R0,R2),R7; MNET_NO[]
    000011DC              L415:
    000011DC A01B                   BRA         L418
    000011DE 0029                   MOVT        R0
    000011E0              L413:
               mnet.c       1782          break;
               mnet.c       1783      case NCPRSUNIT:
               mnet.c       1784          return TRUE;
               mnet.c       1785          break;
               mnet.c       1786      }
               mnet.c       1787    
               mnet.c       1788    // シュミレーションモード
               mnet.c       1789    #if DEBUG_SIM_MODE != 0
               mnet.c       1790      return( TRUE ) ;
               mnet.c       1791    #endif
               mnet.c       1792      
               mnet.c       1793      MAC_READ( pMotionnet->deviceInformation[mnetno], result );
    000011E0 D610                   MOV.L       L626+8,R6  ; _pMotionnet
    000011E2 6E62                   MOV.L       @R6,R14    ; pMotionnet
    000011E4 677C                   EXTU.B      R7,R7
    000011E6 6073                   MOV         R7,R0
    000011E8 E500                   MOV         #0,R5      ; H'00000000
    000011EA 7E78                   ADD         #120,R14
    000011EC ED05                   MOV         #5,R13     ; H'00000005
    000011EE 02EC                   MOV.B       @(R0,R14),R2; pMotionnet->deviceInformation[]
    000011F0 642C                   EXTU.B      R2,R4
    000011F2 A009                   BRA         L419
    000011F4 6143                   MOV         R4,R1
    000011F6              L420:
    000011F6 6073                   MOV         R7,R0
    000011F8 02EC                   MOV.B       @(R0,R14),R2; pMotionnet->deviceInformation[]
    000011FA 622C                   EXTU.B      R2,R2
    000011FC 3240                   CMP/EQ      R4,R2
    000011FE 8902                   BT          L422
    00001200 E500                   MOV         #0,R5      ; H'00000000
    00001202 6123                   MOV         R2,R1
    00001204 6423                   MOV         R2,R4
    00001206              L422:
    00001206 7501                   ADD         #1,R5
    00001208              L419:
    00001208 35D3                   CMP/GE      R13,R5
    0000120A 8BF4                   BF          L420
               mnet.c       1794    
               mnet.c       1795      return result != 0;
    0000120C 611C                   EXTU.B      R1,R1
    0000120E 2118                   TST         R1,R1
    00001210 A001                   BRA         L418
    00001212 0039                   MOVRT       R0
    00001214              L408:
    00001214 E000                   MOV         #0,R0      ; H'00000000
    00001216              L418:
    00001216 6EF6                   MOV.L       @R15+,R14
               mnet.c       1796    }
    00001218 000B                   RTS
    0000121A 6DF6                   MOV.L       @R15+,R13
    0000121C              L626:
    0000121C <00000000>             .DATA.L     _MNET_NO
    00001220 <00000000>             .DATA.L     _MNET_DRV_TYPE
    00001224 <00000000>             .DATA.L     _pMotionnet
               mnet.c       1797    
               mnet.c       1798    static    INT pcd_rsts;
               mnet.c       1799    
               mnet.c       1800    /******************************************************************************
               mnet.c       1801    * 
               mnet.c       1802    * [概要]  パルスモータが実行状態を返す
               mnet.c       1803    * [引数]  モーター番号
               mnet.c       1804    * [戻値]  TRUE:実行中、FALSE:アイドリング
               mnet.c       1805    * 
               mnet.c       1806    ******************************************************************************/
               mnet.c       1807    BOOL motor_IsBusy(UB pm)
    00001228              _motor_IsBusy:                   ; function: motor_IsBusy
                                                           ; frame size=28
    00001228 4AF0                   MOVMU.L     R10,@-R15
    0000122A 7FFC                   ADD         #-4,R15
               mnet.c       1808    {
               mnet.c       1809      INT Loop;
               mnet.c       1810      UH  wk = 0;
               mnet.c       1811      MotorStatus mstatus;
               mnet.c       1812    
               mnet.c       1813      if (!IsExist( pm ))
    0000122C 6E4C                   EXTU.B      R4,R14
    0000122E EA00                   MOV         #0,R10     ; H'00000000
    00001230 6D43                   MOV         R4,R13
    00001232 BFB5                   BSR         _IsExist
    00001234 64E3                   MOV         R14,R4
    00001236 2008                   TST         R0,R0
    00001238 8934                   BT          L426
               mnet.c       1814      {
               mnet.c       1815          return FALSE;
               mnet.c       1816      }
               mnet.c       1817      
               mnet.c       1818      if( MNET_DRV_TYPE[pm] == PCD4611 )
    0000123A D681                   MOV.L       L627,R6    ; _MNET_DRV_TYPE
    0000123C 60DC                   EXTU.B      R13,R0
    0000123E 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00001240 8809                   CMP/EQ      #9,R0
    00001242 8B17                   BF          L428
               mnet.c       1819      {
               mnet.c       1820          WriteMemoryPCD4611(RRG_RSTS);
    00001244 BE65                   BSR         __$WriteMemoryPCD4611
    00001246 E4F1                   MOV         #-15,R4    ; H'FFFFFFF1
               mnet.c       1821          pcd_rsts = ReadMemoryPCD4611();
    00001248 BE7B                   BSR         __$ReadMemoryPCD4611
    0000124A 0009                   NOP
    0000124C D57D                   MOV.L       L627+4,R5  ; __$pcd_rsts
    0000124E 6603                   MOV         R0,R6
    00001250 2502                   MOV.L       R0,@R5     ; pcd_rsts
               mnet.c       1822          
               mnet.c       1823          if(
    00001252 C90A                   AND         #10,R0
    00001254 880A                   CMP/EQ      #10,R0
    00001256 8923                   BT          L430
    00001258 6063                   MOV         R6,R0
    0000125A C90B                   AND         #11,R0
    0000125C 880B                   CMP/EQ      #11,R0
    0000125E 891F                   BT          L430
    00001260 6063                   MOV         R6,R0
    00001262 C90C                   AND         #12,R0
    00001264 880C                   CMP/EQ      #12,R0
    00001266 891B                   BT          L430
    00001268 6063                   MOV         R6,R0
    0000126A C90D                   AND         #13,R0
    0000126C 880D                   CMP/EQ      #13,R0
    0000126E 8917                   BT          L430
    00001270 A018                   BRA         L426
    00001272 0009                   NOP
    00001274              L428:
               mnet.c       1824              ( (pcd_rsts & 0x0000000A) == 0x0000000A )||
               mnet.c       1825              ( (pcd_rsts & 0x0000000B) == 0x0000000B )||
               mnet.c       1826              ( (pcd_rsts & 0x0000000C) == 0x0000000C )||
               mnet.c       1827              ( (pcd_rsts & 0x0000000D) == 0x0000000D )
               mnet.c       1828          )
               mnet.c       1829          {
               mnet.c       1830              return TRUE;
               mnet.c       1831          }
               mnet.c       1832          else
               mnet.c       1833          {
               mnet.c       1834              return FALSE;
               mnet.c       1835          }
               mnet.c       1836      }
               mnet.c       1837      else
               mnet.c       1838      {
               mnet.c       1839          for( Loop = 0; Loop <= 3; Loop++ )
    00001274 ED00                   MOV         #0,R13     ; H'00000000
    00001276 EC03                   MOV         #3,R12     ; H'00000003
    00001278 A00D                   BRA         L433
    0000127A 6BD3                   MOV         R13,R11
    0000127C              L434:
               mnet.c       1840          {
               mnet.c       1841              GetMotorStatus(pm, (MotorStatus* )&mstatus);
    0000127C 64E3                   MOV         R14,R4
    0000127E BF51                   BSR         _GetMotorStatus
    00001280 65F3                   MOV         R15,R5
               mnet.c       1842    
               mnet.c       1843              if ( wk != mstatus.UNID.BIT.SBSY )
    00001282 66F0                   MOV.B       @R15,R6    ; (part of)mstatus
    00001284 8768                   BLD         #0,R6
    00001286 0229                   MOVT        R2
    00001288 3B20                   CMP/EQ      R2,R11
    0000128A 8903                   BT          L436
               mnet.c       1844              {
               mnet.c       1845                  wk = mstatus.UNID.BIT.SBSY;
    0000128C 8768                   BLD         #0,R6
    0000128E 0B29                   MOVT        R11
               mnet.c       1846                  Loop = 0;
    00001290 ED00                   MOV         #0,R13     ; H'00000000
    00001292 6AB3                   MOV         R11,R10
    00001294              L436:
    00001294 7D01                   ADD         #1,R13
    00001296              L433:
    00001296 3DC7                   CMP/GT      R12,R13
    00001298 8BF0                   BF          L434
               mnet.c       1847              }
               mnet.c       1848          }
               mnet.c       1849          
               mnet.c       1850          if( wk == 0)
    0000129A 6AAD                   EXTU.W      R10,R10
    0000129C 2AA8                   TST         R10,R10
    0000129E 8901                   BT          L426
    000012A0              L430:
    000012A0 A001                   BRA         L438
    000012A2 E001                   MOV         #1,R0      ; H'00000001
    000012A4              L426:
    000012A4 E000                   MOV         #0,R0      ; H'00000000
    000012A6              L438:
    000012A6 7F04                   ADD         #4,R15
    000012A8 4AF4                   MOVMU.L     @R15+,R10
               mnet.c       1851          {
               mnet.c       1852              return FALSE;
               mnet.c       1853          }
               mnet.c       1854      }
               mnet.c       1855      return TRUE;
               mnet.c       1856    }
    000012AA 006B                   RTS/N
               mnet.c       1857    
               mnet.c       1858    /******************************************************************************
               mnet.c       1859    * 
               mnet.c       1860    * [概要]  パルスモータが指定方向のリミット位置の場合TRUEを返す関数
               mnet.c       1861    * [引数]  モーター番号、方向
               mnet.c       1862    * [戻値]  TRUE:リミット、FALSE:リミット以外
               mnet.c       1863    * 
               mnet.c       1864    ******************************************************************************/
               mnet.c       1865    BOOL motor_IsLimit(UB pm, UH dir)
    000012AC              _motor_IsLimit:                  ; function: motor_IsLimit
                                                           ; frame size=16
    000012AC 4DF0                   MOVMU.L     R13,@-R15
    000012AE 7FFC                   ADD         #-4,R15
               mnet.c       1866    {
               mnet.c       1867      BOOL result = FALSE;
               mnet.c       1868      RSTS rsts;
               mnet.c       1869      INT  rest= 0;
               mnet.c       1870    
               mnet.c       1871      if( MNET_DRV_TYPE[pm] == PCD4611 )
    000012B0 D663                   MOV.L       L627,R6    ; _MNET_DRV_TYPE
    000012B2 644C                   EXTU.B      R4,R4
    000012B4 ED00                   MOV         #0,R13     ; H'00000000
    000012B6 6043                   MOV         R4,R0
    000012B8 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    000012BA 8809                   CMP/EQ      #9,R0
    000012BC 8F12                   BF/S        L441
    000012BE 6E53                   MOV         R5,R14
               mnet.c       1872      {
               mnet.c       1873          WriteMemoryPCD4611(RRG_REST);
    000012C0 BE27                   BSR         __$WriteMemoryPCD4611
    000012C2 E4F2                   MOV         #-14,R4    ; H'FFFFFFF2
               mnet.c       1874          rest = ReadMemoryPCD4611();
    000012C4 BE3D                   BSR         __$ReadMemoryPCD4611
    000012C6 0009                   NOP
               mnet.c       1875          
               mnet.c       1876          if( dir == CW )
    000012C8 62ED                   EXTU.W      R14,R2
    000012CA 6603                   MOV         R0,R6
    000012CC 6023                   MOV         R2,R0
    000012CE 8801                   CMP/EQ      #1,R0
    000012D0 8B01                   BF          L443
               mnet.c       1877          {
               mnet.c       1878              if((rest & 0x00000001))     return( TRUE );
    000012D2 8768                   BLD         #0,R6
    000012D4 8904                   BT          L444
    000012D6              L443:
               mnet.c       1879          }
               mnet.c       1880          if( dir == CCW )
    000012D6 6023                   MOV         R2,R0
    000012D8 8802                   CMP/EQ      #2,R0
    000012DA 8B1A                   BF          L446
               mnet.c       1881          {
               mnet.c       1882              if((rest & 0x00000002))     return( TRUE );
    000012DC 8769                   BLD         #1,R6
    000012DE 8B18                   BF          L446
    000012E0              L444:
    000012E0 A018                   BRA         L447
    000012E2 0029                   MOVT        R0
    000012E4              L441:
    000012E4 E5F1                   MOV         #-15,R5    ; H'FFFFFFF1
               mnet.c       1883          }
               mnet.c       1884      }
               mnet.c       1885      else
               mnet.c       1886      {
               mnet.c       1887          if (!GetMotorRegister(pm, RRG_RSTS, &rsts.UNID.data))
    000012E6 66F3                   MOV         R15,R6
    000012E8 BEBE                   BSR         _GetMotorRegister
    000012EA 655C                   EXTU.B      R5,R5
    000012EC 2008                   TST         R0,R0
    000012EE 8B01                   BF          L449
               mnet.c       1888          {
               mnet.c       1889              return( result );
    000012F0 A010                   BRA         L447
    000012F2 0039                   MOVRT       R0
    000012F4              L449:
               mnet.c       1890          }
               mnet.c       1891    
               mnet.c       1892          if( dir == CW )
    000012F4 62ED                   EXTU.W      R14,R2
    000012F6 6023                   MOV         R2,R0
    000012F8 8801                   CMP/EQ      #1,R0
    000012FA 8B03                   BF          L451
               mnet.c       1893          {
               mnet.c       1894              if( rsts.UNID.BIT.SPEL )
    000012FC 3F693003               BLD.B       #6,@(3,R15); (part of)rsts
    00001300 8B00                   BF          L451
               mnet.c       1895              {
               mnet.c       1896                  result = TRUE;
    00001302 ED01                   MOV         #1,R13     ; H'00000001
    00001304              L451:
               mnet.c       1897              }
               mnet.c       1898          }
               mnet.c       1899          if( dir == CCW )
    00001304 6023                   MOV         R2,R0
    00001306 8802                   CMP/EQ      #2,R0
    00001308 8B03                   BF          L446
               mnet.c       1900          {
               mnet.c       1901              if( rsts.UNID.BIT.SMEL )
    0000130A 3F793003               BLD.B       #7,@(3,R15); (part of)rsts
    0000130E 8B00                   BF          L446
               mnet.c       1902              {
               mnet.c       1903                  result = TRUE;
    00001310 ED01                   MOV         #1,R13     ; H'00000001
    00001312              L446:
               mnet.c       1904              }
               mnet.c       1905          }
               mnet.c       1906      }
               mnet.c       1907      return( result );
    00001312 60D3                   MOV         R13,R0
    00001314              L447:
    00001314 7F04                   ADD         #4,R15
    00001316 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1908    }
    00001318 006B                   RTS/N
               mnet.c       1909    /******************************************************************************
               mnet.c       1910    * 
               mnet.c       1911    * [概要]  指定パルスモータがリミット位置の場合TRUEを返す関数
               mnet.c       1912    * [引数]  モーター番号
               mnet.c       1913    * [戻値]  TRUE:リミット、FALSE:リミット以外
               mnet.c       1914    * 
               mnet.c       1915    ******************************************************************************/
               mnet.c       1916    BOOL motor_IsLimitW(UB pm)
    0000131A              _motor_IsLimitW:                 ; function: motor_IsLimitW
                                                           ; frame size=8
    0000131A 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       1917    {
               mnet.c       1918      if( motor_IsLimit(pm,CW) == TRUE )  return( TRUE );
    0000131C 644C                   EXTU.B      R4,R4
    0000131E E501                   MOV         #1,R5      ; H'00000001
    00001320 BFC4                   BSR         _motor_IsLimit
    00001322 6E43                   MOV         R4,R14
    00001324 8801                   CMP/EQ      #1,R0
    00001326 8903                   BT          L457
               mnet.c       1919      if( motor_IsLimit(pm,CCW) == TRUE ) return( TRUE );
    00001328 E502                   MOV         #2,R5      ; H'00000002
    0000132A BFBF                   BSR         _motor_IsLimit
    0000132C 64E3                   MOV         R14,R4
    0000132E 8801                   CMP/EQ      #1,R0
    00001330              L457:
               mnet.c       1920    
               mnet.c       1921      return( FALSE );
    00001330 0029                   MOVT        R0
    00001332 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       1922    }
    00001334 006B                   RTS/N
               mnet.c       1923    /******************************************************************************
               mnet.c       1924    * 
               mnet.c       1925    * [概要]  エンコーダ有無を取得
               mnet.c       1926    * [引数]  モーター番号
               mnet.c       1927    * [戻値]  TRUE:有、FALSE:無
               mnet.c       1928    * 
               mnet.c       1929    ******************************************************************************/
               mnet.c       1930    BOOL IsEncoderExist(UB pm)
    00001336              _IsEncoderExist:                 ; function: IsEncoderExist
                                                           ; frame size=0
               mnet.c       1931    {
               mnet.c       1932      BOOL    result = FALSE;
               mnet.c       1933      UB      index;
               mnet.c       1934      UB      bitsfh = 0x00;
               mnet.c       1935      UB      bitdat = 0x01;
               mnet.c       1936      UB      pmwk;
               mnet.c       1937    
               mnet.c       1938      // モータ範囲外
               mnet.c       1939      if( pm > DVMAX )    return( result );
    00001336 664C                   EXTU.B      R4,R6
    00001338 E107                   MOV         #7,R1      ; H'00000007
    0000133A 3617                   CMP/GT      R1,R6
    0000133C 6243                   MOV         R4,R2
    0000133E 8D14                   BT/S        L460
    00001340 E500                   MOV         #0,R5      ; H'00000000
               mnet.c       1940      
               mnet.c       1941      // bit0    チャネル1
               mnet.c       1942      // bit1    チャネル2
               mnet.c       1943      // ・
               mnet.c       1944      // bit63   チャネル64
               mnet.c       1945      if( pm == 0 )       return( result );
    00001342 2668                   TST         R6,R6
    00001344 8911                   BT          L460
               mnet.c       1946      pmwk = pm - 1;
               mnet.c       1947    
               mnet.c       1948      index  = ( pmwk / 8 );
               mnet.c       1949      bitsfh = ( pmwk % 8 );
               mnet.c       1950      bitdat = (bitdat << bitsfh);
               mnet.c       1951      
               mnet.c       1952      // エンコーダ付き
               mnet.c       1953      if( (ENCODER_EXIST[index] & bitdat) )
    00001346 72FF                   ADD         #-1,R2
    00001348 E7FD                   MOV         #-3,R7     ; H'FFFFFFFD
    0000134A 642C                   EXTU.B      R2,R4
    0000134C E601                   MOV         #1,R6      ; H'00000001
    0000134E 6143                   MOV         R4,R1
    00001350 417C                   SHAD        R7,R1
    00001352 D23D                   MOV.L       L627+8,R2  ; _ENCODER_EXIST
    00001354 601C                   EXTU.B      R1,R0
    00001356 012C                   MOV.B       @(R0,R2),R1; ENCODER_EXIST[]
    00001358 6043                   MOV         R4,R0
    0000135A C907                   AND         #7,R0
    0000135C 460C                   SHAD        R0,R6
    0000135E 646C                   EXTU.B      R6,R4
    00001360 2148                   TST         R4,R1
    00001362 8900                   BT          L463
               mnet.c       1954      {
               mnet.c       1955          result = TRUE;
    00001364 E501                   MOV         #1,R5      ; H'00000001
    00001366              L463:
    00001366 000B                   RTS
    00001368 6053                   MOV         R5,R0
    0000136A              L460:
    0000136A 000B                   RTS
    0000136C E000                   MOV         #0,R0      ; H'00000000
               mnet.c       1956      }
               mnet.c       1957      
               mnet.c       1958      return( result );
               mnet.c       1959    }
               mnet.c       1960    /******************************************************************************
               mnet.c       1961    * 
               mnet.c       1962    * [概要]  パルスモータを励磁
               mnet.c       1963    * [引数]  モーター番号、励磁動作指示
               mnet.c       1964    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1965    * 
               mnet.c       1966    ******************************************************************************/
               mnet.c       1967    BOOL motor_PowerUp(UB pm, UB sw)
    0000136E              _motor_PowerUp:                  ; function: motor_PowerUp
                                                           ; frame size=36
    0000136E 48F0                   MOVMU.L     R8,@-R15
    00001370 7FFC                   ADD         #-4,R15
               mnet.c       1968    {
               mnet.c       1969      INT cnt;
               mnet.c       1970      INT rcnt;
               mnet.c       1971      UB DataCmp;
               mnet.c       1972      UB DataSet;
               mnet.c       1973      UB mnet_drv_typ;
               mnet.c       1974    
               mnet.c       1975      mnet_drv_typ = MNET_DRV_TYPE[pm];
    00001372 664C                   EXTU.B      R4,R6
    00001374 D132                   MOV.L       L627,R1    ; _MNET_DRV_TYPE
    00001376 6063                   MOV         R6,R0
    00001378 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    0000137A 675C                   EXTU.B      R5,R7
               mnet.c       1976    
               mnet.c       1977      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    0000137C 880A                   CMP/EQ      #10,R0
    0000137E 8D67                   BT/S        L471
    00001380 6E0C                   EXTU.B      R0,R14
               mnet.c       1978      {
               mnet.c       1979          return( TRUE );
               mnet.c       1980      }
               mnet.c       1981    
               mnet.c       1982      if(
    00001382 60E3                   MOV         R14,R0
    00001384 8801                   CMP/EQ      #1,R0
    00001386 8901                   BT          L473
    00001388 2EE8                   TST         R14,R14
    0000138A 8B57                   BF          L474
    0000138C              L473:
    0000138C D22F                   MOV.L       L627+12,R2 ; _pMotionnet
    0000138E 6122                   MOV.L       @R2,R1     ; pMotionnet
               mnet.c       1983          ( mnet_drv_typ != BCD4020FUA )&&
               mnet.c       1984          ( mnet_drv_typ != BCD4020FU )
               mnet.c       1985      )
               mnet.c       1986      {
               mnet.c       1987          return FALSE;
               mnet.c       1988      }
               mnet.c       1989      
               mnet.c       1990      MAC_READ( pMotionnet->portData[pm][2], DataSet );
    00001390 4608                   SHLL2       R6
    00001392 08000102               MOVI20      #258,R8    ; H'00000102
    00001396 318C                   ADD         R8,R1
    00001398 6063                   MOV         R6,R0
    0000139A 021C                   MOV.B       @(R0,R1),R2; pMotionnet->portData[]
    0000139C 6D63                   MOV         R6,R13
    0000139E E500                   MOV         #0,R5      ; H'00000000
    000013A0 EC05                   MOV         #5,R12     ; H'00000005
    000013A2 642C                   EXTU.B      R2,R4
    000013A4 A009                   BRA         L475
    000013A6 6A43                   MOV         R4,R10
    000013A8              L476:
    000013A8 60D3                   MOV         R13,R0
    000013AA 021C                   MOV.B       @(R0,R1),R2; pMotionnet->portData[]
    000013AC 622C                   EXTU.B      R2,R2
    000013AE 3240                   CMP/EQ      R4,R2
    000013B0 8902                   BT          L478
    000013B2 E500                   MOV         #0,R5      ; H'00000000
    000013B4 6A23                   MOV         R2,R10
    000013B6 6423                   MOV         R2,R4
    000013B8              L478:
    000013B8 7501                   ADD         #1,R5
    000013BA              L475:
    000013BA 35C3                   CMP/GE      R12,R5
    000013BC 8BF4                   BF          L476
               mnet.c       1991    
               mnet.c       1992      switch( mnet_drv_typ )
    000013BE 60E3                   MOV         R14,R0
    000013C0 8801                   CMP/EQ      #1,R0
    000013C2 8903                   BT          L481
    000013C4 2EE8                   TST         R14,R14
    000013C6 8904                   BT          L482
    000013C8 A006                   BRA         L483
    000013CA 0009                   NOP
    000013CC              L481:
               mnet.c       1993      {
               mnet.c       1994      case BCD4020FUA:
               mnet.c       1995          if (sw)
    000013CC 2778                   TST         R7,R7
    000013CE A003                   BRA         L483
    000013D0 87A0                   BST         #0,R10
    000013D2              L482:
               mnet.c       1996          {
               mnet.c       1997              DataSet &= (~0x01); // 励磁ON
               mnet.c       1998          }
               mnet.c       1999          else
               mnet.c       2000          {
               mnet.c       2001              DataSet |= 0x01;    // 励磁OFF
               mnet.c       2002          }
               mnet.c       2003          break;
               mnet.c       2004      case BCD4020FU:
               mnet.c       2005          if (sw)
    000013D2 2778                   TST         R7,R7
    000013D4 0068                   NOTT
    000013D6 87A6                   BST         #6,R10
    000013D8              L483:
    000013D8 E203                   MOV         #3,R2      ; H'00000003
               mnet.c       2006          {
               mnet.c       2007              DataSet |= 0x40;    // 励磁ON
               mnet.c       2008          }
               mnet.c       2009          else
               mnet.c       2010          {
               mnet.c       2011              DataSet &= (~0x40); // 励磁OFF
               mnet.c       2012          }
               mnet.c       2013          break;
               mnet.c       2014      }
               mnet.c       2015    
               mnet.c       2016    //x       g_Sleep(20);
               mnet.c       2017    //x       g_Sleep(40);
               mnet.c       2018    //o       g_Sleep(50);
               mnet.c       2019    //o       g_Sleep(60);
               mnet.c       2020    //o       g_Sleep(500);
               mnet.c       2021    //o       g_Sleep(250);
               mnet.c       2022    //o       g_Sleep(120);
               mnet.c       2023      for( cnt = 0; cnt < READ_RTY_MAX; cnt++ )
    000013DA 69AC                   EXTU.B      R10,R9
    000013DC 2F22                   MOV.L       R2,@R15
    000013DE 0B000103               MOVI20      #259,R11   ; H'00000103
    000013E2              L484:
               mnet.c       2024      {
               mnet.c       2025          MAC_WRIT( pMotionnet->portData[pm][3], DataSet  );
    000013E2 D11A                   MOV.L       L627+12,R1 ; _pMotionnet
    000013E4 6512                   MOV.L       @R1,R5     ; pMotionnet
    000013E6 60D3                   MOV         R13,R0
    000013E8 35BC                   ADD         R11,R5
    000013EA 05A4                   MOV.B       R10,@(R0,R5); pMotionnet->portData[]
    000013EC E605                   MOV         #5,R6      ; H'00000005
    000013EE 60D3                   MOV         R13,R0
    000013F0 D116                   MOV.L       L627+12,R1 ; _pMotionnet
    000013F2              L486:
    000013F2 6412                   MOV.L       @R1,R4     ; pMotionnet
    000013F4 4610                   DT          R6
    000013F6 34BC                   ADD         R11,R4
    000013F8 8FFB                   BF/S        L486
    000013FA 04A4                   MOV.B       R10,@(R0,R4); pMotionnet->portData[]
               mnet.c       2026    
               mnet.c       2027          for( rcnt = 0; rcnt < READ_RTY_MAX; rcnt++ )
    000013FC EE03                   MOV         #3,R14     ; H'00000003
    000013FE              L488:
               mnet.c       2028          {
               mnet.c       2029              g_Sleep(WAITTIM);
    000013FE B260                   BSR         _g_Sleep
    00001400 E43C                   MOV         #60,R4     ; H'0000003C
               mnet.c       2030              MAC_READ( pMotionnet->portData[pm][2], DataCmp );
    00001402 D412                   MOV.L       L627+12,R4 ; _pMotionnet
    00001404 6742                   MOV.L       @R4,R7     ; pMotionnet
    00001406 60D3                   MOV         R13,R0
    00001408 E500                   MOV         #0,R5      ; H'00000000
    0000140A 378C                   ADD         R8,R7
    0000140C 017C                   MOV.B       @(R0,R7),R1; pMotionnet->portData[]
    0000140E A009                   BRA         L490
    00001410 641C                   EXTU.B      R1,R4
    00001412              L491:
    00001412 60D3                   MOV         R13,R0
    00001414 027C                   MOV.B       @(R0,R7),R2; pMotionnet->portData[]
    00001416 622C                   EXTU.B      R2,R2
    00001418 3240                   CMP/EQ      R4,R2
    0000141A 8902                   BT          L493
    0000141C E500                   MOV         #0,R5      ; H'00000000
    0000141E 6123                   MOV         R2,R1
    00001420 6423                   MOV         R2,R4
    00001422              L493:
    00001422 7501                   ADD         #1,R5
    00001424              L490:
    00001424 35C3                   CMP/GE      R12,R5
    00001426 8BF4                   BF          L491
               mnet.c       2031              if( DataSet == DataCmp )
    00001428 621C                   EXTU.B      R1,R2
    0000142A 3920                   CMP/EQ      R2,R9
    0000142C 8910                   BT          L471
    0000142E 4E10                   DT          R14
    00001430 8BE5                   BF          L488
    00001432 62F2                   MOV.L       @R15,R2
    00001434 72FF                   ADD         #-1,R2
    00001436 2228                   TST         R2,R2
    00001438 8FD3                   BF/S        L484
    0000143A 2F22                   MOV.L       R2,@R15
    0000143C              L474:
    0000143C A009                   BRA         L497
    0000143E E000                   MOV         #0,R0      ; H'00000000
    00001440              L627:
    00001440 <00000000>             .DATA.L     _MNET_DRV_TYPE
    00001444 <00000000>             .DATA.L     __$pcd_rsts
    00001448 <00000000>             .DATA.L     _ENCODER_EXIST
    0000144C <00000000>             .DATA.L     _pMotionnet
    00001450              L471:
    00001450 E001                   MOV         #1,R0      ; H'00000001
    00001452              L497:
    00001452 7F04                   ADD         #4,R15
    00001454 48F4                   MOVMU.L     @R15+,R8
               mnet.c       2032              {
               mnet.c       2033                  return TRUE;
               mnet.c       2034              }
               mnet.c       2035              else
               mnet.c       2036              {
               mnet.c       2037              }
               mnet.c       2038          }
               mnet.c       2039      }
               mnet.c       2040      
               mnet.c       2041      
               mnet.c       2042      return FALSE;
               mnet.c       2043    }
    00001456 006B                   RTS/N
               mnet.c       2044    ///<summary>
               mnet.c       2045    /// 全てのレジスタに値を書き込む関数
               mnet.c       2046    ///</summary>
               mnet.c       2047    ER motor_SetAllRegister(UB pm)
    00001458              __$motor_SetAllRegister:         ; function: __$motor_SetAllRegister
                                                           ; frame size=52
    00001458 4CF0                   MOVMU.L     R12,@-R15
    0000145A 7FDC                   ADD         #-36,R15
               mnet.c       2048    {
               mnet.c       2049      RMD     rmd;
               mnet.c       2050    
               mnet.c       2051      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    0000145C 6D4C                   EXTU.B      R4,R13
    0000145E D27F                   MOV.L       L628,R2    ; _MNET_DRV_TYPE
    00001460 60D3                   MOV         R13,R0
    00001462 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    00001464 880A                   CMP/EQ      #10,R0
    00001466 8B01                   BF          L643
    00001468 A0CE                   BRA         L500
    0000146A 0009                   NOP
    0000146C              L643:
               mnet.c       2052      {
               mnet.c       2053          return( E_SUCCESS );
               mnet.c       2054      }
               mnet.c       2055    
               mnet.c       2056      // デバイス:PCD4611
               mnet.c       2057      if( MNET_DRV_TYPE[pm] == PCD4611 )
    0000146C 8809                   CMP/EQ      #9,R0
    0000146E 8B4E                   BF          L502
               mnet.c       2058      {
               mnet.c       2059          pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
               mnet.c       2060    
               mnet.c       2061    //        WriteMemoryPCD4611( CMD_CUN1R );        // CUN1R : 
               mnet.c       2062    //        if( !SetMotorRegisterInt(pm, WRG_RFA, 1                  ) )    return(( E_MNT_ACCESS + WRG_RFA ));// 9Bh
               mnet.c       2063          SetMotorRegisterInt( pm, WRG_PRFL, _pmInfo[pm].reg[R1] );   // RFL
    00001470 E064                   MOV         #100,R0    ; H'00000064
    00001472 D17B                   MOV.L       L628+4,R1  ; H'0C009000
    00001474 6ED3                   MOV         R13,R14
    00001476 E581                   MOV         #-127,R5   ; H'FFFFFF81
    00001478 4E80                   MULR        R0,R14
    0000147A DC7A                   MOV.L       L628+8,R12 ; _pPulseMotor
    0000147C 2C12                   MOV.L       R1,@R12    ; pPulseMotor
    0000147E 655C                   EXTU.B      R5,R5
    00001480 DC79                   MOV.L       L628+12,R12; __$_pmInfo
    00001482 67C3                   MOV         R12,R7
    00001484 7728                   ADD         #40,R7
    00001486 60E3                   MOV         R14,R0
    00001488 067E                   MOV.L       @(R0,R7),R6; _pmInfo[].reg[]
    0000148A 6053                   MOV         R5,R0
    0000148C 81F2                   MOV.W       R0,@(4,R15)
    0000148E BD96                   BSR         _SetMotorRegisterInt
    00001490 64D3                   MOV         R13,R4
               mnet.c       2064          SetMotorRegisterInt( pm, WRG_PRFH, _pmInfo[pm].reg[R2] );   // RFH
    00001492 61C3                   MOV         R12,R1
    00001494 712C                   ADD         #44,R1
    00001496 60E3                   MOV         R14,R0
    00001498 061E                   MOV.L       @(R0,R1),R6; _pmInfo[].reg[]
    0000149A 85F2                   MOV.W       @(4,R15),R0
    0000149C 64D3                   MOV         R13,R4
    0000149E 7001                   ADD         #1,R0
    000014A0 81F4                   MOV.W       R0,@(8,R15)
    000014A2 BD8C                   BSR         _SetMotorRegisterInt
    000014A4 6503                   MOV         R0,R5
               mnet.c       2065          SetMotorRegisterInt( pm, WRG_PRUR, _pmInfo[pm].reg[R3] );   // RUR
    000014A6 67C3                   MOV         R12,R7
    000014A8 7730                   ADD         #48,R7
    000014AA 60E3                   MOV         R14,R0
    000014AC 067E                   MOV.L       @(R0,R7),R6; _pmInfo[].reg[]
    000014AE 85F4                   MOV.W       @(8,R15),R0
    000014B0 64D3                   MOV         R13,R4
    000014B2 7001                   ADD         #1,R0
    000014B4 81F6                   MOV.W       R0,@(12,R15)
    000014B6 BD82                   BSR         _SetMotorRegisterInt
    000014B8 6503                   MOV         R0,R5
               mnet.c       2066          SetMotorRegisterInt( pm, WRG_PRDR, 0                   );   // RDR
    000014BA 85F6                   MOV.W       @(12,R15),R0
    000014BC E600                   MOV         #0,R6      ; H'00000000
    000014BE 64D3                   MOV         R13,R4
    000014C0 7001                   ADD         #1,R0
    000014C2 81F8                   MOV.W       R0,@(16,R15)
    000014C4 BD7B                   BSR         _SetMotorRegisterInt
    000014C6 6503                   MOV         R0,R5
               mnet.c       2067          SetMotorRegisterInt( pm, WRG_PRMG, _pmInfo[pm].reg[R4] );   // RMG
    000014C8 62C3                   MOV         R12,R2
    000014CA 7234                   ADD         #52,R2
    000014CC 60E3                   MOV         R14,R0
    000014CE 062E                   MOV.L       @(R0,R2),R6; _pmInfo[].reg[]
    000014D0 85F8                   MOV.W       @(16,R15),R0
    000014D2 64D3                   MOV         R13,R4
               mnet.c       2068          SetMotorRegisterInt( pm, WRG_PRDP, 0                   );   // RDP
               mnet.c       2069          SetMotorRegisterInt( pm, WRG_PRDS, _pmInfo[pm].reg[R9] );   // RDS
    000014D4 7C48                   ADD         #72,R12
    000014D6 7001                   ADD         #1,R0
    000014D8 81FA                   MOV.W       R0,@(20,R15)
    000014DA BD70                   BSR         _SetMotorRegisterInt
    000014DC 6503                   MOV         R0,R5
    000014DE 85FA                   MOV.W       @(20,R15),R0
    000014E0 E600                   MOV         #0,R6      ; H'00000000
    000014E2 64D3                   MOV         R13,R4
    000014E4 7001                   ADD         #1,R0
    000014E6 81FC                   MOV.W       R0,@(24,R15)
    000014E8 BD69                   BSR         _SetMotorRegisterInt
    000014EA 6503                   MOV         R0,R5
    000014EC 60E3                   MOV         R14,R0
    000014EE 06CE                   MOV.L       @(R0,R12),R6; _pmInfo[].reg[]
    000014F0 85FC                   MOV.W       @(24,R15),R0
    000014F2 64D3                   MOV         R13,R4
    000014F4 7004                   ADD         #4,R0
    000014F6 81FE                   MOV.W       R0,@(28,R15)
    000014F8 BD61                   BSR         _SetMotorRegisterInt
    000014FA 6503                   MOV         R0,R5
               mnet.c       2070          SetMotorRegisterInt( pm, WRG_PRMG, 1199                );   // RMG
    000014FC 85FE                   MOV.W       @(28,R15),R0
    000014FE 64D3                   MOV         R13,R4
    00001500 060004AF               MOVI20      #1199,R6   ; H'000004AF
    00001504 70FB                   ADD         #-5,R0
    00001506 BD5A                   BSR         _SetMotorRegisterInt
    00001508 6503                   MOV         R0,R5
    0000150A A07D                   BRA         L500
    0000150C 0009                   NOP
    0000150E              L502:
    0000150E E5D7                   MOV         #-41,R5    ; H'FFFFFFD7
               mnet.c       2071    
               mnet.c       2072      }
               mnet.c       2073      // デバイス:FU,FU-A
               mnet.c       2074      else
               mnet.c       2075      {
               mnet.c       2076          if( !GetMotorRegister(pm, RRG_RMD, &rmd.UNID.data))             return(( E_MNT_ACCESS + RRG_RMD ));
    00001510 66F3                   MOV         R15,R6
    00001512 655C                   EXTU.B      R5,R5
    00001514 BDA8                   BSR         _GetMotorRegister
    00001516 64D3                   MOV         R13,R4
    00001518 2008                   TST         R0,R0
    0000151A 000005D7               MOVI20      #1495,R0   ; H'000005D7
    0000151E 8974                   BT          L504
               mnet.c       2077    
               mnet.c       2078          rmd.UNID.BIT.MSMD = (_pmInfo[pm].param.accel_type == ACCEL_STYPE ? 1 : 0);
    00001520 E064                   MOV         #100,R0    ; H'00000064
    00001522 6ED3                   MOV         R13,R14
    00001524 4E80                   MULR        R0,R14
    00001526 D151                   MOV.L       L628+16,R1 ; H'00000008+__$_pmInfo
               mnet.c       2079          rmd.UNID.BIT.MINT = 1;
               mnet.c       2080          if( !SetMotorRegisterInt(pm, WRG_RMD, rmd.UNID.data) )          return(( E_MNT_ACCESS + WRG_RMD ));// 97h
    00001528 E597                   MOV         #-105,R5   ; H'FFFFFF97
    0000152A 64D3                   MOV         R13,R4
    0000152C 655C                   EXTU.B      R5,R5
    0000152E 60E3                   MOV         R14,R0
    00001530 001D                   MOV.W       @(R0,R1),R0; _pmInfo[].accel_type
    00001532 1FE8                   MOV.L       R14,@(32,R15)
    00001534 8801                   CMP/EQ      #1,R0
    00001536 3F292002               BST.B       #2,@(2,R15); (part of)rmd
    0000153A 3F391001               BSET.B      #3,@(1,R15); (part of)rmd
    0000153E BD3E                   BSR         _SetMotorRegisterInt
    00001540 66F2                   MOV.L       @R15,R6    ; rmd.UNID.data
    00001542 2008                   TST         R0,R0
    00001544 00000597               MOVI20      #1431,R0   ; H'00000597
    00001548 895F                   BT          L504
               mnet.c       2081          if( !SetMotorRegisterInt(pm, WRG_RFL, _pmInfo[pm].reg[R1]) )    return(( E_MNT_ACCESS + WRG_RFL ));// 91h
    0000154A 50F8                   MOV.L       @(32,R15),R0
    0000154C E591                   MOV         #-111,R5   ; H'FFFFFF91
    0000154E D148                   MOV.L       L628+20,R1 ; H'00000028+__$_pmInfo
    00001550 061E                   MOV.L       @(R0,R1),R6; _pmInfo[].reg[]
    00001552 655C                   EXTU.B      R5,R5
    00001554 BD33                   BSR         _SetMotorRegisterInt
    00001556 64D3                   MOV         R13,R4
    00001558 2008                   TST         R0,R0
    0000155A 00000591               MOVI20      #1425,R0   ; H'00000591
    0000155E 8954                   BT          L504
               mnet.c       2082          if( !SetMotorRegisterInt(pm, WRG_RFH, _pmInfo[pm].reg[R2]) )    return(( E_MNT_ACCESS + WRG_RFH ));// 92h
    00001560 50F8                   MOV.L       @(32,R15),R0
    00001562 E592                   MOV         #-110,R5   ; H'FFFFFF92
    00001564 D143                   MOV.L       L628+24,R1 ; H'0000002C+__$_pmInfo
    00001566 061E                   MOV.L       @(R0,R1),R6; _pmInfo[].reg[]
    00001568 655C                   EXTU.B      R5,R5
    0000156A BD28                   BSR         _SetMotorRegisterInt
    0000156C 64D3                   MOV         R13,R4
    0000156E 2008                   TST         R0,R0
    00001570 00000592               MOVI20      #1426,R0   ; H'00000592
    00001574 8949                   BT          L504
               mnet.c       2083          if( !SetMotorRegister(pm,   WRG_RUR, _pmInfo[pm].reg[R3]) )     return(( E_MNT_ACCESS + WRG_RUR ));// 93h
    00001576 50F8                   MOV.L       @(32,R15),R0
    00001578 E593                   MOV         #-109,R5   ; H'FFFFFF93
    0000157A D13F                   MOV.L       L628+28,R1 ; H'00000030+__$_pmInfo
    0000157C 061E                   MOV.L       @(R0,R1),R6; _pmInfo[].reg[]
    0000157E 655C                   EXTU.B      R5,R5
    00001580 BD4A                   BSR         __$SetMotorRegister
    00001582 64D3                   MOV         R13,R4
    00001584 2008                   TST         R0,R0
    00001586 00000593               MOVI20      #1427,R0   ; H'00000593
    0000158A 893E                   BT          L504
               mnet.c       2084          if( !SetMotorRegister(pm,   WRG_RDR, 0) )                       return(( E_MNT_ACCESS + WRG_RDR ));// 94h
    0000158C E594                   MOV         #-108,R5   ; H'FFFFFF94
    0000158E E600                   MOV         #0,R6      ; H'00000000
    00001590 655C                   EXTU.B      R5,R5
    00001592 BD41                   BSR         __$SetMotorRegister
    00001594 64D3                   MOV         R13,R4
    00001596 2008                   TST         R0,R0
    00001598 00000594               MOVI20      #1428,R0   ; H'00000594
    0000159C 8935                   BT          L504
               mnet.c       2085          if( !SetMotorRegisterInt(pm, WRG_RMG, _pmInfo[pm].reg[R4]) )    return(( E_MNT_ACCESS + WRG_RMG ));// 95h
    0000159E 50F8                   MOV.L       @(32,R15),R0
    000015A0 E595                   MOV         #-107,R5   ; H'FFFFFF95
    000015A2 D136                   MOV.L       L628+32,R1 ; H'00000034+__$_pmInfo
    000015A4 061E                   MOV.L       @(R0,R1),R6; _pmInfo[].reg[]
    000015A6 655C                   EXTU.B      R5,R5
    000015A8 BD09                   BSR         _SetMotorRegisterInt
    000015AA 64D3                   MOV         R13,R4
    000015AC 2008                   TST         R0,R0
    000015AE 00000595               MOVI20      #1429,R0   ; H'00000595
    000015B2 892A                   BT          L504
    000015B4 E596                   MOV         #-106,R5   ; H'FFFFFF96
               mnet.c       2086          if( !SetMotorRegisterInt(pm, WRG_RDP, 0) )                      return(( E_MNT_ACCESS + WRG_RDP ));// 96h
    000015B6 E600                   MOV         #0,R6      ; H'00000000
    000015B8 655C                   EXTU.B      R5,R5
    000015BA BD00                   BSR         _SetMotorRegisterInt
    000015BC 64D3                   MOV         R13,R4
    000015BE 2008                   TST         R0,R0
    000015C0 00000596               MOVI20      #1430,R0   ; H'00000596
    000015C4 8921                   BT          L504
    000015C6 E59B                   MOV         #-101,R5   ; H'FFFFFF9B
               mnet.c       2087          if( !SetMotorRegisterInt(pm, WRG_RFA, 1) )                      return(( E_MNT_ACCESS + WRG_RFA ));// 9Bh
    000015C8 E601                   MOV         #1,R6      ; H'00000001
    000015CA 655C                   EXTU.B      R5,R5
    000015CC BCF7                   BSR         _SetMotorRegisterInt
    000015CE 64D3                   MOV         R13,R4
    000015D0 2008                   TST         R0,R0
    000015D2 0000059B               MOVI20      #1435,R0   ; H'0000059B
    000015D6 8918                   BT          L504
               mnet.c       2088          if( !SetMotorRegisterInt(pm, WRG_RUS, _pmInfo[pm].reg[R8]) )    return(( E_MNT_ACCESS + WRG_RUS ));// 99h
    000015D8 50F8                   MOV.L       @(32,R15),R0
    000015DA E599                   MOV         #-103,R5   ; H'FFFFFF99
    000015DC D128                   MOV.L       L628+36,R1 ; H'00000044+__$_pmInfo
    000015DE 061E                   MOV.L       @(R0,R1),R6; _pmInfo[].reg[]
    000015E0 655C                   EXTU.B      R5,R5
    000015E2 BCEC                   BSR         _SetMotorRegisterInt
    000015E4 64D3                   MOV         R13,R4
    000015E6 2008                   TST         R0,R0
    000015E8 00000599               MOVI20      #1433,R0   ; H'00000599
    000015EC 890D                   BT          L504
               mnet.c       2089          if( !SetMotorRegisterInt(pm, WRG_RDS, _pmInfo[pm].reg[R9]) )    return(( E_MNT_ACCESS + WRG_RDS ));// 9Ah
    000015EE 50F8                   MOV.L       @(32,R15),R0
    000015F0 E59A                   MOV         #-102,R5   ; H'FFFFFF9A
    000015F2 D124                   MOV.L       L628+40,R1 ; H'00000048+__$_pmInfo
    000015F4 061E                   MOV.L       @(R0,R1),R6; _pmInfo[].reg[]
    000015F6 655C                   EXTU.B      R5,R5
    000015F8 BCE1                   BSR         _SetMotorRegisterInt
    000015FA 64D3                   MOV         R13,R4
    000015FC 2008                   TST         R0,R0
    000015FE 8B03                   BF          L500
    00001600 0000059A               MOVI20      #1434,R0   ; H'0000059A
    00001604 A001                   BRA         L504
    00001606 0009                   NOP
    00001608              L500:
    00001608 E000                   MOV         #0,R0      ; H'00000000
    0000160A              L504:
    0000160A 7F24                   ADD         #36,R15
    0000160C 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       2090      }
               mnet.c       2091    
               mnet.c       2092      return( E_SUCCESS );
               mnet.c       2093    }
    0000160E 006B                   RTS/N
               mnet.c       2094    ///<summary>
               mnet.c       2095    /// モータ動作パラメータから各レジスタの値を計算する関数
               mnet.c       2096    ///</summary>
               mnet.c       2097    static ER motor_CalcMotorReg(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg)
    00001610              __$motor_CalcMotorReg:           ; function: __$motor_CalcMotorReg
                                                           ; frame size=28
    00001610 2FE6                   MOV.L       R14,@-R15
    00001612 4F12                   STS.L       MACL,@-R15
    00001614 4F02                   STS.L       MACH,@-R15
    00001616 7FF0                   ADD         #-16,R15
    00001618 32419002               MOVU.W      @(4,R4),R2 ; (mp)->accel_type
    0000161C E601                   MOV         #1,R6      ; H'00000001
               mnet.c       2098    {
               mnet.c       2099      if( mp->accel_type > 1 )        return(( E_PAR_OUTRNG + PARAM1 ));
    0000161E 3267                   CMP/GT      R6,R2
    00001620 8F04                   BF/S        L517
    00001622 6153                   MOV         R5,R1
    00001624 00000801               MOVI20      #2049,R0   ; H'00000801
    00001628 A09A                   BRA         L518
    0000162A 0009                   NOP
    0000162C              L517:
               mnet.c       2100      if( mp->FH == 0 )               return(( E_PAR_OUTRNG + PARAM2 ));
    0000162C 5543                   MOV.L       @(12,R4),R5; (mp)->FH
    0000162E 2558                   TST         R5,R5
    00001630 8B03                   BF          L520
    00001632 00000802               MOVI20      #2050,R0   ; H'00000802
    00001636 A093                   BRA         L518
    00001638 0009                   NOP
    0000163A              L520:
               mnet.c       2101      if( mp->FL == 0 )               return(( E_PAR_OUTRNG + PARAM3 ));
    0000163A 5642                   MOV.L       @(8,R4),R6 ; (mp)->FL
    0000163C 2668                   TST         R6,R6
    0000163E 8B01                   BF          L644
    00001640 A08C                   BRA         L522
    00001642 0009                   NOP
    00001644              L644:
               mnet.c       2102      if( mp->FH <= mp->FL )          return(( E_PAR_OUTRNG + PARAM3 ));
    00001644 3567                   CMP/GT      R6,R5
    00001646 8901                   BT          L645
    00001648 A088                   BRA         L522
    0000164A 0009                   NOP
    0000164C              L645:
               mnet.c       2103      if( mp->utime <= 0)             return(( E_PAR_OUTRNG + PARAM4 ));
    0000164C 5744                   MOV.L       @(16,R4),R7; (mp)->utime
    0000164E 4715                   CMP/PL      R7
    00001650 8D1A                   BT/S        L525
    00001652 2F72                   MOV.L       R7,@R15
    00001654 00000804               MOVI20      #2052,R0   ; H'00000804
    00001658 A082                   BRA         L518
    0000165A 0009                   NOP
    0000165C              L628:
    0000165C <00000000>             .DATA.L     _MNET_DRV_TYPE
    00001660 0C009000               .DATA.L     H'0C009000
    00001664 <00000000>             .DATA.L     _pPulseMotor
    00001668 <00000000>             .DATA.L     __$_pmInfo
    0000166C <00000008>             .DATA.L     H'00000008+__$_pmInfo
    00001670 <00000028>             .DATA.L     H'00000028+__$_pmInfo
    00001674 <0000002C>             .DATA.L     H'0000002C+__$_pmInfo
    00001678 <00000030>             .DATA.L     H'00000030+__$_pmInfo
    0000167C <00000034>             .DATA.L     H'00000034+__$_pmInfo
    00001680 <00000044>             .DATA.L     H'00000044+__$_pmInfo
    00001684 <00000048>             .DATA.L     H'00000048+__$_pmInfo
    00001688              L525:
               mnet.c       2104    
               mnet.c       2105      factor  = mp->factor;
    00001688 6742                   MOV.L       @R4,R7     ; (mp)->factor
               mnet.c       2106      param   = (mp->accel_type == ACCEL_LINEAR ? 5000 : 2500);
    0000168A 2228                   TST         R2,R2
    0000168C DEAF                   MOV.L       L629,R14   ; __$factor
    0000168E 2E72                   MOV.L       R7,@R14    ; factor
    00001690 0E0009C4               MOVI20      #2500,R14  ; H'000009C4
    00001694 8B01                   BF          L527
    00001696 0E001388               MOVI20      #5000,R14  ; H'00001388
    0000169A              L527:
    0000169A 1FE1                   MOV.L       R14,@(4,R15)
    0000169C 62E3                   MOV         R14,R2
    0000169E DEAC                   MOV.L       L629+4,R14 ; __$param
    000016A0 2E22                   MOV.L       R2,@R14    ; param
               mnet.c       2107      RMG     = factor;
    000016A2 DEAC                   MOV.L       L629+8,R14 ; __$RMG
    000016A4 2E72                   MOV.L       R7,@R14    ; RMG
               mnet.c       2108      RFL     = (mp->FL * (RMG + 1)) / 200;
    000016A6 7701                   ADD         #1,R7
    000016A8 6073                   MOV         R7,R0
    000016AA D2AB                   MOV.L       L629+12,R2 ; H'51EB851F
    000016AC 4680                   MULR        R0,R6
    000016AE 1F22                   MOV.L       R2,@(8,R15)
    000016B0 326D                   DMULS.L     R6,R2
    000016B2 EEFA                   MOV         #-6,R14    ; H'FFFFFFFA
    000016B4 020A                   STS         MACH,R2
    000016B6 42EC                   SHAD        R14,R2
    000016B8 6023                   MOV         R2,R0
    000016BA 4004                   ROTL        R0
    000016BC C901                   AND         #1,R0
    000016BE 320C                   ADD         R0,R2
               mnet.c       2109      RFH     = (mp->FH * (RMG + 1)) / 200;
    000016C0 6073                   MOV         R7,R0
    000016C2 4580                   MULR        R0,R5
    000016C4 1F23                   MOV.L       R2,@(12,R15)
    000016C6 6E23                   MOV         R2,R14
    000016C8 D2A4                   MOV.L       L629+16,R2 ; __$RFL
    000016CA 22E2                   MOV.L       R14,@R2    ; RFL
    000016CC 52F2                   MOV.L       @(8,R15),R2
    000016CE 325D                   DMULS.L     R5,R2
    000016D0 E5FA                   MOV         #-6,R5     ; H'FFFFFFFA
               mnet.c       2110      RUR     = ((mp->utime * param) / (RFH - RFL)) - 1;
    000016D2 62F2                   MOV.L       @R15,R2
    000016D4 060A                   STS         MACH,R6
    000016D6 465C                   SHAD        R5,R6
    000016D8 6063                   MOV         R6,R0
    000016DA 4004                   ROTL        R0
    000016DC C901                   AND         #1,R0
    000016DE 360C                   ADD         R0,R6
    000016E0 50F1                   MOV.L       @(4,R15),R0
    000016E2 D59F                   MOV.L       L629+20,R5 ; __$RFH
    000016E4 4280                   MULR        R0,R2
    000016E6 2562                   MOV.L       R6,@R5     ; RFH
    000016E8 55F3                   MOV.L       @(12,R15),R5
    000016EA 3658                   SUB         R5,R6
    000016EC 55F2                   MOV.L       @(8,R15),R5
    000016EE 6063                   MOV         R6,R0
    000016F0 4294                   DIVS        R0,R2
    000016F2 D69C                   MOV.L       L629+24,R6 ; __$RUR
    000016F4 6073                   MOV         R7,R0
    000016F6 72FF                   ADD         #-1,R2
    000016F8 2622                   MOV.L       R2,@R6     ; RUR
    000016FA D29B                   MOV.L       L629+28,R2 ; __$RUS
               mnet.c       2111      RUS     = (mp->us * (RMG + 1)) / 200;
    000016FC 5E46                   MOV.L       @(24,R4),R14; (mp)->us
    000016FE 4E80                   MULR        R0,R14
    00001700 35ED                   DMULS.L     R14,R5
    00001702 E5FA                   MOV         #-6,R5     ; H'FFFFFFFA
    00001704 060A                   STS         MACH,R6
    00001706 465C                   SHAD        R5,R6
    00001708 6063                   MOV         R6,R0
    0000170A 4004                   ROTL        R0
    0000170C C901                   AND         #1,R0
    0000170E 360C                   ADD         R0,R6
    00001710 6073                   MOV         R7,R0
    00001712 2262                   MOV.L       R6,@R2     ; RUS
    00001714 57F2                   MOV.L       @(8,R15),R7
               mnet.c       2112      RDS     = (mp->ds * (RMG + 1)) / 200;
    00001716 5547                   MOV.L       @(28,R4),R5; (mp)->ds
               mnet.c       2113      
               mnet.c       2114      pm_reg->reg[R1] = RFL;
               mnet.c       2115      pm_reg->reg[R2] = RFH;
               mnet.c       2116      pm_reg->reg[R3] = RUR;
    00001718 D692                   MOV.L       L629+24,R6 ; __$RUR
    0000171A 4580                   MULR        R0,R5
    0000171C 375D                   DMULS.L     R5,R7
    0000171E E7FA                   MOV         #-6,R7     ; H'FFFFFFFA
    00001720 D592                   MOV.L       L629+32,R5 ; __$RDS
    00001722 040A                   STS         MACH,R4
    00001724 447C                   SHAD        R7,R4
    00001726 6043                   MOV         R4,R0
    00001728 4004                   ROTL        R0
    0000172A C901                   AND         #1,R0
    0000172C 340C                   ADD         R0,R4
               mnet.c       2117      pm_reg->reg[R4] = RMG;
               mnet.c       2118      pm_reg->reg[R5] = 0;
               mnet.c       2119      pm_reg->reg[R6] = 2;
               mnet.c       2120      pm_reg->reg[R7] = 0;
               mnet.c       2121      pm_reg->reg[R8] = RUS;
               mnet.c       2122      pm_reg->reg[R9] = RDS;
               mnet.c       2123    
               mnet.c       2124      return ( E_SUCCESS );
    0000172E E000                   MOV         #0,R0      ; H'00000000
    00001730 2542                   MOV.L       R4,@R5     ; RDS
    00001732 54F3                   MOV.L       @(12,R15),R4
    00001734 1141                   MOV.L       R4,@(4,R1) ; pm_reg->reg[]
    00001736 D48A                   MOV.L       L629+20,R4 ; __$RFH
    00001738 6742                   MOV.L       @R4,R7     ; RFH
    0000173A 1172                   MOV.L       R7,@(8,R1) ; pm_reg->reg[]
    0000173C 6462                   MOV.L       @R6,R4     ; RUR
    0000173E D685                   MOV.L       L629+8,R6  ; __$RMG
    00001740 1143                   MOV.L       R4,@(12,R1); pm_reg->reg[]
    00001742 E400                   MOV         #0,R4      ; H'00000000
    00001744 6762                   MOV.L       @R6,R7     ; RMG
    00001746 E602                   MOV         #2,R6      ; H'00000002
    00001748 1174                   MOV.L       R7,@(16,R1); pm_reg->reg[]
    0000174A 1145                   MOV.L       R4,@(20,R1); pm_reg->reg[]
    0000174C 1166                   MOV.L       R6,@(24,R1); pm_reg->reg[]
    0000174E 1147                   MOV.L       R4,@(28,R1); pm_reg->reg[]
    00001750 D785                   MOV.L       L629+28,R7 ; __$RUS
    00001752 6272                   MOV.L       @R7,R2     ; RUS
    00001754 1128                   MOV.L       R2,@(32,R1); pm_reg->reg[]
    00001756 6252                   MOV.L       @R5,R2     ; RDS
    00001758 A002                   BRA         L518
    0000175A 1129                   MOV.L       R2,@(36,R1); pm_reg->reg[]
    0000175C              L522:
    0000175C 00000803               MOVI20      #2051,R0   ; H'00000803
    00001760              L518:
    00001760 7F10                   ADD         #16,R15
    00001762 4F06                   LDS.L       @R15+,MACH
    00001764 4F16                   LDS.L       @R15+,MACL
               mnet.c       2125    }
    00001766 000B                   RTS
    00001768 6EF6                   MOV.L       @R15+,R14
               mnet.c       2126    ///<summary>
               mnet.c       2127    /// モータ動作パラメータから各レジスタの値を計算する関数
               mnet.c       2128    ///</summary>
               mnet.c       2129    static ER motor_CalcMotorRegPCD4611(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg)
    0000176A              __$motor_CalcMotorRegPCD4611:    ; function: __$motor_CalcMotorRegPCD4611
                                                           ; frame size=24
    0000176A 4F12                   STS.L       MACL,@-R15
    0000176C 4F02                   STS.L       MACH,@-R15
    0000176E 7FF0                   ADD         #-16,R15
    00001770 32419002               MOVU.W      @(4,R4),R2 ; (mp)->accel_type
    00001774 E601                   MOV         #1,R6      ; H'00000001
               mnet.c       2130    {
               mnet.c       2131      if( mp->accel_type > 1 )        return(( E_PAR_OUTRNG + PARAM1 ));
    00001776 3267                   CMP/GT      R6,R2
    00001778 8F04                   BF/S        L530
    0000177A 6153                   MOV         R5,R1
    0000177C 00000801               MOVI20      #2049,R0   ; H'00000801
    00001780 A083                   BRA         L531
    00001782 0009                   NOP
    00001784              L530:
               mnet.c       2132      if( mp->FH == 0 )               return(( E_PAR_OUTRNG + PARAM2 ));
    00001784 5543                   MOV.L       @(12,R4),R5; (mp)->FH
    00001786 2558                   TST         R5,R5
    00001788 8B03                   BF          L533
    0000178A 00000802               MOVI20      #2050,R0   ; H'00000802
    0000178E A07C                   BRA         L531
    00001790 0009                   NOP
    00001792              L533:
               mnet.c       2133      if( mp->FL == 0 )               return(( E_PAR_OUTRNG + PARAM3 ));
    00001792 5642                   MOV.L       @(8,R4),R6 ; (mp)->FL
    00001794 2668                   TST         R6,R6
    00001796 8976                   BT          L535
               mnet.c       2134      if( mp->FH <= mp->FL )          return(( E_PAR_OUTRNG + PARAM3 ));
    00001798 3567                   CMP/GT      R6,R5
    0000179A 8B74                   BF          L535
               mnet.c       2135      if( mp->utime <= 0)             return(( E_PAR_OUTRNG + PARAM4 ));
    0000179C 5744                   MOV.L       @(16,R4),R7; (mp)->utime
    0000179E 4715                   CMP/PL      R7
    000017A0 8D04                   BT/S        L538
    000017A2 2F72                   MOV.L       R7,@R15
    000017A4 00000804               MOVI20      #2052,R0   ; H'00000804
    000017A8 A06F                   BRA         L531
    000017AA 0009                   NOP
    000017AC              L538:
               mnet.c       2136    
               mnet.c       2137      factor  = MOTORSPD_TBL_PCD4611[2];
    000017AC D770                   MOV.L       L629+36,R7 ; H'00000008+__$MOTORSPD_TBL_PCD4611
    000017AE 6372                   MOV.L       @R7,R3     ; MOTORSPD_TBL_PCD4611[]
               mnet.c       2138      param   = (mp->accel_type == ACCEL_LINEAR ? 5000 : 2500);
    000017B0 2228                   TST         R2,R2
    000017B2 D766                   MOV.L       L629,R7    ; __$factor
    000017B4 2732                   MOV.L       R3,@R7     ; factor
    000017B6 070009C4               MOVI20      #2500,R7   ; H'000009C4
    000017BA 8B01                   BF          L540
    000017BC 07001388               MOVI20      #5000,R7   ; H'00001388
    000017C0              L540:
    000017C0 1F71                   MOV.L       R7,@(4,R15)
    000017C2 6373                   MOV         R7,R3
    000017C4 D762                   MOV.L       L629+4,R7  ; __$param
    000017C6 2732                   MOV.L       R3,@R7     ; param
               mnet.c       2139      RMG     = factor;
    000017C8 D760                   MOV.L       L629,R7    ; __$factor
    000017CA 6072                   MOV.L       @R7,R0     ; factor
    000017CC D761                   MOV.L       L629+8,R7  ; __$RMG
    000017CE 2702                   MOV.L       R0,@R7     ; RMG
               mnet.c       2140      RFL     = (mp->FL * (RMG + 1)) / 2441;                      // 40,000,000/ 16384 = 2441
    000017D0 7001                   ADD         #1,R0
    000017D2 4680                   MULR        R0,R6
    000017D4 D267                   MOV.L       L629+40,R2 ; H'6B645D8D
    000017D6 6703                   MOV         R0,R7
    000017D8 1F22                   MOV.L       R2,@(8,R15)
    000017DA 326D                   DMULS.L     R6,R2
    000017DC E3F6                   MOV         #-10,R3    ; H'FFFFFFF6
    000017DE 020A                   STS         MACH,R2
    000017E0 423C                   SHAD        R3,R2
    000017E2 6023                   MOV         R2,R0
    000017E4 4004                   ROTL        R0
    000017E6 C901                   AND         #1,R0
    000017E8 320C                   ADD         R0,R2
               mnet.c       2141      RFH     = (mp->FH * (RMG + 1)) / 2441;                      // 40,000,000/ 16384
    000017EA 6073                   MOV         R7,R0
    000017EC 4580                   MULR        R0,R5
    000017EE 1F23                   MOV.L       R2,@(12,R15)
    000017F0 6323                   MOV         R2,R3
    000017F2 D25A                   MOV.L       L629+16,R2 ; __$RFL
    000017F4 2232                   MOV.L       R3,@R2     ; RFL
    000017F6 52F2                   MOV.L       @(8,R15),R2
    000017F8 325D                   DMULS.L     R5,R2
    000017FA E5F6                   MOV         #-10,R5    ; H'FFFFFFF6
    000017FC D258                   MOV.L       L629+20,R2 ; __$RFH
    000017FE 060A                   STS         MACH,R6
    00001800 465C                   SHAD        R5,R6
    00001802 55F3                   MOV.L       @(12,R15),R5
    00001804 6063                   MOV         R6,R0
    00001806 4004                   ROTL        R0
    00001808 C901                   AND         #1,R0
    0000180A 360C                   ADD         R0,R6
               mnet.c       2142      RUR     = ((mp->utime * param) / (RFH - RFL)) - 1;
    0000180C 50F1                   MOV.L       @(4,R15),R0
    0000180E 2262                   MOV.L       R6,@R2     ; RFH
    00001810 3658                   SUB         R5,R6
    00001812 62F2                   MOV.L       @R15,R2
    00001814 D553                   MOV.L       L629+24,R5 ; __$RUR
    00001816 4280                   MULR        R0,R2
    00001818 6063                   MOV         R6,R0
    0000181A 4294                   DIVS        R0,R2
    0000181C 6073                   MOV         R7,R0
    0000181E 72FF                   ADD         #-1,R2
    00001820 2522                   MOV.L       R2,@R5     ; RUR
               mnet.c       2143      RUS     = (mp->us * (RMG + 1)) / 2441;                      // 40,000,000/ 16384
               mnet.c       2144      RDS     = (mp->ds * (RMG + 1)) / 2441;                      // 40,000,000/ 16384
               mnet.c       2145      
               mnet.c       2146      pm_reg->reg[R1] = RFL;
               mnet.c       2147      pm_reg->reg[R2] = RFH;
               mnet.c       2148      pm_reg->reg[R3] = RUR;
               mnet.c       2149      pm_reg->reg[R4] = RMG;
               mnet.c       2150      pm_reg->reg[R5] = 0;
    00001822 E200                   MOV         #0,R2      ; H'00000000
    00001824 55F2                   MOV.L       @(8,R15),R5
    00001826 5346                   MOV.L       @(24,R4),R3; (mp)->us
    00001828 4380                   MULR        R0,R3
    0000182A 353D                   DMULS.L     R3,R5
    0000182C E5F6                   MOV         #-10,R5    ; H'FFFFFFF6
    0000182E 060A                   STS         MACH,R6
    00001830 465C                   SHAD        R5,R6
    00001832 6063                   MOV         R6,R0
    00001834 4004                   ROTL        R0
    00001836 C901                   AND         #1,R0
    00001838 360C                   ADD         R0,R6
    0000183A 6073                   MOV         R7,R0
    0000183C D54A                   MOV.L       L629+28,R5 ; __$RUS
    0000183E 2562                   MOV.L       R6,@R5     ; RUS
    00001840 57F2                   MOV.L       @(8,R15),R7
    00001842 5547                   MOV.L       @(28,R4),R5; (mp)->ds
    00001844 D646                   MOV.L       L629+20,R6 ; __$RFH
    00001846 4580                   MULR        R0,R5
    00001848 375D                   DMULS.L     R5,R7
    0000184A E7F6                   MOV         #-10,R7    ; H'FFFFFFF6
    0000184C D547                   MOV.L       L629+32,R5 ; __$RDS
    0000184E 040A                   STS         MACH,R4
    00001850 447C                   SHAD        R7,R4
    00001852 6043                   MOV         R4,R0
    00001854 4004                   ROTL        R0
    00001856 C901                   AND         #1,R0
    00001858 340C                   ADD         R0,R4
               mnet.c       2151      pm_reg->reg[R6] = 2;
               mnet.c       2152      pm_reg->reg[R7] = 0;
               mnet.c       2153      pm_reg->reg[R8] = RUS;
               mnet.c       2154      pm_reg->reg[R9] = RDS;
               mnet.c       2155    
               mnet.c       2156      return ( E_SUCCESS );
    0000185A E000                   MOV         #0,R0      ; H'00000000
    0000185C 2542                   MOV.L       R4,@R5     ; RDS
    0000185E 54F3                   MOV.L       @(12,R15),R4
    00001860 1141                   MOV.L       R4,@(4,R1) ; pm_reg->reg[]
    00001862 6762                   MOV.L       @R6,R7     ; RFH
    00001864 D63F                   MOV.L       L629+24,R6 ; __$RUR
    00001866 1172                   MOV.L       R7,@(8,R1) ; pm_reg->reg[]
    00001868 6462                   MOV.L       @R6,R4     ; RUR
    0000186A D63A                   MOV.L       L629+8,R6  ; __$RMG
    0000186C 1143                   MOV.L       R4,@(12,R1); pm_reg->reg[]
    0000186E 6462                   MOV.L       @R6,R4     ; RMG
    00001870 E602                   MOV         #2,R6      ; H'00000002
    00001872 1144                   MOV.L       R4,@(16,R1); pm_reg->reg[]
    00001874 1125                   MOV.L       R2,@(20,R1); pm_reg->reg[]
    00001876 1166                   MOV.L       R6,@(24,R1); pm_reg->reg[]
    00001878 1127                   MOV.L       R2,@(28,R1); pm_reg->reg[]
    0000187A D43B                   MOV.L       L629+28,R4 ; __$RUS
    0000187C 6242                   MOV.L       @R4,R2     ; RUS
    0000187E 1128                   MOV.L       R2,@(32,R1); pm_reg->reg[]
    00001880 6252                   MOV.L       @R5,R2     ; RDS
    00001882 A002                   BRA         L531
    00001884 1129                   MOV.L       R2,@(36,R1); pm_reg->reg[]
    00001886              L535:
    00001886 00000803               MOVI20      #2051,R0   ; H'00000803
    0000188A              L531:
    0000188A 7F10                   ADD         #16,R15
    0000188C 4F06                   LDS.L       @R15+,MACH
               mnet.c       2157    }
    0000188E 000B                   RTS
    00001890 4F16                   LDS.L       @R15+,MACL
               mnet.c       2158    /////<summary>
               mnet.c       2159    /// コマンドをセットする関数
               mnet.c       2160    ///</summary>
               mnet.c       2161    static void motor_RegistCommand(UB pm, UH cmd)
    00001892              __$motor_RegistCommand:          ; function: __$motor_RegistCommand
                                                           ; frame size=0
               mnet.c       2162    {
               mnet.c       2163      _pmInfo[pm].command.code     = cmd;
    00001892 614C                   EXTU.B      R4,R1
    00001894 E064                   MOV         #100,R0    ; H'00000064
    00001896 6613                   MOV         R1,R6
    00001898 4680                   MULR        R0,R6
    0000189A D437                   MOV.L       L629+44,R4 ; __$_pmInfo
    0000189C 6743                   MOV         R4,R7
    0000189E 775C                   ADD         #92,R7
               mnet.c       2164      _pmInfo[pm].command.status   = PSTAT_READY;
    000018A0 6243                   MOV         R4,R2
    000018A2 725E                   ADD         #94,R2
    000018A4 6063                   MOV         R6,R0
    000018A6 0755                   MOV.W       R5,@(R0,R7); _pmInfo[].code
    000018A8 E702                   MOV         #2,R7      ; H'00000002
    000018AA 0275                   MOV.W       R7,@(R0,R2); _pmInfo[].status
    000018AC 6013                   MOV         R1,R0
               mnet.c       2165    
               mnet.c       2166      if( MNET_DRV_TYPE[pm] == PCD4611 )
    000018AE D233                   MOV.L       L629+48,R2 ; _MNET_DRV_TYPE
    000018B0 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    000018B2 8809                   CMP/EQ      #9,R0
    000018B4 8904                   BT          L542
               mnet.c       2167      {
               mnet.c       2168          // PCD4611は、処理不要。前段階で実行済み
               mnet.c       2169      }
               mnet.c       2170      else
               mnet.c       2171      {
               mnet.c       2172          SetMotorCommand(pm, _pmInfo[pm].startParam);
    000018B6 7460                   ADD         #96,R4
    000018B8 6063                   MOV         R6,R0
    000018BA 054D                   MOV.W       @(R0,R4),R5; _pmInfo[].startParam
    000018BC AB61                   BRA         __$SetMotorCommand
    000018BE 6413                   MOV         R1,R4
    000018C0              L542:
    000018C0 006B                   RTS/N
               mnet.c       2173      }
               mnet.c       2174    }
               mnet.c       2175    ///<summary>
               mnet.c       2176    /// 指定μs待機します
               mnet.c       2177    ///</summary>
               mnet.c       2178    static void g_Sleep(INT usec)
    000018C2              _g_Sleep:                        ; function: g_Sleep
                                                           ; frame size=0
               mnet.c       2179    {
               mnet.c       2180        INT i;
               mnet.c       2181        
               mnet.c       2182        i = 40000;          // 6.25 ns/instruction * 4 instructions * loop_count = 1ms = 1000000 ns
               mnet.c       2183        i *= usec;
               mnet.c       2184        i /= 1000;
    000018C2 E028                   MOV         #40,R0     ; H'00000028
    000018C4 4480                   MULR        R0,R4
    000018C6 6643                   MOV         R4,R6
    000018C8              L545:
               mnet.c       2185        while (i--);        /* loop count */
    000018C8 2668                   TST         R6,R6
    000018CA 8FFD                   BF/S        L545
    000018CC 76FF                   ADD         #-1,R6
               mnet.c       2186    }
    000018CE 006B                   RTS/N
               mnet.c       2187    ///<summary>
               mnet.c       2188    /// 割り込み要因をクリアします
               mnet.c       2189    ///</summary>
               mnet.c       2190    static void ClearInterrupt(void)
               mnet.c       2191    {
               mnet.c       2192    }
               mnet.c       2193    
               mnet.c       2194    /******************************************************************************
               mnet.c       2195    * 
               mnet.c       2196    * [概要]  ＩＦＢアイドリング待ち
               mnet.c       2197    * [引数]  −
               mnet.c       2198    * [戻値]  IFBビット(TRUE = ビジー , FALSE = アイドリング)
               mnet.c       2199    * 
               mnet.c       2200    ******************************************************************************/
               mnet.c       2201    static BOOL IfbIdleWait(void)
    000018D0              __$IfbIdleWait:                  ; function: __$IfbIdleWait
                                                           ; frame size=8
    000018D0 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       2202    {
               mnet.c       2203      INT loop;
               mnet.c       2204      
               mnet.c       2205      for( loop = 0; loop < MNET_CMD_RTY_MAX; loop++ )
    000018D2 EE78                   MOV         #120,R14   ; H'00000078
    000018D4              L548:
               mnet.c       2206      {
               mnet.c       2207          if( ChkIFB() == TRUE )  return( FALSE );
    000018D4 B00B                   BSR         __$ChkIFB
    000018D6 0009                   NOP
    000018D8 8801                   CMP/EQ      #1,R0
    000018DA 8B01                   BF          L550
    000018DC A005                   BRA         L551
    000018DE 0039                   MOVRT       R0
    000018E0              L550:
               mnet.c       2208          g_Sleep(5);
    000018E0 BFEF                   BSR         _g_Sleep
    000018E2 E405                   MOV         #5,R4      ; H'00000005
    000018E4 4E10                   DT          R14
    000018E6 8BF5                   BF          L548
               mnet.c       2209      }
               mnet.c       2210      
               mnet.c       2211      return( TRUE );
    000018E8 0029                   MOVT        R0
    000018EA              L551:
    000018EA 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       2212    }
    000018EC 006B                   RTS/N
               mnet.c       2213    /******************************************************************************
               mnet.c       2214    * 
               mnet.c       2215    * [概要]  ＩＦＢ状態取得
               mnet.c       2216    * [引数]  −
               mnet.c       2217    * [戻値]  IFBビット(TRUE = 1 , FALSE = 0)
               mnet.c       2218    * 
               mnet.c       2219    ******************************************************************************/
               mnet.c       2220    static BOOL ChkIFB( void )
    000018EE              __$ChkIFB:                       ; function: __$ChkIFB
                                                           ; frame size=0
               mnet.c       2221    {
               mnet.c       2222      BOOL    result; 
               mnet.c       2223    
               mnet.c       2224      if( PB.DR.BIT.B19 )
    000018EE 06E03880               MOVI20      #-116608,R6; H'FFFE3880
    000018F2 8461                   MOV.B       @(1,R6),R0
    000018F4 C808                   TST         #8,R0
               mnet.c       2225      {
               mnet.c       2226          result = TRUE;
               mnet.c       2227      }
               mnet.c       2228      else
               mnet.c       2229      {
               mnet.c       2230          result = FALSE;
               mnet.c       2231      }
               mnet.c       2232    
               mnet.c       2233      return( result );
               mnet.c       2234    }
    000018F6 000B                   RTS
    000018F8 0039                   MOVRT       R0
               mnet.c       2235    /******************************************************************************
               mnet.c       2236    * 
               mnet.c       2237    * [概要]  完了待ち
               mnet.c       2238    * [引数]  −
               mnet.c       2239    * [戻値]  TRUE = ビジー , FALSE = アイドリング
               mnet.c       2240    * 
               mnet.c       2241    ******************************************************************************/
               mnet.c       2242    static BOOL EndIdleWait(void)
    000018FA              __$EndIdleWait:                  ; function: __$EndIdleWait
                                                           ; frame size=8
    000018FA 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       2243    {
               mnet.c       2244      INT loop;
               mnet.c       2245      
               mnet.c       2246      for( loop = 0; loop < MNET_CMD_RTY_MAX; loop++ )
    000018FC EE78                   MOV         #120,R14   ; H'00000078
    000018FE              L555:
               mnet.c       2247      {
               mnet.c       2248          if( ChkEnd() == TRUE )  return( FALSE );
    000018FE B00B                   BSR         __$ChkEnd
    00001900 0009                   NOP
    00001902 8801                   CMP/EQ      #1,R0
    00001904 8B01                   BF          L557
    00001906 A005                   BRA         L558
    00001908 0039                   MOVRT       R0
    0000190A              L557:
               mnet.c       2249          g_Sleep(5);
    0000190A BFDA                   BSR         _g_Sleep
    0000190C E405                   MOV         #5,R4      ; H'00000005
    0000190E 4E10                   DT          R14
    00001910 8BF5                   BF          L555
               mnet.c       2250      }
               mnet.c       2251    
               mnet.c       2252      return( TRUE );
    00001912 0029                   MOVT        R0
    00001914              L558:
    00001914 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       2253    }
    00001916 006B                   RTS/N
               mnet.c       2254    /******************************************************************************
               mnet.c       2255    * 
               mnet.c       2256    * [概要]  エンド状態取得
               mnet.c       2257    * [引数]  −
               mnet.c       2258    * [戻値]  TRUE:完了、FALSE:未完了
               mnet.c       2259    * 
               mnet.c       2260    ******************************************************************************/
               mnet.c       2261    static BOOL ChkEnd( void )
    00001918              __$ChkEnd:                       ; function: __$ChkEnd
                                                           ; frame size=8
    00001918 4F22                   STS.L       PR,@-R15
    0000191A 7FFC                   ADD         #-4,R15
               mnet.c       2262    {
               mnet.c       2263      BOOL    result; 
               mnet.c       2264      MNETStatus status;
               mnet.c       2265    
               mnet.c       2266      GetMainStatus(&status);
    0000191C BAF6                   BSR         __$GetMainStatus
    0000191E 64F3                   MOV         R15,R4
               mnet.c       2267    
               mnet.c       2268      if (status.UNID.BIT.CEND)
    00001920 84F1                   MOV.B       @(1,R15),R0; (part of)status
    00001922 8708                   BLD         #0,R0
    00001924 8F04                   BF/S        L562
    00001926 6603                   MOV         R0,R6
               mnet.c       2269      {
               mnet.c       2270          if (status.UNID.BIT.EDTE)
    00001928 876C                   BLD         #4,R6
    0000192A 8901                   BT          L562
               mnet.c       2271          {
               mnet.c       2272              result = FALSE; //エラー
               mnet.c       2273          }
               mnet.c       2274          else
               mnet.c       2275          {
               mnet.c       2276              result = TRUE;
    0000192C A001                   BRA         L564
    0000192E 0239                   MOVRT       R2
    00001930              L562:
    00001930 E200                   MOV         #0,R2      ; H'00000000
    00001932              L564:
    00001932 7F04                   ADD         #4,R15
    00001934 4F26                   LDS.L       @R15+,PR
               mnet.c       2277          }
               mnet.c       2278      }
               mnet.c       2279      else
               mnet.c       2280      {
               mnet.c       2281          result = FALSE;
               mnet.c       2282      }
               mnet.c       2283    
               mnet.c       2284      return( result );
               mnet.c       2285    }
    00001936 027B                   RTV/N       R2
               mnet.c       2286    /******************************************************************************
               mnet.c       2287    * 
               mnet.c       2288    * [概要]  RBSY状態取得
               mnet.c       2289    * [引数]  −
               mnet.c       2290    * [戻値]  1:ON、0:OFF
               mnet.c       2291    * 
               mnet.c       2292    ******************************************************************************/
               mnet.c       2293    static UB ChkRbsy( void )
    00001938              __$ChkRbsy:                      ; function: __$ChkRbsy
                                                           ; frame size=8
    00001938 4F22                   STS.L       PR,@-R15
    0000193A 7FFC                   ADD         #-4,R15
               mnet.c       2294    {
               mnet.c       2295      UB  result; 
               mnet.c       2296      MNETStatus status;
               mnet.c       2297    
               mnet.c       2298      GetMainStatus(&status);
    0000193C BAE6                   BSR         __$GetMainStatus
    0000193E 64F3                   MOV         R15,R4
               mnet.c       2299    
               mnet.c       2300      result = ( status.UNID.BIT.RBSY ? SET : CLR );
    00001940 60F0                   MOV.B       @R15,R0    ; (part of)status
    00001942 C820                   TST         #32,R0
    00001944 7F04                   ADD         #4,R15
    00001946 4F26                   LDS.L       @R15+,PR
               mnet.c       2301    
               mnet.c       2302      return( result );
               mnet.c       2303    }
    00001948 000B                   RTS
    0000194A 0039                   MOVRT       R0
    0000194C              L629:
    0000194C <00000000>             .DATA.L     __$factor
    00001950 <00000000>             .DATA.L     __$param
    00001954 <00000000>             .DATA.L     __$RMG
    00001958 51EB851F               .DATA.L     H'51EB851F
    0000195C <00000000>             .DATA.L     __$RFL
    00001960 <00000000>             .DATA.L     __$RFH
    00001964 <00000000>             .DATA.L     __$RUR
    00001968 <00000000>             .DATA.L     __$RUS
    0000196C <00000000>             .DATA.L     __$RDS
    00001970 <00000008>             .DATA.L     H'00000008+__$MOTORSPD_TBL_PCD4611
    00001974 6B645D8D               .DATA.L     H'6B645D8D
    00001978 <00000000>             .DATA.L     __$_pmInfo
    0000197C <00000000>             .DATA.L     _MNET_DRV_TYPE
               mnet.c       2304    /******************************************************************************
               mnet.c       2305    * 
               mnet.c       2306    * [概要]  DBSY状態取得
               mnet.c       2307    * [引数]  −
               mnet.c       2308    * [戻値]  1:ON、0:OFF
               mnet.c       2309    * 
               mnet.c       2310    ******************************************************************************/
               mnet.c       2311    static UB ChkDbsy( void )
    00001980              __$ChkDbsy:                      ; function: __$ChkDbsy
                                                           ; frame size=8
    00001980 4F22                   STS.L       PR,@-R15
    00001982 7FFC                   ADD         #-4,R15
               mnet.c       2312    {
               mnet.c       2313      UB  result; 
               mnet.c       2314      MNETStatus status;
               mnet.c       2315    
               mnet.c       2316      GetMainStatus(&status);
    00001984 BAC2                   BSR         __$GetMainStatus
    00001986 64F3                   MOV         R15,R4
               mnet.c       2317    
               mnet.c       2318      result = ( status.UNID.BIT.DBSY ? SET : CLR );
    00001988 60F0                   MOV.B       @R15,R0    ; (part of)status
    0000198A C840                   TST         #64,R0
    0000198C 7F04                   ADD         #4,R15
    0000198E 4F26                   LDS.L       @R15+,PR
               mnet.c       2319    
               mnet.c       2320      return( result );
               mnet.c       2321    }
    00001990 000B                   RTS
    00001992 0039                   MOVRT       R0
               mnet.c       2322    /******************************************************************************
               mnet.c       2323    * 
               mnet.c       2324    * [概要]  SBSY状態取得
               mnet.c       2325    * [引数]  −
               mnet.c       2326    * [戻値]  1:ON、0:OFF
               mnet.c       2327    * 
               mnet.c       2328    ******************************************************************************/
               mnet.c       2329    static UB ChkSbsy( void )
    00001994              __$ChkSbsy:                      ; function: __$ChkSbsy
                                                           ; frame size=8
    00001994 4F22                   STS.L       PR,@-R15
    00001996 7FFC                   ADD         #-4,R15
               mnet.c       2330    {
               mnet.c       2331      UB  result; 
               mnet.c       2332      MNETStatus status;
               mnet.c       2333    
               mnet.c       2334      GetMainStatus(&status);
    00001998 BAB8                   BSR         __$GetMainStatus
    0000199A 64F3                   MOV         R15,R4
               mnet.c       2335    
               mnet.c       2336      result = ( status.UNID.BIT.SBSY ? SET : CLR );
    0000199C 60F0                   MOV.B       @R15,R0    ; (part of)status
    0000199E C810                   TST         #16,R0
    000019A0 7F04                   ADD         #4,R15
    000019A2 4F26                   LDS.L       @R15+,PR
               mnet.c       2337    
               mnet.c       2338      return( result );
               mnet.c       2339    }
    000019A4 000B                   RTS
    000019A6 0039                   MOVRT       R0
               mnet.c       2340    static UB dev_nowk;
               mnet.c       2341    /******************************************************************************
               mnet.c       2342    * 
               mnet.c       2343    * [概要]  RENV1 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2344    * [引数]  −
               mnet.c       2345    * [戻値]  −
               mnet.c       2346    * 
               mnet.c       2347    ******************************************************************************/
               mnet.c       2348    static ER SetRenv1Fu( UB dev_no )
    000019A8              __$SetRenv1Fu:                   ; function: __$SetRenv1Fu
                                                           ; frame size=16
    000019A8 4DF0                   MOVMU.L     R13,@-R15
    000019AA 7FFC                   ADD         #-4,R15
               mnet.c       2349    {
               mnet.c       2350      RENV1       renv1;
               mnet.c       2351      ER          result = E_SUCCESS;
               mnet.c       2352    dev_nowk = dev_no;
               mnet.c       2353      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    000019AC D16F                   MOV.L       L630+2,R1  ; _MNET_DRV_TYPE
    000019AE 6E4C                   EXTU.B      R4,R14
    000019B0 ED00                   MOV         #0,R13     ; H'00000000
    000019B2 60E3                   MOV         R14,R0
    000019B4 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    000019B6 D66E                   MOV.L       L630+6,R6  ; __$dev_nowk
    000019B8 880A                   CMP/EQ      #10,R0
    000019BA 8F02                   BF/S        L570
    000019BC 2640                   MOV.B       R4,@R6     ; dev_nowk
               mnet.c       2354      {
               mnet.c       2355          return( result );
    000019BE A01A                   BRA         L571
    000019C0 E000                   MOV         #0,R0      ; H'00000000
    000019C2              L570:
               mnet.c       2356      }
               mnet.c       2357    
               mnet.c       2358      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    000019C2 8809                   CMP/EQ      #9,R0
    000019C4 8916                   BT          L573
    000019C6 E604                   MOV         #4,R6      ; H'00000004
    000019C8 E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2359      {
               mnet.c       2360          memset( &renv1, CLR, sizeof( RENV1 ) );
    000019CA D26A                   MOV.L       L630+10,R2 ; _memset
    000019CC 420B                   JSR         @R2
    000019CE 64F3                   MOV         R15,R4
               mnet.c       2361    
               mnet.c       2362          renv1.UNID.BIT.PDTC = 1;
               mnet.c       2363    
               mnet.c       2364          //FU-A
               mnet.c       2365          if( MNET_DRV_TYPE[dev_no] == BCD4020FUA )
    000019D0 D166                   MOV.L       L630+2,R1  ; _MNET_DRV_TYPE
    000019D2 60E3                   MOV         R14,R0
    000019D4 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    000019D6 8801                   CMP/EQ      #1,R0
    000019D8 3F591000               BSET.B      #5,@(0,R15); (part of)renv1
    000019DC 8B01                   BF          L575
               mnet.c       2366          {
               mnet.c       2367              // 自動カレントダウン
               mnet.c       2368              renv1.UNID.BIT.CDWN = 1;
    000019DE 3F791000               BSET.B      #7,@(0,R15); (part of)renv1
    000019E2              L575:
    000019E2 66F2                   MOV.L       @R15,R6    ; renv1.UNID.data
    000019E4 E59C                   MOV         #-100,R5   ; H'FFFFFF9C
    000019E6 655C                   EXTU.B      R5,R5
               mnet.c       2369          }
               mnet.c       2370    
               mnet.c       2371          // 9Ch
               mnet.c       2372          if (!SetMotorRegisterInt( dev_no, WRG_RENV1, renv1.UNID.data ) )
    000019E8 BAE9                   BSR         _SetMotorRegisterInt
    000019EA 64E3                   MOV         R14,R4
    000019EC 2008                   TST         R0,R0
    000019EE 8B01                   BF          L573
               mnet.c       2373          {
               mnet.c       2374              result = E_MNT_ACCESS + WRG_RENV1;
    000019F0 0D00059C               MOVI20      #1436,R13  ; H'0000059C
    000019F4              L573:
               mnet.c       2375          }
               mnet.c       2376      }
               mnet.c       2377      return( result );
    000019F4 60D3                   MOV         R13,R0
    000019F6              L571:
    000019F6 7F04                   ADD         #4,R15
    000019F8 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       2378    }
    000019FA 006B                   RTS/N
               mnet.c       2379    /******************************************************************************
               mnet.c       2380    * 
               mnet.c       2381    * [概要]  RENV2 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2382    * [引数]  −
               mnet.c       2383    * [戻値]  −
               mnet.c       2384    * 
               mnet.c       2385    ******************************************************************************/
               mnet.c       2386    static ER SetRenv2Fu( UB dev_no, UB teibai )
    000019FC              __$SetRenv2Fu:                   ; function: __$SetRenv2Fu
                                                           ; frame size=20
    000019FC 4CF0                   MOVMU.L     R12,@-R15
    000019FE 7FFC                   ADD         #-4,R15
               mnet.c       2387    {
               mnet.c       2388      ER          result = E_SUCCESS;
               mnet.c       2389      RENV2       renv2;
               mnet.c       2390    
               mnet.c       2391      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    00001A00 D15A                   MOV.L       L630+2,R1  ; _MNET_DRV_TYPE
    00001A02 6D4C                   EXTU.B      R4,R13
    00001A04 EC00                   MOV         #0,R12     ; H'00000000
    00001A06 60D3                   MOV         R13,R0
    00001A08 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    00001A0A 880A                   CMP/EQ      #10,R0
    00001A0C 8F02                   BF/S        L584
    00001A0E 6E53                   MOV         R5,R14
               mnet.c       2392      {
               mnet.c       2393          return( result );
    00001A10 A037                   BRA         L585
    00001A12 E000                   MOV         #0,R0      ; H'00000000
    00001A14              L584:
               mnet.c       2394      }
               mnet.c       2395    
               mnet.c       2396      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    00001A14 8809                   CMP/EQ      #9,R0
    00001A16 8933                   BT          L587
    00001A18 E604                   MOV         #4,R6      ; H'00000004
    00001A1A E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2397      {
               mnet.c       2398          memset( &renv2, CLR, sizeof( RENV2 ) );
    00001A1C D255                   MOV.L       L630+10,R2 ; _memset
    00001A1E 420B                   JSR         @R2
    00001A20 64F3                   MOV         R15,R4
               mnet.c       2399          
               mnet.c       2400          // P0M 励磁出力
               mnet.c       2401          renv2.UNID.BIT.P0M  = 1;
               mnet.c       2402          
               mnet.c       2403          if( MNET_DRV_TYPE[dev_no] == BCD4020FUA )
    00001A22 D152                   MOV.L       L630+2,R1  ; _MNET_DRV_TYPE
    00001A24 60D3                   MOV         R13,R0
    00001A26 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    00001A28 8801                   CMP/EQ      #1,R0
    00001A2A 3F091003               BSET.B      #0,@(3,R15); (part of)renv2
    00001A2E 8B05                   BF          L589
               mnet.c       2404          {
               mnet.c       2405              // P1M 汎用出力
               mnet.c       2406              renv2.UNID.BIT.P1M  = 1;
    00001A30 3F191003               BSET.B      #1,@(3,R15); (part of)renv2
               mnet.c       2407    
               mnet.c       2408              // P2M 汎用出力
               mnet.c       2409              renv2.UNID.BIT.P2M  = 1;
    00001A34 3F291003               BSET.B      #2,@(3,R15); (part of)renv2
    00001A38 A002                   BRA         L590
    00001A3A 0009                   NOP
    00001A3C              L589:
               mnet.c       2410          }
               mnet.c       2411          else
               mnet.c       2412          {
               mnet.c       2413              // P6M 自動カレントダウン
               mnet.c       2414              renv2.UNID.BIT.P6M  = 1;
    00001A3C 3F691003               BSET.B      #6,@(3,R15); (part of)renv2
    00001A40              L590:
               mnet.c       2415          }
               mnet.c       2416          
               mnet.c       2417          // EOF
               mnet.c       2418          renv2.UNID.BIT.E0FF = 0;
               mnet.c       2419    
               mnet.c       2420          // EA/EB入力仕様
               mnet.c       2421          switch( teibai )
    00001A40 60EC                   EXTU.B      R14,R0
    00001A42 8801                   CMP/EQ      #1,R0
    00001A44 3F190001               BCLR.B      #1,@(1,R15); (part of)renv2
    00001A48 8903                   BT          L592
    00001A4A 8802                   CMP/EQ      #2,R0
    00001A4C 8905                   BT          L593
    00001A4E A00A                   BRA         L594
    00001A50 0009                   NOP
    00001A52              L592:
               mnet.c       2422          {
               mnet.c       2423          // 1逓倍
               mnet.c       2424          case EC_1:
               mnet.c       2425              renv2.UNID.BIT.EIM0 = 0;
    00001A52 3F190002               BCLR.B      #1,@(2,R15); (part of)renv2
    00001A56 A002                   BRA         L595
    00001A58 0009                   NOP
    00001A5A              L593:
               mnet.c       2426              renv2.UNID.BIT.EIM1 = 0;
               mnet.c       2427              break;
               mnet.c       2428          // 2逓倍
               mnet.c       2429          case EC_2:
               mnet.c       2430              renv2.UNID.BIT.EIM0 = 1;
    00001A5A 3F191002               BSET.B      #1,@(2,R15); (part of)renv2
    00001A5E              L595:
    00001A5E 3F290002               BCLR.B      #2,@(2,R15); (part of)renv2
    00001A62 A004                   BRA         L596
    00001A64 0009                   NOP
    00001A66              L594:
               mnet.c       2431              renv2.UNID.BIT.EIM1 = 0;
               mnet.c       2432              break;
               mnet.c       2433          // 4逓倍
               mnet.c       2434          case EC_3:
               mnet.c       2435          default:
               mnet.c       2436              renv2.UNID.BIT.EIM0 = 0;
    00001A66 3F190002               BCLR.B      #1,@(2,R15); (part of)renv2
               mnet.c       2437              renv2.UNID.BIT.EIM1 = 1;
    00001A6A 3F291002               BSET.B      #2,@(2,R15); (part of)renv2
    00001A6E              L596:
    00001A6E 66F2                   MOV.L       @R15,R6    ; renv2.UNID.data
    00001A70 E59D                   MOV         #-99,R5    ; H'FFFFFF9D
    00001A72 655C                   EXTU.B      R5,R5
               mnet.c       2438              break;
               mnet.c       2439          }
               mnet.c       2440          
               mnet.c       2441          // 9Dh
               mnet.c       2442          if (!SetMotorRegisterInt( dev_no, WRG_RENV2, renv2.UNID.data ) )
    00001A74 BAA3                   BSR         _SetMotorRegisterInt
    00001A76 64D3                   MOV         R13,R4
    00001A78 2008                   TST         R0,R0
    00001A7A 8B01                   BF          L587
               mnet.c       2443          {
               mnet.c       2444              result = E_MNT_ACCESS + WRG_RENV2;
    00001A7C 0C00059D               MOVI20      #1437,R12  ; H'0000059D
    00001A80              L587:
               mnet.c       2445          }
               mnet.c       2446      }
               mnet.c       2447      return( result );
    00001A80 60C3                   MOV         R12,R0
    00001A82              L585:
    00001A82 7F04                   ADD         #4,R15
    00001A84 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       2448    }
    00001A86 006B                   RTS/N
               mnet.c       2449    /******************************************************************************
               mnet.c       2450    * 
               mnet.c       2451    * [概要]  RENV3 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2452    * [引数]  −
               mnet.c       2453    * [戻値]  −
               mnet.c       2454    * 
               mnet.c       2455    ******************************************************************************/
               mnet.c       2456    static ER SetRenv3Fu( UB dev_no, UB enc )
    00001A88              __$SetRenv3Fu:                   ; function: __$SetRenv3Fu
                                                           ; frame size=16
    00001A88 4DF0                   MOVMU.L     R13,@-R15
    00001A8A 7FFC                   ADD         #-4,R15
               mnet.c       2457    {
               mnet.c       2458      ER          result = E_SUCCESS;
               mnet.c       2459      RENV3       renv3;
               mnet.c       2460    
               mnet.c       2461      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    00001A8C D637                   MOV.L       L630+2,R6  ; _MNET_DRV_TYPE
    00001A8E 6E4C                   EXTU.B      R4,R14
    00001A90 60E3                   MOV         R14,R0
    00001A92 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00001A94 880A                   CMP/EQ      #10,R0
    00001A96 8F02                   BF/S        L600
    00001A98 ED00                   MOV         #0,R13     ; H'00000000
               mnet.c       2462      {
               mnet.c       2463          return( result );
    00001A9A A019                   BRA         L601
    00001A9C E000                   MOV         #0,R0      ; H'00000000
    00001A9E              L600:
               mnet.c       2464      }
               mnet.c       2465    
               mnet.c       2466      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    00001A9E 8809                   CMP/EQ      #9,R0
    00001AA0 8915                   BT          L603
    00001AA2 E604                   MOV         #4,R6      ; H'00000004
    00001AA4 E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2467      {
               mnet.c       2468          memset( &renv3, CLR, sizeof( RENV3 ) );
    00001AA6 D233                   MOV.L       L630+10,R2 ; _memset
    00001AA8 420B                   JSR         @R2
    00001AAA 64F3                   MOV         R15,R4
               mnet.c       2469    
               mnet.c       2470          // 原点復帰動作設定：原点復帰２
               mnet.c       2471          renv3.UNID.BIT.ORM0 = 0;
    00001AAC 85F1                   MOV.W       @(2,R15),R0; (part of)renv3
    00001AAE E59E                   MOV         #-98,R5    ; H'FFFFFF9E
    00001AB0 01F0F0FC               MOVI20      #-3844,R1  ; H'FFFFF0FC
    00001AB4 2019                   AND         R1,R0
    00001AB6 655C                   EXTU.B      R5,R5
               mnet.c       2472          renv3.UNID.BIT.ORM1 = 0;
    00001AB8 0200100C               MOVI20      #4108,R2   ; H'0000100C
    00001ABC 202B                   OR          R2,R0
               mnet.c       2473          renv3.UNID.BIT.ORM2 = 1;
               mnet.c       2474          renv3.UNID.BIT.ORM3 = 1;
               mnet.c       2475    
               mnet.c       2476          // COUNTER2カウント設定：EA/EB入力
               mnet.c       2477          renv3.UNID.BIT.CI20 = 0;
               mnet.c       2478          renv3.UNID.BIT.CI21 = 0;
               mnet.c       2479    
               mnet.c       2480          // COUNTER3カウント設定：出力パルスとEA/EB入力（偏差）
               mnet.c       2481          renv3.UNID.BIT.CI30 = 0;
               mnet.c       2482          renv3.UNID.BIT.CI31 = 0;
               mnet.c       2483          renv3.UNID.BIT.CI32 = 1;
               mnet.c       2484    
               mnet.c       2485          // 9Eh
               mnet.c       2486          if (!SetMotorRegisterInt(dev_no, WRG_RENV3, renv3.UNID.data) )
    00001ABE 64E3                   MOV         R14,R4
    00001AC0 81F1                   MOV.W       R0,@(2,R15); (part of)renv3
    00001AC2 BA7C                   BSR         _SetMotorRegisterInt
    00001AC4 66F2                   MOV.L       @R15,R6    ; renv3.UNID.data
    00001AC6 2008                   TST         R0,R0
    00001AC8 8B01                   BF          L603
               mnet.c       2487          {
               mnet.c       2488              result = E_MNT_ACCESS + WRG_RENV3;
    00001ACA 0D00059E               MOVI20      #1438,R13  ; H'0000059E
    00001ACE              L603:
               mnet.c       2489          }
               mnet.c       2490      }
               mnet.c       2491      return( result );
    00001ACE 60D3                   MOV         R13,R0
    00001AD0              L601:
    00001AD0 7F04                   ADD         #4,R15
    00001AD2 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       2492    }
    00001AD4 006B                   RTS/N
               mnet.c       2493    /******************************************************************************
               mnet.c       2494    * 
               mnet.c       2495    * [概要]  RENV4 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2496    * [引数]  −
               mnet.c       2497    * [戻値]  −
               mnet.c       2498    * 
               mnet.c       2499    ******************************************************************************/
               mnet.c       2500    static ER SetRenv4Fu( UB dev_no, INT so )
               mnet.c       2501    {
               mnet.c       2502      ER          result = E_SUCCESS;
               mnet.c       2503      RENV4       renv4;
               mnet.c       2504      UB          sts;
               mnet.c       2505    
               mnet.c       2506      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
               mnet.c       2507      {
               mnet.c       2508          return( result );
               mnet.c       2509      }
               mnet.c       2510      
               mnet.c       2511      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
               mnet.c       2512      {
               mnet.c       2513          memset( &renv4, CLR, sizeof( RENV4 ) );
               mnet.c       2514          
               mnet.c       2515          sts = ( so > 0 ? SET : CLR );
               mnet.c       2516    
               mnet.c       2517          // コンパレータ３の比較カウンタ選択：COUNTER3(汎用・偏差)
               mnet.c       2518          renv4.UNID.BIT.C3C0 = 0;
               mnet.c       2519          renv4.UNID.BIT.C3C1 = sts;
               mnet.c       2520    
               mnet.c       2521          // コンパレータ３の比較方法選択：RCMP3＝比較カウンタ
               mnet.c       2522          renv4.UNID.BIT.C3S0 = sts;
               mnet.c       2523          renv4.UNID.BIT.C3S1 = 0;
               mnet.c       2524          renv4.UNID.BIT.C3S2 = 0;
               mnet.c       2525          renv4.UNID.BIT.C3S3 = 0;
               mnet.c       2526    
               mnet.c       2527          // コンパレータ３条件成立時の処理選択：即停止
               mnet.c       2528          renv4.UNID.BIT.C3D0 = sts;
               mnet.c       2529          renv4.UNID.BIT.C3D1 = 0;
               mnet.c       2530          
               mnet.c       2531          // 9Fh
               mnet.c       2532          if (!SetMotorRegisterInt(dev_no, WRG_RENV4, renv4.UNID.data) )
               mnet.c       2533          {
               mnet.c       2534              result = E_MNT_ACCESS + WRG_RENV4;
               mnet.c       2535          }
               mnet.c       2536      }
               mnet.c       2537      return( result );
               mnet.c       2538    }
               mnet.c       2539    /******************************************************************************
               mnet.c       2540    * 
               mnet.c       2541    * [概要]  RMD 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2542    * [引数]  −
               mnet.c       2543    * [戻値]  −
               mnet.c       2544    * 
               mnet.c       2545    ******************************************************************************/
               mnet.c       2546    static ER SetRmdFu( UB dev_no, UB mod )
    00001AD6              __$SetRmdFu:                     ; function: __$SetRmdFu
                                                           ; frame size=20
    00001AD6 4DF0                   MOVMU.L     R13,@-R15
    00001AD8 7FF8                   ADD         #-8,R15
    00001ADA D624                   MOV.L       L630+2,R6  ; _MNET_DRV_TYPE
    00001ADC 6E4C                   EXTU.B      R4,R14
    00001ADE 60E3                   MOV         R14,R0
    00001AE0 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
               mnet.c       2547    {
               mnet.c       2548      ER          result = E_SUCCESS;
               mnet.c       2549      RMD         rmd;
               mnet.c       2550    
               mnet.c       2551      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    00001AE2 880A                   CMP/EQ      #10,R0
    00001AE4 8D27                   BT/S        L607
    00001AE6 6D53                   MOV         R5,R13
               mnet.c       2552      {
               mnet.c       2553          return( result );
               mnet.c       2554      }
               mnet.c       2555      
               mnet.c       2556      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    00001AE8 8809                   CMP/EQ      #9,R0
    00001AEA 8924                   BT          L607
    00001AEC E604                   MOV         #4,R6      ; H'00000004
    00001AEE E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2557      {
               mnet.c       2558          memset( &rmd, CLR, sizeof( RMD ) );
    00001AF0 D220                   MOV.L       L630+10,R2 ; _memset
    00001AF2 420B                   JSR         @R2
    00001AF4 64F3                   MOV         R15,R4
    00001AF6 E5D7                   MOV         #-41,R5    ; H'FFFFFFD7
    00001AF8 1FE1                   MOV.L       R14,@(4,R15)
    00001AFA 655C                   EXTU.B      R5,R5
               mnet.c       2559          
               mnet.c       2560          if (!GetMotorRegister(dev_no, RRG_RMD, &rmd.UNID.data))
    00001AFC 64E3                   MOV         R14,R4
    00001AFE BAB3                   BSR         _GetMotorRegister
    00001B00 66F3                   MOV         R15,R6
    00001B02 2008                   TST         R0,R0
    00001B04 000005D7               MOVI20      #1495,R0   ; H'000005D7
    00001B08 8916                   BT          L610
               mnet.c       2561          {
               mnet.c       2562              return(( E_MNT_ACCESS + RRG_RMD ));
               mnet.c       2563          }
               mnet.c       2564          rmd.UNID.BIT.MOD = mod;
    00001B0A 84F3                   MOV.B       @(3,R15),R0; (part of)rmd
    00001B0C E180                   MOV         #-128,R1   ; H'FFFFFF80
               mnet.c       2565          rmd.UNID.BIT.MINT = 1;
               mnet.c       2566    
               mnet.c       2567          if (!SetMotorRegisterInt(dev_no, WRG_RMD, rmd.UNID.data))
    00001B0E 54F1                   MOV.L       @(4,R15),R4
    00001B10 E597                   MOV         #-105,R5   ; H'FFFFFF97
    00001B12 2019                   AND         R1,R0
    00001B14 6203                   MOV         R0,R2
    00001B16 60D3                   MOV         R13,R0
    00001B18 C97F                   AND         #127,R0
    00001B1A 220B                   OR          R0,R2
    00001B1C 655C                   EXTU.B      R5,R5
    00001B1E 6023                   MOV         R2,R0
    00001B20 80F3                   MOV.B       R0,@(3,R15); (part of)rmd
    00001B22 3F391001               BSET.B      #3,@(1,R15); (part of)rmd
    00001B26 BA4A                   BSR         _SetMotorRegisterInt
    00001B28 66F2                   MOV.L       @R15,R6    ; rmd.UNID.data
    00001B2A 2008                   TST         R0,R0
    00001B2C 8B03                   BF          L607
               mnet.c       2568          {
               mnet.c       2569              return(( E_MNT_ACCESS + WRG_RMD ));
    00001B2E 00000597               MOVI20      #1431,R0   ; H'00000597
    00001B32 A001                   BRA         L610
    00001B34 0009                   NOP
    00001B36              L607:
    00001B36 E000                   MOV         #0,R0      ; H'00000000
    00001B38              L610:
    00001B38 7F08                   ADD         #8,R15
    00001B3A 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       2570          }
               mnet.c       2571      }
               mnet.c       2572      return( result );
               mnet.c       2573    }
    00001B3C 006B                   RTS/N
               mnet.c       2574    /******************************************************************************
               mnet.c       2575    * 
               mnet.c       2576    * [概要]  RMV 設定
               mnet.c       2577    * [引数]  −
               mnet.c       2578    * [戻値]  −
               mnet.c       2579    * 
               mnet.c       2580    ******************************************************************************/
               mnet.c       2581    static ER SetRmv( UB dev_no, INT pos )
    00001B3E              __$SetRmv:                       ; function: __$SetRmv
                                                           ; frame size=4
    00001B3E 4F22                   STS.L       PR,@-R15
               mnet.c       2582    {
               mnet.c       2583      ER          result = E_SUCCESS;
               mnet.c       2584    
               mnet.c       2585      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )
    00001B40 D60A                   MOV.L       L630+2,R6  ; _MNET_DRV_TYPE
    00001B42 644C                   EXTU.B      R4,R4
    00001B44 6043                   MOV         R4,R0
    00001B46 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00001B48 880A                   CMP/EQ      #10,R0
    00001B4A 890B                   BT          L614
               mnet.c       2586      {
               mnet.c       2587          // 圧力ユニット
               mnet.c       2588          return( result );
               mnet.c       2589      }
               mnet.c       2590      
               mnet.c       2591      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    00001B4C 8809                   CMP/EQ      #9,R0
    00001B4E 8909                   BT          L614
               mnet.c       2592      {
               mnet.c       2593          if (!SetMotorRegisterInt(dev_no, WRG_RMV, pos))
    00001B50 6653                   MOV         R5,R6
    00001B52 E590                   MOV         #-112,R5   ; H'FFFFFF90
    00001B54 BA33                   BSR         _SetMotorRegisterInt
    00001B56 655C                   EXTU.B      R5,R5
    00001B58 2008                   TST         R0,R0
    00001B5A 8B03                   BF          L614
               mnet.c       2594          {
               mnet.c       2595              return(( E_MNT_ACCESS + WRG_RMV ));
    00001B5C 00000590               MOVI20      #1424,R0   ; H'00000590
    00001B60 A001                   BRA         L617
    00001B62 0009                   NOP
    00001B64              L614:
    00001B64 E000                   MOV         #0,R0      ; H'00000000
    00001B66              L617:
    00001B66 4F26                   LDS.L       @R15+,PR
               mnet.c       2596          }
               mnet.c       2597      }
               mnet.c       2598      return( result );
               mnet.c       2599    }
    00001B68 006B                   RTS/N
    00001B6A              L630:
    00001B6A 00000002               .RES.W      1
    00001B6C <00000000>             .DATA.L     _MNET_DRV_TYPE
    00001B70 <00000000>             .DATA.L     __$dev_nowk
    00001B74 <00000000>             .DATA.L     _memset
               mnet.c       2600    /******************************************************************************
               mnet.c       2601    * 
               mnet.c       2602    * [概要]  RMV 設定
               mnet.c       2603    * [引数]  −
               mnet.c       2604    * [戻値]  −
               mnet.c       2605    * 
               mnet.c       2606    ******************************************************************************/
               mnet.c       2607    static ER SetRmvPCD4611( UB dev_no, INT pos )
               mnet.c       2608    {
               mnet.c       2609      WriteMemoryIntPCD4611( pos );
               mnet.c       2610      WriteMemoryPCD4611( WRG_RMV );
               mnet.c       2611    
               mnet.c       2612      return( E_SUCCESS );
               mnet.c       2613    }
               mnet.c       2614    /******************************************************************************
               mnet.c       2615    * 
               mnet.c       2616    * [概要]  RENV1 設定( PCD4611 )
               mnet.c       2617    * [引数]  −
               mnet.c       2618    * [戻値]  −
               mnet.c       2619    * 
               mnet.c       2620    ******************************************************************************/
               mnet.c       2621    static ER SetRenv1PCD4611( UB dev_no )
               mnet.c       2622    {
               mnet.c       2623    
               mnet.c       2624      return( E_SUCCESS );
               mnet.c       2625    }
               mnet.c       2626    
               mnet.c       2627    /******************************************************************************
               mnet.c       2628    * 
               mnet.c       2629    * [概要]  RENV2 設定( PCD4611 )
               mnet.c       2630    * [引数]  −
               mnet.c       2631    * [戻値]  −
               mnet.c       2632    * 
               mnet.c       2633    ******************************************************************************/
               mnet.c       2634    static ER SetRenv2PCD4611()
               mnet.c       2635    {
               mnet.c       2636      WriteMemoryIntPCD4611( 0x00000005 );// EA/EB: A/B相1逓倍, P1〜P0: 汎用出力
               mnet.c       2637      WriteMemoryPCD4611( WPCD_RENV2 );   // 0x9D
               mnet.c       2638    
               mnet.c       2639      return( E_SUCCESS );
               mnet.c       2640    }
               mnet.c       2641    /******************************************************************************
               mnet.c       2642    * 
               mnet.c       2643    * [概要]  RENV3 設定( PCD4611 )
               mnet.c       2644    * [引数]  −
               mnet.c       2645    * [戻値]  −
               mnet.c       2646    * 
               mnet.c       2647    ******************************************************************************/
               mnet.c       2648    static ER SetRenv3PCD4611( UB dev_no, UB enc )
               mnet.c       2649    {
               mnet.c       2650      return( E_SUCCESS );
               mnet.c       2651    }
               mnet.c       2652    /******************************************************************************
               mnet.c       2653    * 
               mnet.c       2654    * [概要]  RMD 設定( PCD4611 )
               mnet.c       2655    * [引数]  −
               mnet.c       2656    * [戻値]  −
               mnet.c       2657    * 
               mnet.c       2658    ******************************************************************************/
               mnet.c       2659    static ER SetRmdPCD4611( UB dev_no, UB mod )
               mnet.c       2660    {
               mnet.c       2661      WriteMemoryIntPCD4611( mod );
               mnet.c       2662      WriteMemoryPCD4611( WPCD_PRMD );
               mnet.c       2663    
               mnet.c       2664      return( E_SUCCESS );
               mnet.c       2665    }
               mnet.c       2666    
               mnet.c       2667    #ifdef DEBUG_INFO
               mnet.c       2668    static    INT dbgread;
               mnet.c       2669    
               mnet.c       2670    /******************************************************************************
               mnet.c       2671    * 
               mnet.c       2672    * [概要]  SBSY状態取得
               mnet.c       2673    * [引数]  −
               mnet.c       2674    * [戻値]  1:ON、0:OFF
               mnet.c       2675    * 
               mnet.c       2676    ******************************************************************************/
               mnet.c       2677    static void DebugMnetInfo( UB mm )
    00001B78              __$DebugMnetInfo:                ; function: __$DebugMnetInfo
                                                           ; frame size=16
    00001B78 4CF0                   MOVMU.L     R12,@-R15
               mnet.c       2678    {
               mnet.c       2679    
               mnet.c       2680      dbgread = 0;
    00001B7A E100                   MOV         #0,R1      ; H'00000000
    00001B7C E5C0                   MOV         #-64,R5    ; H'FFFFFFC0
    00001B7E DE3D                   MOV.L       L631+2,R14 ; __$dbgread
    00001B80 2E12                   MOV.L       R1,@R14    ; dbgread
               mnet.c       2681      GetMotorRegister(mm, RRG_PRMV, &dbgread);           //  RRG_PRMV    = 0x00C0,   PRMV レジスタ の読み出し
    00001B82 6C4C                   EXTU.B      R4,R12
    00001B84 655C                   EXTU.B      R5,R5
    00001B86 66E3                   MOV         R14,R6
    00001B88 6D53                   MOV         R5,R13
    00001B8A 7D05                   ADD         #5,R13
    00001B8C BA6C                   BSR         _GetMotorRegister
    00001B8E 64C3                   MOV         R12,R4
               mnet.c       2682    
               mnet.c       2683      dbgread = 0;
               mnet.c       2684    //    GetMotorRegister(mm, RRG_PRFL, &dbgread);           //  RRG_PRFL    = 0x00C1,   PRFL レジスタ の読み出し
               mnet.c       2685    //    GetMotorRegister(mm, RRG_PRFH, &dbgread);           //  RRG_PRFH    = 0x00C2,   PRFH レジスタ の読み出し
               mnet.c       2686    //    GetMotorRegister(mm, RRG_PRUR, &dbgread);           //  RRG_PRUR    = 0x00C3,   PRUR レジスタ の読み出し
               mnet.c       2687    //    GetMotorRegister(mm, RRG_PRDR, &dbgread);           //  RRG_PRDR    = 0x00C4,   PRDR レジスタ の読み出し
               mnet.c       2688    
               mnet.c       2689      dbgread = 0;
    00001B90 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2690      GetMotorRegister(mm, RRG_PRMG, &dbgread);           //  RRG_PRMG    = 0x00C5,   PRMG レジスタ の読み出し
    00001B92 66E3                   MOV         R14,R6
    00001B94 2E72                   MOV.L       R7,@R14    ; dbgread
    00001B96 64C3                   MOV         R12,R4
    00001B98 65D3                   MOV         R13,R5
    00001B9A BA65                   BSR         _GetMotorRegister
    00001B9C 7D01                   ADD         #1,R13
               mnet.c       2691      dbgread = 0;
    00001B9E E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2692      GetMotorRegister(mm, RRG_PRDP, &dbgread);           //  RRG_PRDP    = 0x00C6,   PRDP レジスタ の読み出し
    00001BA0 66E3                   MOV         R14,R6
    00001BA2 2E12                   MOV.L       R1,@R14    ; dbgread
    00001BA4 64C3                   MOV         R12,R4
    00001BA6 65D3                   MOV         R13,R5
    00001BA8 BA5E                   BSR         _GetMotorRegister
    00001BAA 7D01                   ADD         #1,R13
               mnet.c       2693      dbgread = 0;
    00001BAC E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2694      GetMotorRegister(mm, RRG_PRMD, &dbgread);           //  RRG_PRMD    = 0x00C7,   PRMD レジスタ の読み出し
    00001BAE 66E3                   MOV         R14,R6
    00001BB0 2E72                   MOV.L       R7,@R14    ; dbgread
    00001BB2 64C3                   MOV         R12,R4
    00001BB4 65D3                   MOV         R13,R5
    00001BB6 BA57                   BSR         _GetMotorRegister
    00001BB8 7D02                   ADD         #2,R13
               mnet.c       2695      dbgread = 0;
    00001BBA E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2696      GetMotorRegister(mm, RRG_PRUS, &dbgread);           //  RRG_PRUS    = 0x00C9,   PRUS レジスタ の読み出し
    00001BBC 66E3                   MOV         R14,R6
    00001BBE 2E12                   MOV.L       R1,@R14    ; dbgread
    00001BC0 64C3                   MOV         R12,R4
    00001BC2 65D3                   MOV         R13,R5
    00001BC4 BA50                   BSR         _GetMotorRegister
    00001BC6 7D01                   ADD         #1,R13
               mnet.c       2697      dbgread = 0;
    00001BC8 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2698      GetMotorRegister(mm, RRG_PRDS, &dbgread);           //  RRG_PRDS    = 0x00CA,   PRDS レジスタ の読み出し
    00001BCA 66E3                   MOV         R14,R6
    00001BCC 2E72                   MOV.L       R7,@R14    ; dbgread
    00001BCE 64C3                   MOV         R12,R4
    00001BD0 65D3                   MOV         R13,R5
    00001BD2 BA49                   BSR         _GetMotorRegister
    00001BD4 7D06                   ADD         #6,R13
               mnet.c       2699      
               mnet.c       2700      dbgread = 0;
    00001BD6 E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2701      GetMotorRegister(mm, RRG_RMV, &dbgread);            //  RRG_RMV     = 0x00D0,   RMV レジスタ の読み出し
    00001BD8 66E3                   MOV         R14,R6
    00001BDA 2E12                   MOV.L       R1,@R14    ; dbgread
    00001BDC 64C3                   MOV         R12,R4
    00001BDE 65D3                   MOV         R13,R5
    00001BE0 BA42                   BSR         _GetMotorRegister
    00001BE2 7D07                   ADD         #7,R13
               mnet.c       2702    //    GetMotorRegister(mm, RRG_RFL, &dbgread);            //  RRG_RFL     = 0x00D1,   RFL レジスタ の読み出し
               mnet.c       2703    //    GetMotorRegister(mm, RRG_RFH, &dbgread);            //  RRG_RFH     = 0x00D2,   RFH レジスタ の読み出し
               mnet.c       2704    //    GetMotorRegister(mm, RRG_RUR, &dbgread);            //  RRG_RUR     = 0x00D3,   RUR レジスタ の読み出し
               mnet.c       2705    //    GetMotorRegister(mm, RRG_RDR, &dbgread);            //  RRG_RDR     = 0x00D4,   RDR レジスタ の読み出し
               mnet.c       2706    //    GetMotorRegister(mm, RRG_RMG, &dbgread);            //  RRG_RMG     = 0x00D5,   RMG レジスタ の読み出し
               mnet.c       2707    //    GetMotorRegister(mm, RRG_RDP, &dbgread);            //  RRG_RDP     = 0x00D6,   RDP レジスタ の読み出し
               mnet.c       2708      dbgread = 0;
    00001BE4 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2709      GetMotorRegister(mm, RRG_RMD, &dbgread);            //  RRG_RMD     = 0x00D7,   RMD レジスタ の読み出し
    00001BE6 66E3                   MOV         R14,R6
    00001BE8 2E72                   MOV.L       R7,@R14    ; dbgread
    00001BEA 64C3                   MOV         R12,R4
    00001BEC 65D3                   MOV         R13,R5
    00001BEE BA3B                   BSR         _GetMotorRegister
    00001BF0 7D05                   ADD         #5,R13
               mnet.c       2710    //    GetMotorRegister(mm, RRG_RUS, &dbgread);            //  RRG_RUS     = 0x00D9,   RUS レジスタ の読み出し
               mnet.c       2711    //    GetMotorRegister(mm, RRG_RDS, &dbgread);            //  RRG_RDS     = 0x00DA,   RDS レジスタ の読み出し
               mnet.c       2712    //    GetMotorRegister(mm, RRG_RFA, &dbgread);            //  RRG_RFA     = 0x00DB,   RFA レジスタ の読み出し
               mnet.c       2713      dbgread = 0;
    00001BF2 E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2714      GetMotorRegister(mm, RRG_RENV1, &dbgread);          //  RRG_RENV1   = 0x00DC,   RENV1 レジスタ の読み出し
    00001BF4 66E3                   MOV         R14,R6
    00001BF6 2E12                   MOV.L       R1,@R14    ; dbgread
    00001BF8 64C3                   MOV         R12,R4
    00001BFA 65D3                   MOV         R13,R5
    00001BFC BA34                   BSR         _GetMotorRegister
    00001BFE 7D01                   ADD         #1,R13
               mnet.c       2715      dbgread = 0;
    00001C00 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2716      GetMotorRegister(mm, RRG_RENV2, &dbgread);          //  RRG_RENV2   = 0x00DD,   RENV2 レジスタ の読み出し
    00001C02 66E3                   MOV         R14,R6
    00001C04 2E72                   MOV.L       R7,@R14    ; dbgread
    00001C06 64C3                   MOV         R12,R4
    00001C08 65D3                   MOV         R13,R5
    00001C0A BA2D                   BSR         _GetMotorRegister
    00001C0C 7D01                   ADD         #1,R13
               mnet.c       2717      dbgread = 0;
    00001C0E E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2718      GetMotorRegister(mm, RRG_RENV3, &dbgread);          //  RRG_RENV3   = 0x00DE,   RENV3 レジスタ の読み出し
    00001C10 66E3                   MOV         R14,R6
    00001C12 2E12                   MOV.L       R1,@R14    ; dbgread
    00001C14 64C3                   MOV         R12,R4
    00001C16 65D3                   MOV         R13,R5
    00001C18 BA26                   BSR         _GetMotorRegister
    00001C1A 7D01                   ADD         #1,R13
               mnet.c       2719      dbgread = 0;
    00001C1C E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2720      GetMotorRegister(mm, RRG_RENV4, &dbgread);          //  RRG_RENV4   = 0x00DF,   RENV4 レジスタ の読み出し
    00001C1E 66E3                   MOV         R14,R6
    00001C20 2E72                   MOV.L       R7,@R14    ; dbgread
    00001C22 64C3                   MOV         R12,R4
    00001C24 65D3                   MOV         R13,R5
    00001C26 BA1F                   BSR         _GetMotorRegister
    00001C28 7D01                   ADD         #1,R13
               mnet.c       2721      dbgread = 0;
    00001C2A E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2722      GetMotorRegister(mm, RRG_RENV5, &dbgread);          //  RRG_RENV5   = 0x00E0,   RENV5 レジスタ の読み出し
    00001C2C 66E3                   MOV         R14,R6
    00001C2E 2E22                   MOV.L       R2,@R14    ; dbgread
    00001C30 64C3                   MOV         R12,R4
    00001C32 65D3                   MOV         R13,R5
    00001C34 BA18                   BSR         _GetMotorRegister
    00001C36 7D01                   ADD         #1,R13
               mnet.c       2723      dbgread = 0;
    00001C38 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2724      GetMotorRegister(mm, RRG_RENV6, &dbgread);          //  RRG_RENV6   = 0x00E1,   RENV6 レジスタ の読み出し
    00001C3A 66E3                   MOV         R14,R6
    00001C3C 2E22                   MOV.L       R2,@R14    ; dbgread
    00001C3E 64C3                   MOV         R12,R4
    00001C40 65D3                   MOV         R13,R5
    00001C42 BA11                   BSR         _GetMotorRegister
    00001C44 7D02                   ADD         #2,R13
               mnet.c       2725    //    GetMotorRegister(mm, RRG_RENV7, &dbgread);          //  RRG_RENV7   = 0x00E2,   RENV7 レジスタ の読み出し
               mnet.c       2726      dbgread = 0;
    00001C46 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2727      GetMotorRegister(mm, RRG_RCUN1, &dbgread);          //  RRG_RCUN1   = 0x00E3,   RCUN1 レジスタ の読み出し
    00001C48 66E3                   MOV         R14,R6
    00001C4A 2E22                   MOV.L       R2,@R14    ; dbgread
    00001C4C 64C3                   MOV         R12,R4
    00001C4E 65D3                   MOV         R13,R5
    00001C50 BA0A                   BSR         _GetMotorRegister
    00001C52 7D01                   ADD         #1,R13
               mnet.c       2728      dbgread = 0;
    00001C54 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2729      GetMotorRegister(mm, RRG_RCUN2, &dbgread);          //  RRG_RCUN2   = 0x00E4,   RCUN2 レジスタ の読み出し
    00001C56 66E3                   MOV         R14,R6
    00001C58 2E22                   MOV.L       R2,@R14    ; dbgread
    00001C5A 64C3                   MOV         R12,R4
    00001C5C 65D3                   MOV         R13,R5
    00001C5E BA03                   BSR         _GetMotorRegister
    00001C60 7D01                   ADD         #1,R13
               mnet.c       2730      dbgread = 0;
    00001C62 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2731      GetMotorRegister(mm, RRG_RCUN3, &dbgread);          //  RRG_RCUN3   = 0x00E5,   RCUN3 レジスタ の読み出し
    00001C64 66E3                   MOV         R14,R6
    00001C66 2E22                   MOV.L       R2,@R14    ; dbgread
    00001C68 65D3                   MOV         R13,R5
    00001C6A 64C3                   MOV         R12,R4
    00001C6C 4CF4                   MOVMU.L     @R15+,R12
    00001C6E A9FB                   BRA         _GetMotorRegister
    00001C70 0009                   NOP
    00001C72              L631:
    00001C72 00000002               .RES.W      1
    00001C74 <00000000>             .DATA.L     __$dbgread
               mnet.c       2732    
               mnet.c       2733    }
               mnet.c       2734    #endif
               mnet.c       2735    
               mnet.c       2736    //    struct
               mnet.c       2737    //    {
               mnet.c       2738    //        UH  BBSY    : 1;    // RENV0(8)= "1" でブレーク通信コマンド（0610h）を発行したとき、
               mnet.c       2739    //                                // ブレーク通信が完了するまで "1" となります。
               mnet.c       2740    //        UH  DBSY    : 1;    // システム通信中、またはデータ通信中に1 になります。
               mnet.c       2741    //        UH  RBSY    : 1;    // リセット処理中に1 になります。
               mnet.c       2742    //        UH  SBSY    : 1;    // サイクリック通信スタート中に1 になります。
               mnet.c       2743    //        UH  reserve2: 1;    // 常に0 になります。
               mnet.c       2744    //        UH  RDBB    : 1;    // データ受信用FIFO に受信データがある時に1 になります。
               mnet.c       2745    //        UH  TDBB    : 1;    // データ送信用FIFO に送信データがある時に1 になります。
               mnet.c       2746    //        UH  REF     : 1;    // 未送信の出力ポートデータがある時1 になります。
               mnet.c       2747    //        UH  reserve1: 1;    // 常に0 になります。
               mnet.c       2748    //        UH  CAER    : 1;    // CPU のアクセスエラーです。
               mnet.c       2749    //        UH  ERAE    : 1;    // ﾛｰｶﾙ側受信処理ｴﾗｰ発生時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2750    //        UH  EDTE    : 1;    // データ通信エラー発生時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2751    //        UH  EIOE    : 1;    // サイクリック通信ｴﾗｰ発生時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2752    //        UH  IOPC    : 1;    // 「入力変化割り込み設定」を1 にセットした入力ポートの状態が変化した時に1 になり、
               mnet.c       2753    //                                // 割り込み信号(INT)を出力します。
               mnet.c       2754    //        UH  BRKF    : 1;    // ブレークフレーム受信時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2755    //        UH  CEND    : 1;    // データ送信用FIFO 書き込み可能時に1 になります。
               mnet.c       2756    //    }BIT;
               mnet.c       2757    
C   00000000              __$MOTORSPD_TBL:                 ; static: __$MOTORSPD_TBL
    00000000 000007CF00             .DATA.L     H'000007CF,H'000003E7,H'0000018F,H'000000C7,H'00000063,H'00000027,H'00000013,
             0003E70000 +                       H'00000009,H'00000003,H'00000002
             018F000000   
             C700000063   
             0000002700   
             0000130000   
             0009000000   
             0300000002   
    00000028              __$MOTORSPD_TBL_PCD4611:         ; static: __$MOTORSPD_TBL_PCD4611
    00000028 00000F9F00             .DATA.L     H'00000F9F,H'0000095F,H'000004AF,H'00000257,H'000000EF,H'0000003B,H'0000001D,
             00095F0000 +                       H'0000000E,H'00000005,H'00000002
             04AF000002   
             57000000EF   
             0000003B00   
             00001D0000   
             000E000000   
             0500000002   
    00000050              __$LMMOD_TBL:                    ; static: __$LMMOD_TBL
    00000050 2020282222             .DATA.B     H'20,H'20,H'28,H'22,H'22,H'2A
             2A           
D   00000000              __$Initialized:                  ; static: __$Initialized
    00000000 00000000               .DATA.L     H'00000000
C   00000056 00000002               .RES.W      1
    00000058              L654:
    00000058 00000000               .DATA.L     H'00000000
    0000005C 00                     .DATAB.B    36,0
B   00000000              _pMotionnet:                     ; static: pMotionnet
    00000000 00000004               .RES.L      1
    00000004              _pPulseMotor:                    ; static: pPulseMotor
    00000004 00000004               .RES.L      1
    00000008              __$_pmInfo:                      ; static: __$_pmInfo
    00000008 00000004               .RES.L      500
    000007D8              __$factor:                       ; static: __$factor
    000007D8 00000004               .RES.L      1
    000007DC              __$param:                        ; static: __$param
    000007DC 00000004               .RES.L      1
    000007E0              __$RMG:                          ; static: __$RMG
    000007E0 00000004               .RES.L      1
    000007E4              __$RFL:                          ; static: __$RFL
    000007E4 00000004               .RES.L      1
    000007E8              __$RFH:                          ; static: __$RFH
    000007E8 00000004               .RES.L      1
    000007EC              __$RUR:                          ; static: __$RUR
    000007EC 00000004               .RES.L      1
    000007F0              __$RUS:                          ; static: __$RUS
    000007F0 00000004               .RES.L      1
    000007F4              __$RDS:                          ; static: __$RDS
    000007F4 00000004               .RES.L      1
    000007F8              __$pcd_rsts:                     ; static: __$pcd_rsts
    000007F8 00000004               .RES.L      1
    000007FC              __$dev_nowk:                     ; static: __$dev_nowk
    000007FC 00000001               .RES.B      1
    000007FD 00000001               .RES.B      1
    000007FE 00000002               .RES.W      1
    00000800              __$dbgread:                      ; static: __$dbgread
    00000800 00000004               .RES.L      1
SH SERIES C/C++ Compiler (V.9.02.00.003)                                                         08-Sep-2023 13:46:33  PAGE    1


******** STATISTICS INFORMATION ********


********** ERROR INFORMATION ***********

NUMBER OF ERRORS:           0
NUMBER OF WARNINGS:         0




******* SOURCE LINE INFORMATION ********

COMPILED SOURCE LINE:     2757



******* SECTION SIZE INFORMATION *******

PROGRAM  SECTION (P):                                 00001C78 Byte(s)
CONSTANT SECTION (C):                                 00000080 Byte(s)
DATA     SECTION (D):                                 00000004 Byte(s)
BSS      SECTION (B):                                 00000804 Byte(s)

TOTAL PROGRAM  SECTION: 00001C78 Byte(s)
TOTAL CONSTANT SECTION: 00000080 Byte(s)
TOTAL DATA     SECTION: 00000004 Byte(s)
TOTAL BSS      SECTION: 00000804 Byte(s)

    TOTAL PROGRAM SIZE: 00002500 Byte(s)



********** LABEL INFORMATION ***********

NUMBER OF EXTERNAL REFERENCE SYMBOLS:           12
NUMBER OF EXTERNAL DEFINITION SYMBOLS:          33
NUMBER OF INTERNAL/EXTERNAL SYMBOLS:           327



*** COMMAND PARAMETER ***

-subcommand=C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\Debug\mnet.shc
-cpu=sh2a
-include="C:\NORTi\INC","C:\NORTi\INC\Dummy","C:\NORTi\INC","C:\NORTi\LIB"
-object="C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\Debug\mnet.obj"
-debug
-listfile="C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\Debug\mnet.lst"
-show=source,tab=4
-gbr=auto
-chgincpath
-errorpath
"C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\mnet.c"
-global_volatile=0
-opt_range=all
-infinite_loop=0
-del_vacant_loop=0
-struct_alloc=1
-lang=c
-nologo
