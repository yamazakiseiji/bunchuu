SH SERIES C/C++ Compiler (V.9.02.00.003)                                                         08-Sep-2023 13:46:33  PAGE    1

************ OBJECT LISTING ************

FILE NAME: C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\n4i7237.c

SCT OFFSET   CODE       C LABEL     INSTRUCTION OPERAND    COMMENT

            n4i7237.c          1    /*******************************************************************************
            n4i7237.c          2    * 割込み管理機能/周期タイマ割込みハンドラ (SH7286)                             *
            n4i7237.c          3    *                                                                              *
            n4i7237.c          4    *  File name : n4i7286.c                                                       *
            n4i7237.c          5    *  Copyright (c) 2010, MiSPO Co., Ltd.                                         *
            n4i7237.c          6    *                                                                              *
            n4i7237.c          7    *  Compile : shc -cp=sh2a -op=1 -def=CLK=?,CH=?,MSEC=?,INTVEC=?,INTVSZ=?,      *
            n4i7237.c          8    *                 IP=? n4i7286.c                                   (Renesas C) *
            n4i7237.c          9    *                                                                              *
            n4i7237.c         10    * 2010-10-29 Created                                                        SZ *
            n4i7237.c         11    *                                                                              *
            n4i7237.c         12    * 2017/09〜   ハンドラ追加                                                       *
            n4i7237.c         13    *             優先順位変更                                                       *
            n4i7237.c         14    *             タイマ値変更                                                       *
            n4i7237.c         15    *                                                                              *
            n4i7237.c         16    *******************************************************************************/
            n4i7237.c         17    
            n4i7237.c         18    /*
            n4i7237.c         19    
            n4i7237.c         20    最適化コンパイル
            n4i7237.c         21    
            n4i7237.c         22              割り込みハンドラのコンパイルには、必ず、最適化オプションを付け、
            n4i7237.c         23              ent_int 呼び出し前に、不要な命令が生成されないよう注意してください。
            n4i7237.c         24              ルネサスCでは、割込みハンドラを #pragma interrupt で定義してください。
            n4i7237.c         25    
            n4i7237.c         26    
            n4i7237.c         27    割込み周期の指定
            n4i7237.c         28    
            n4i7237.c         29              割込み周期は、MSEC マクロで決まります。 デフォルト値は kernel.hで
            n4i7237.c         30              定義しており、10 msec です。
            n4i7237.c         31              割込み周期を変更する場合は、全てのファイルに対してMSECマクロを変更
            n4i7237.c         32              するようにコンパイルしてください。
            n4i7237.c         33    
            n4i7237.c         34              (例) shc <options> -def=MSEC=5 FILE … 5 msec
            n4i7237.c         35                                      ~~~~~~
            n4i7237.c         36    
            n4i7237.c         37    割込みベクタテーブル
            n4i7237.c         38    
            n4i7237.c         39              def_inhシステムコールによる割込みベクタの設定を可能にするため、
            n4i7237.c         40              RAM先頭(0C000000H番地から1024バイト)に、割込みベクタテーブルがあると
            n4i7237.c         41              想定しています。
            n4i7237.c         42              割込みベクタテーブルの領域が、他の領域と重ならない様にリンクしてく
            n4i7237.c         43              ださい。(重なってもリンカで警告は出ません!)
            n4i7237.c         44              割込みベクタテーブルの先頭アドレスはINTVECマクロで変更できます。
            n4i7237.c         45              割込みベクタテーブルのサイズ(バイト数)は、INTVSZマクロで変更できます。
            n4i7237.c         46    
            n4i7237.c         47              (例) shc <op> -def=INTVEC=0,INTVSZ=408 n4iXXX.c … 0番地,408バイト
            n4i7237.c         48                                 ~~~~~~~~ ~~~~~~~~~~
            n4i7237.c         49              割込みベクタテーブルがROM上にあり、def_inhに依らず直接ベクタを定義
            n4i7237.c         50              する場合、INTVEC=0, INTVSZ=0としてください。この場合、def_inhシステ
            n4i7237.c         51              ムコールは機能しません。
            n4i7237.c         52    
            n4i7237.c         53    
            n4i7237.c         54    チャネル番号の指定
            n4i7237.c         55    
            n4i7237.c         56              周期タイマ割込みに使用している内蔵CMTのチャネルをCHマクロで指定で
            n4i7237.c         57              きます。(0〜1, 無指定時は、CH=0)
            n4i7237.c         58    
            n4i7237.c         59              (例) shc <options> -def=CH=1 n4iXXX.c  .......... CMT CH1
            n4i7237.c         60                                      ~~~~
            n4i7237.c         61    
            n4i7237.c         62    クロック周波数の指定
            n4i7237.c         63    
            n4i7237.c         64              本ソースのクロック(Pφ)のデフォルトは49.152 MHz です。変更する場合は
            n4i7237.c         65              CLKマクロを定義してコンパイルしてください。値は[Hz]単位の周波数です。
            n4i7237.c         66    
            n4i7237.c         67              (例) shc <options> -def=CLK=25000000 n4iXXX.c ……… 25 MHz
            n4i7237.c         68                                      ~~~~~~~~~~~~
            n4i7237.c         69    
            n4i7237.c         70    dis_int, ena_int
            n4i7237.c         71    
            n4i7237.c         72              SHシリーズの割込みコントローラでは、汎用的なdis_int, ena_intシステ
            n4i7237.c         73              ムコールの実装が複雑となってしまいます。
            n4i7237.c         74              この２つのシステムコールは用意していませんので、個別の割込み禁止許
            n4i7237.c         75              可を行いたい場合は、各制御レジスタを直接アクセスしてください。
            n4i7237.c         76    
            n4i7237.c         77    
            n4i7237.c         78    _kernel_inROM
            n4i7237.c         79    
            n4i7237.c         80              与えられたアドレスがROM領域か否かを返す関数です。ROM領域であれば
            n4i7237.c         81              TRUE(1), ROM領域でなければ FALSE(0) を返します。
            n4i7237.c         82    
            n4i7237.c         83    
            n4i7237.c         84    割込み優先順位
            n4i7237.c         85    
            n4i7237.c         86              周期タイマ割込みハンドラのデフォルトの割込み優先順位は、7 です。
            n4i7237.c         87              これを変更する場合、IP マクロを定義してコンパイルしてください。
            n4i7237.c         88              ただし、カーネルより高優先にはできません。 (IP ≦ KNL_LEVEL)
            n4i7237.c         89              本ハンドラより高優先度の割込みハンドラが有る場合、多重割込みが
            n4i7237.c         90              起こります。
            n4i7237.c         91    
            n4i7237.c         92              (例) shc <options> -def=IP=2 n4iXXX.c ... 割込み優先順位 2
            n4i7237.c         93                                      ~~~~
            n4i7237.c         94    */
            n4i7237.c         95    
            n4i7237.c         96    #include "kernel.h"
            n4i7237.c         97    #include "nosys4.h"
            n4i7237.c         98    #include "sh7237.h"
            n4i7237.c         99    #include "iodefine.h"
            n4i7237.c        100    #include "hdrsio0.h"
            n4i7237.c        101    #include "define.h"
            n4i7237.c        102    
            n4i7237.c        103    /* 割込みベクタテーブル */
            n4i7237.c        104    
            n4i7237.c        105    #ifndef INTVSZ
            n4i7237.c        106    #define INTVSZ      1024        /* サイズ未定義の場合 */
            n4i7237.c        107    #endif
            n4i7237.c        108    
            n4i7237.c        109    /* 割込み優先順位の定義 */
            n4i7237.c        110    
            n4i7237.c        111    #ifndef IP
            n4i7237.c        112    #define IP      7               /* 割込み優先順位未定義の場合 */
            n4i7237.c        113    #endif
            n4i7237.c        114    
            n4i7237.c        115    /* クロックの定義 */
            n4i7237.c        116    
            n4i7237.c        117    #ifndef CLK
            n4i7237.c        118    #define CLK     40000000L     /* 周辺クロックPck0[Hz] */
            n4i7237.c        119    #endif
            n4i7237.c        120    
            n4i7237.c        121    /* チャネル番号の定義 */
            n4i7237.c        122    
            n4i7237.c        123    #ifndef CH
            n4i7237.c        124    #define CH      0               /* チャネル番号未定義の場合 */
            n4i7237.c        125    #endif
            n4i7237.c        126    
            n4i7237.c        127    /* CHに合わせたCMTレジスタの再定義 */
            n4i7237.c        128    
            n4i7237.c        129    #if (CH==0)
            n4i7237.c        130    #define CMT_CMCSR   CMT_CMCSR_0
            n4i7237.c        131    #define CMT_CMCNT   CMT_CMCNT_0
            n4i7237.c        132    #define CMT_CMCOR   CMT_CMCOR_0
            n4i7237.c        133    #define INT_CMT     INT_CMI0
            n4i7237.c        134    #elif (CH==1)
            n4i7237.c        135    #define CMT_CMCSR   CMT_CMCSR_1
            n4i7237.c        136    #define CMT_CMCNT   CMT_CMCNT_1
            n4i7237.c        137    #define CMT_CMCOR   CMT_CMCOR_1
            n4i7237.c        138    #define INT_CMT     INT_CMI1
            n4i7237.c        139    #else
            n4i7237.c        140    #error illegal CH number! (CH = 0 to 1)
            n4i7237.c        141    #endif
            n4i7237.c        142    
            n4i7237.c        143    /* 処理系の差異の調整 */
            n4i7237.c        144    
            n4i7237.c        145    #if defined(__HITACHI__)        /* Renesas C */
            n4i7237.c        146    #include <machine.h>
            n4i7237.c        147    extern int *_C_BGN, *_C_END, *_P_BGN, *_P_END, *_VECT_BGN;
            n4i7237.c        148    #if (INTVSZ==0)
            n4i7237.c        149    #pragma interrupt(inthdr(resbank))
            n4i7237.c        150    #pragma ifunc(inthdr)
            n4i7237.c        151    #pragma interrupt(int_sio0_rx(resbank))
            n4i7237.c        152    #pragma ifunc(int_sio0_rx)                
            n4i7237.c        153    #pragma interrupt(int_sio0_er(resbank))
            n4i7237.c        154    #pragma ifunc(int_sio0_er)                
            n4i7237.c        155    
            n4i7237.c        156    #pragma interrupt(int_sio1_rx(resbank))
            n4i7237.c        157    #pragma ifunc(int_sio1_rx)                
            n4i7237.c        158    #pragma interrupt(int_sio1_er(resbank))
            n4i7237.c        159    #pragma ifunc(int_sio1_er)                
            n4i7237.c        160    
            n4i7237.c        161    #pragma interrupt(int_sio2_rx(resbank))
            n4i7237.c        162    #pragma ifunc(int_sio2_rx)                
            n4i7237.c        163    #pragma interrupt(int_sio2_er(resbank))
            n4i7237.c        164    #pragma ifunc(int_sio2_er)                
            n4i7237.c        165    
            n4i7237.c        166    // 5/11 #pragma interrupt(int_sio3_rx(resbank))
            n4i7237.c        167    // 5/11 #pragma ifunc(int_sio3_rx)                
            n4i7237.c        168    // 5/11 #pragma interrupt(int_sio3_er(resbank))
            n4i7237.c        169    // 5/11 #pragma ifunc(int_sio3_er)                
            n4i7237.c        170    
            n4i7237.c        171    #endif
            n4i7237.c        172    
            n4i7237.c        173    #elif defined(__ghs)            /* Green Hills */
            n4i7237.c        174    #include <machine.h>
            n4i7237.c        175    extern char __ghsbegin_rodata[], __ghsend_rodata[];
            n4i7237.c        176    extern char __ghsbegin_text[], __ghsend_text[];
            n4i7237.c        177    extern char __ghsbegin_vect[];
            n4i7237.c        178    #endif
            n4i7237.c        179    
            n4i7237.c        180    /* Tick入力積算カウンタ */
            n4i7237.c        181    
            n4i7237.c        182    #ifdef HOOK
            n4i7237.c        183    UW TOTAL_TICKCK;
            n4i7237.c        184    UW TICK_RATE;
            n4i7237.c        185    #endif
            n4i7237.c        186    
            n4i7237.c        187    /* 外部参照 */
            n4i7237.c        188    
            n4i7237.c        189    extern void _kernel_interr(void);
            n4i7237.c        190    void init_timer(void);
            n4i7237.c        191    
            n4i7237.c        192    /* 割込みサービスルーチン生成情報 */
            n4i7237.c        193    
            n4i7237.c        194    #if (INTVSZ!=0)
            n4i7237.c        195    void isritm(VP_INT exinf);
            n4i7237.c        196    const T_CISR disr_isritm = { TA_HLNG, NULL, INT_CMT, (FP)isritm, 0 };
            n4i7237.c        197    #else
            n4i7237.c        198    void isritm(void);
            n4i7237.c        199    #endif
            n4i7237.c        200    
            n4i7237.c        201    #if 1
            n4i7237.c        202    #define   CPU_CLOCK       160000000               // CPUクロック  [Hz]
            n4i7237.c        203    #define   PFAI_CLOCK      (CPU_CLOCK/4)           // Pφクロック  [Hz]
            n4i7237.c        204    #define   CMT0_CLOCK          (PFAI_CLOCK/8)      // CMT0カウントクロック [Hz]
            n4i7237.c        205    #define   CMT0_COUNT_1MS      (CMT0_CYCLE_1000US*(CMT0_CLOCK/1000000))
            n4i7237.c        206                                                  // CMT0の設定周期に対するカウント値
            n4i7237.c        207    #define   CMT0_CYCLE_1000US   1000                // CMT0の割り込み周期   [us]
            n4i7237.c        208    #endif
            n4i7237.c        209    
            n4i7237.c        210    /*****************************************************************************
            n4i7237.c        211    * 割込み初期化
            n4i7237.c        212    *
            n4i7237.c        213    * 形式  ER intini(void);
            n4i7237.c        214    *
            n4i7237.c        215    * 戻値  常に E_OK
            n4i7237.c        216    *
            n4i7237.c        217    * 解説  カーネルの初期化ルーチン sysini から割込み禁止状態で呼び出されます。
            n4i7237.c        218    ******************************************************************************/
            n4i7237.c        219    
            n4i7237.c        220    
            n4i7237.c        221    ER intini(void)
P   00000000              _intini:                         ; function: intini
                                                           ; frame size=12
    00000000 4F22                   STS.L       PR,@-R15
    00000002 7FF8                   ADD         #-8,R15
            n4i7237.c        222    {
            n4i7237.c        223      #ifndef INTVEC
            n4i7237.c        224       #if defined(__ghs)               /* Green Hills */
            n4i7237.c        225        UW *intvec = (UW *)__ghsbegin_vect;
            n4i7237.c        226       #elif defined(__HITACHI__)       /* Renesas C */
            n4i7237.c        227        UW *intvec = (UW *)_VECT_BGN;
    00000004 D177                   MOV.L       L47+2,R1   ; __VECT_BGN
            n4i7237.c        228       #endif
            n4i7237.c        229      #else
            n4i7237.c        230        UW *intvec = (UW *)INTVEC;
            n4i7237.c        231      #endif
            n4i7237.c        232    
            n4i7237.c        233      #if (INTVSZ!=0)
            n4i7237.c        234        int i;
            n4i7237.c        235    
            n4i7237.c        236        /* 割込みベクタテーブルの初期化 */
            n4i7237.c        237    
            n4i7237.c        238        for (i = INT_IRQ0; i < (INTVSZ) / 4; i++)
    00000006 E6C0                   MOV         #-64,R6    ; H'FFFFFFC0
    00000008 6412                   MOV.L       @R1,R4     ; _VECT_BGN
    0000000A 666C                   EXTU.B      R6,R6
    0000000C 6163                   MOV         R6,R1
    0000000E 7140                   ADD         #64,R1
    00000010 6243                   MOV         R4,R2
    00000012 321C                   ADD         R1,R2
    00000014 D074                   MOV.L       L47+6,R0   ; __kernel_interr
    00000016 2F42                   MOV.L       R4,@R15    ; intvec
    00000018              L11:
    00000018 4610                   DT          R6
            n4i7237.c        239            intvec[i] = (UW)_kernel_interr;
    0000001A 8FFD                   BF/S        L11
    0000001C 42AB                   MOV.L       R0,@R2+    ; intvec[]
            n4i7237.c        240      #endif
            n4i7237.c        241    
            n4i7237.c        242        /* ベクタベースレジスタを設定 */
            n4i7237.c        243    
            n4i7237.c        244        set_vbr((void **)intvec);
    0000001E E601                   MOV         #1,R6      ; H'00000001
    00000020 4618                   SHLL8       R6
    00000022 1F61                   MOV.L       R6,@(4,R15); i
    00000024 442E                   LDC         R4,VBR
            n4i7237.c        245    
            n4i7237.c        246        /* 全ての割込み対してレジスタバンクを有効にする */
            n4i7237.c        247    
            n4i7237.c        248        sfr_outw(INTC_IBNR, 0x4000);
    00000026 E540                   MOV         #64,R5     ; H'00000040
    00000028 00E0080E               MOVI20      #-129010,R0; H'FFFE080E
    0000002C E200                   MOV         #0,R2      ; H'00000000
    0000002E 4518                   SHLL8       R5
            n4i7237.c        249    
            n4i7237.c        250      #ifdef HOOK
            n4i7237.c        251        TOTAL_TICKCK = 0;
            n4i7237.c        252      #endif
            n4i7237.c        253        init_timer();
    00000030 B046                   BSR         _init_timer
    00000032 0255                   MOV.W       R5,@(R0,R2)
            n4i7237.c        254    
            n4i7237.c        255        return E_OK;
    00000034 7F08                   ADD         #8,R15
    00000036 4F26                   LDS.L       @R15+,PR
            n4i7237.c        256    }
    00000038 000B                   RTS
    0000003A E000                   MOV         #0,R0      ; H'00000000
            n4i7237.c        257    
            n4i7237.c        258    /*****************************************************************************
            n4i7237.c        259    * 定数か否かをチェックする
            n4i7237.c        260    *
            n4i7237.c        261    * 形式  BOOL _kernel_inROM(const void *p);
            n4i7237.c        262    *
            n4i7237.c        263    *       p     チェックする領域へのポインタ
            n4i7237.c        264    *
            n4i7237.c        265    * 戻値  TRUE  コード領域または定数領域
            n4i7237.c        266    *       FALSE 上記以外
            n4i7237.c        267    *
            n4i7237.c        268    * 解説  オブジェクト生成情報等が定数か変数かを判定するために、カーネルの各種
            n4i7237.c        269    *       システムコールから呼び出されます。
            n4i7237.c        270    ******************************************************************************/
            n4i7237.c        271    
            n4i7237.c        272    BOOL _kernel_inROM(const void *p)
    0000003C              __kernel_inROM:                  ; function: _kernel_inROM
                                                           ; frame size=0
    0000003C D56B                   MOV.L       L47+10,R5  ; __P_BGN
    0000003E 6652                   MOV.L       @R5,R6     ; _P_BGN
            n4i7237.c        273    {
            n4i7237.c        274    #if defined(__HITACHI__)      /* Renesas C */
            n4i7237.c        275        return((((UW)p >= (UW)_P_BGN) && ((UW)p <= (UW)_P_END)) || (((UW)p >= (UW)_C_BGN) && ((UW)p <= (UW)_C_END)));
    00000040 3462                   CMP/HS      R6,R4
    00000042 8F04                   BF/S        L15
    00000044 E201                   MOV         #1,R2      ; H'00000001
    00000046 D56A                   MOV.L       L47+14,R5  ; __P_END
    00000048 6652                   MOV.L       @R5,R6     ; _P_END
    0000004A 3466                   CMP/HI      R6,R4
    0000004C 8B08                   BF          L16
    0000004E              L15:
    0000004E D569                   MOV.L       L47+18,R5  ; __C_BGN
    00000050 6652                   MOV.L       @R5,R6     ; _C_BGN
    00000052 3462                   CMP/HS      R6,R4
    00000054 8B03                   BF          L18
    00000056 D568                   MOV.L       L47+22,R5  ; __C_END
    00000058 6652                   MOV.L       @R5,R6     ; _C_END
    0000005A 3466                   CMP/HI      R6,R4
    0000005C 8B00                   BF          L16
    0000005E              L18:
    0000005E E200                   MOV         #0,R2      ; H'00000000
    00000060              L16:
            n4i7237.c        276    
            n4i7237.c        277    #elif defined(__ghs)            /* Green Hills */
            n4i7237.c        278        return((((UW)p >= (UW)__ghsbegin_text) && ((UW)p <= (UW)__ghsend_text)) || (((UW)p >= (UW)__ghsbegin_rodata) && ((UW)p <= (UW)__ghsend_rodata)));
            n4i7237.c        279    
            n4i7237.c        280    #endif
            n4i7237.c        281    }
    00000060 027B                   RTV/N       R2
            n4i7237.c        282    
            n4i7237.c        283    /*****************************************************************************
            n4i7237.c        284    * 割込みサービスルーチン生成情報のチェック
            n4i7237.c        285    *
            n4i7237.c        286    * 形式  ER _kernel_check_cisr(const T_CISR *pk_cisr);
            n4i7237.c        287    *
            n4i7237.c        288    *       pk_cisr  チェックする割込みサービスルーチン生成情報へのポインタ
            n4i7237.c        289    *
            n4i7237.c        290    * 戻値  E_PAR 割込み番号とマスクレベルのいずれかが範囲外
            n4i7237.c        291    *       E_OK  割込み番号とマスクレベルは共に正常
            n4i7237.c        292    *
            n4i7237.c        293    * 解説  割込みサービスルーチン生成情報の割込み番号とマスクレベルの範囲を
            n4i7237.c        294    *       チェックします。
            n4i7237.c        295    *       cre_isr, acre_isr システムコールから呼び出されます。
            n4i7237.c        296    ******************************************************************************/
            n4i7237.c        297    
            n4i7237.c        298    ER _kernel_check_cisr(const T_CISR *pk_cisr)
    00000062              __kernel_check_cisr:             ; function: _kernel_check_cisr
                                                           ; frame size=0
            n4i7237.c        299    {
            n4i7237.c        300      #if (INTVSZ!=0)
            n4i7237.c        301        if (pk_cisr->intno >= (INTVSZ) / 4)
    00000062 5242                   MOV.L       @(8,R4),R2 ; (pk_cisr)->intno
    00000064 E601                   MOV         #1,R6      ; H'00000001
    00000066 4618                   SHLL8       R6
    00000068 3262                   CMP/HS      R6,R2
    0000006A 8F01                   BF/S        L21
    0000006C E000                   MOV         #0,R0      ; H'00000000
            n4i7237.c        302            return E_PAR;
    0000006E E0EF                   MOV         #-17,R0    ; H'FFFFFFEF
    00000070              L21:
            n4i7237.c        303        return E_OK;
            n4i7237.c        304      #else
            n4i7237.c        305        return E_PAR;
            n4i7237.c        306      #endif
            n4i7237.c        307    }
    00000070 006B                   RTS/N
            n4i7237.c        308    
            n4i7237.c        309    /*****************************************************************************
            n4i7237.c        310    * 割込みハンドラのアドレス設定
            n4i7237.c        311    *
            n4i7237.c        312    * 形式  void _kernel_set_inthdr(FP hdr, const T_CISR *pk_cisr);
            n4i7237.c        313    *
            n4i7237.c        314    *       hdr       割込みサービスルーチンを呼び出す割込みハンドラのアドレス
            n4i7237.c        315    *       pk_cisr   チェックする割込みサービスルーチン生成情報へのポインタ
            n4i7237.c        316    *
            n4i7237.c        317    * 解説  割込みサービスルーチンを呼び出すために、内部で生成される割込みハンド
            n4i7237.c        318    *       ラのアドレスを、割込みサービスルーチン生成情報の割込み番号より算出し
            n4i7237.c        319    *       た割込みベクタへ格納します。
            n4i7237.c        320    *       cre_isr, acre_isr システムコールから呼び出されます。
            n4i7237.c        321    ******************************************************************************/
            n4i7237.c        322    
            n4i7237.c        323    void _kernel_set_inthdr(FP hdr, const T_CISR *pk_cisr)
    00000072              __kernel_set_inthdr:             ; function: _kernel_set_inthdr
                                                           ; frame size=0
            n4i7237.c        324    {
            n4i7237.c        325      #ifndef INTVEC
            n4i7237.c        326       #if defined(__ghs)               /* Green Hills */
            n4i7237.c        327        UW *intvec = (UW *)__ghsbegin_vect;
            n4i7237.c        328       #elif defined(__HITACHI__)       /* Renesas C */
            n4i7237.c        329        UW *intvec = (UW *)_VECT_BGN;
            n4i7237.c        330       #endif
            n4i7237.c        331      #else
            n4i7237.c        332        UW *intvec = (UW *)INTVEC;
            n4i7237.c        333      #endif
            n4i7237.c        334    
            n4i7237.c        335        intvec[pk_cisr->intno] = (UW)hdr;
    00000072 5052                   MOV.L       @(8,R5),R0 ; (pk_cisr)->intno
    00000074 D15B                   MOV.L       L47+2,R1   ; __VECT_BGN
    00000076 6612                   MOV.L       @R1,R6     ; _VECT_BGN
    00000078 4008                   SHLL2       R0
            n4i7237.c        336    }
    0000007A 000B                   RTS
    0000007C 0646                   MOV.L       R4,@(R0,R6); intvec[]
            n4i7237.c        337    
            n4i7237.c        338    /*****************************************************************************
            n4i7237.c        339    * 割込みハンドラのアドレス取得
            n4i7237.c        340    *
            n4i7237.c        341    * 形式  FP _kernel_get_inthdr(const T_CISR *pk_cisr);
            n4i7237.c        342    *
            n4i7237.c        343    *       pk_cisr  チェックする割込みサービスルーチン生成情報へのポインタ
            n4i7237.c        344    *
            n4i7237.c        345    * 戻値  当該割込み番号の割込みハンドラアドレス
            n4i7237.c        346    *
            n4i7237.c        347    * 解説  割込みサービスルーチン生成情報の割込み番号より算出した割込みベクタか
            n4i7237.c        348    *       ら、割込みハンドラアドレスを読み出します。
            n4i7237.c        349    *       cre_isr, acre_isr システムコールから呼び出されます。
            n4i7237.c        350    ******************************************************************************/
            n4i7237.c        351    
            n4i7237.c        352    FP _kernel_get_inthdr(const T_CISR *pk_cisr)
    0000007E              __kernel_get_inthdr:             ; function: _kernel_get_inthdr
                                                           ; frame size=0
            n4i7237.c        353    {
            n4i7237.c        354      #ifndef INTVEC
            n4i7237.c        355       #if defined(__ghs)               /* Green Hills */
            n4i7237.c        356        UW *intvec = (UW *)__ghsbegin_vect;
            n4i7237.c        357       #elif defined(__HITACHI__)       /* Renesas C */
            n4i7237.c        358        UW *intvec = (UW *)_VECT_BGN;
            n4i7237.c        359       #endif
            n4i7237.c        360      #else
            n4i7237.c        361        UW *intvec = (UW *)INTVEC;
            n4i7237.c        362      #endif
            n4i7237.c        363    
            n4i7237.c        364        return (FP)intvec[pk_cisr->intno];
    0000007E 5042                   MOV.L       @(8,R4),R0 ; (pk_cisr)->intno
    00000080 D658                   MOV.L       L47+2,R6   ; __VECT_BGN
    00000082 6562                   MOV.L       @R6,R5     ; _VECT_BGN
    00000084 4008                   SHLL2       R0
            n4i7237.c        365    }
    00000086 000B                   RTS
    00000088 005E                   MOV.L       @(R0,R5),R0; intvec[]
            n4i7237.c        366    
            n4i7237.c        367    /*****************************************************************************
            n4i7237.c        368    * 割込みハンドラを定義する
            n4i7237.c        369    *
            n4i7237.c        370    * 形式  ER def_inh(UINT inhno, const T_DINH *pk_dinh);
            n4i7237.c        371    *
            n4i7237.c        372    *       inhno    割込みベクタ番号
            n4i7237.c        373    *       pk_dinh  割込みハンドラ定義情報
            n4i7237.c        374    *
            n4i7237.c        375    * 戻値  エラーコード
            n4i7237.c        376    *
            n4i7237.c        377    * 解説  inhno に対応する割込みベクタテーブルに、inthdr を設定します。
            n4i7237.c        378    ******************************************************************************/
            n4i7237.c        379    
            n4i7237.c        380    ER v4_def_inh(INHNO inhno, const V4_T_DINH *pk_dinh)
    0000008A              _v4_def_inh:                     ; function: v4_def_inh
                                                           ; frame size=16
    0000008A 4CF0                   MOVMU.L     R12,@-R15
            n4i7237.c        381    {
            n4i7237.c        382      #if (INTVSZ==0)
            n4i7237.c        383    
            n4i7237.c        384        return E_NOSPT;
            n4i7237.c        385    
            n4i7237.c        386      #else
            n4i7237.c        387    
            n4i7237.c        388        UINT psw;
            n4i7237.c        389        FP fp;
            n4i7237.c        390      #ifndef INTVEC
            n4i7237.c        391       #if defined(__ghs)               /* Green Hills */
            n4i7237.c        392        UW *intvec = (UW *)__ghsbegin_vect;
            n4i7237.c        393       #elif defined(__HITACHI__)       /* Renesas C */
            n4i7237.c        394        UW *intvec = (UW *)_VECT_BGN;
            n4i7237.c        395       #endif
            n4i7237.c        396      #else
            n4i7237.c        397        UW *intvec = (UW *)INTVEC;
            n4i7237.c        398      #endif
            n4i7237.c        399    
            n4i7237.c        400        /* 割込みベクタテーブルへのポインタ算出 */
            n4i7237.c        401    
            n4i7237.c        402        if (inhno >= (INTVSZ) / 4)
    0000008C E601                   MOV         #1,R6      ; H'00000001
    0000008E 6E43                   MOV         R4,R14
    00000090 4618                   SHLL8       R6
    00000092 D254                   MOV.L       L47+2,R2   ; __VECT_BGN
    00000094 3462                   CMP/HS      R6,R4
    00000096 8F02                   BF/S        L26
    00000098 6D22                   MOV.L       @R2,R13    ; _VECT_BGN
            n4i7237.c        403            return E_PAR;
    0000009A A00F                   BRA         L27
    0000009C E0EF                   MOV         #-17,R0    ; H'FFFFFFEF
    0000009E              L26:
            n4i7237.c        404    
            n4i7237.c        405        /* 定義解除の場合、未定義割込みハンドラを設定 */
            n4i7237.c        406    
            n4i7237.c        407        if (pk_dinh == (T_DINH *)NADR)
    0000009E 2558                   TST         R5,R5
    000000A0 8B02                   BF          L29
            n4i7237.c        408            fp = (FP)_kernel_interr;
    000000A2 DC51                   MOV.L       L47+6,R12  ; __kernel_interr
    000000A4 A001                   BRA         L30
    000000A6 0009                   NOP
    000000A8              L29:
            n4i7237.c        409        else
            n4i7237.c        410            fp = pk_dinh->inthdr;
    000000A8 5C51                   MOV.L       @(4,R5),R12; (pk_dinh)->inthdr
    000000AA              L30:
            n4i7237.c        411    
            n4i7237.c        412        /* CPU割込み禁止 */
            n4i7237.c        413    
            n4i7237.c        414        psw = vdis_psw();
    000000AA D154                   MOV.L       L47+26,R1  ; _v3_vdis_psw
    000000AC 414B                   JSR/N       @R1
            n4i7237.c        415    
            n4i7237.c        416        /* 新しい割込みベクタ設定 */
            n4i7237.c        417    
            n4i7237.c        418        intvec[inhno] = (UW)fp;
    000000AE 4E08                   SHLL2       R14
    000000B0 6403                   MOV         R0,R4
    000000B2 60E3                   MOV         R14,R0
            n4i7237.c        419    
            n4i7237.c        420        /* CPU割込み禁止戻す */
            n4i7237.c        421    
            n4i7237.c        422        vset_psw(psw);
    000000B4 D552                   MOV.L       L47+30,R5  ; _v3_vset_psw
    000000B6 450B                   JSR         @R5
    000000B8 0DC6                   MOV.L       R12,@(R0,R13); intvec[]
            n4i7237.c        423        return E_OK;
    000000BA E000                   MOV         #0,R0      ; H'00000000
    000000BC              L27:
    000000BC 4CF4                   MOVMU.L     @R15+,R12
            n4i7237.c        424    
            n4i7237.c        425      #endif
            n4i7237.c        426    }
    000000BE 006B                   RTS/N
            n4i7237.c        427    
            n4i7237.c        428    /*****************************************************************************
            n4i7237.c        429    * 周期タイマ割込み起動 (内蔵CMT)
            n4i7237.c        430    *
            n4i7237.c        431    * 形式  ER intsta(void);
            n4i7237.c        432    *
            n4i7237.c        433    * 戻値  エラーコード
            n4i7237.c        434    *
            n4i7237.c        435    * 補足  割込み禁止状態で実行してください。
            n4i7237.c        436    ******************************************************************************/
            n4i7237.c        437    
            n4i7237.c        438    static UW tc;
            n4i7237.c        439    static UH cks;
            n4i7237.c        440    
            n4i7237.c        441    void init_timer(void)
    000000C0              _init_timer:                     ; function: init_timer
                                                           ; frame size=24
    000000C0 2FD6                   MOV.L       R13,@-R15
    000000C2 2FE6                   MOV.L       R14,@-R15
    000000C4 7FF0                   ADD         #-16,R15
            n4i7237.c        442    {
            n4i7237.c        443        UW prescale[] = { 8, 32, 128, 512 };
    000000C6 D44F                   MOV.L       L47+34,R4  ; L48
    000000C8 6142                   MOV.L       @R4,R1
    000000CA EEFF                   MOV         #-1,R14    ; H'FFFFFFFF
    000000CC 5541                   MOV.L       @(4,R4),R5
    000000CE 6EED                   EXTU.W      R14,R14
    000000D0 5642                   MOV.L       @(8,R4),R6
    000000D2 ED03                   MOV         #3,R13     ; H'00000003
    000000D4 5243                   MOV.L       @(12,R4),R2
            n4i7237.c        444        /* 時定数を計算 */
            n4i7237.c        445    
            n4i7237.c        446        for (cks = 0; cks <= 3; cks++) {
    000000D6 E400                   MOV         #0,R4      ; H'00000000
    000000D8 2F12                   MOV.L       R1,@R15    ; prescale[]
    000000DA 1F51                   MOV.L       R5,@(4,R15); prescale[]
    000000DC 65F3                   MOV         R15,R5
    000000DE 1F62                   MOV.L       R6,@(8,R15); prescale[]
    000000E0 1F23                   MOV.L       R2,@(12,R15); prescale[]
    000000E2 D149                   MOV.L       L47+38,R1  ; H'17D78400
    000000E4 070003E8               MOVI20      #1000,R7   ; H'000003E8
    000000E8              L32:
            n4i7237.c        447            tc = (((UW)(CLK) * MSEC)/((UW)prescale[cks] * 1000)) - 1;
    000000E8 6252                   MOV.L       @R5,R2     ; prescale[]
    000000EA 6073                   MOV         R7,R0
    000000EC 6613                   MOV         R1,R6
    000000EE 4280                   MULR        R0,R2
    000000F0 6023                   MOV         R2,R0
    000000F2 4684                   DIVU        R0,R6
    000000F4 76FF                   ADD         #-1,R6
            n4i7237.c        448            if (tc <= 0xffffL)
    000000F6 36E6                   CMP/HI      R14,R6
    000000F8 8905                   BT          L34
    000000FA D744                   MOV.L       L47+42,R7  ; __$tc
    000000FC DE44                   MOV.L       L47+46,R14 ; __$cks
    000000FE 2762                   MOV.L       R6,@R7     ; tc
    00000100 624D                   EXTU.W      R4,R2
    00000102 A009                   BRA         L35
    00000104 2E41                   MOV.W       R4,@R14    ; cks
    00000106              L34:
    00000106 7401                   ADD         #1,R4
    00000108 624D                   EXTU.W      R4,R2
    0000010A 32D7                   CMP/GT      R13,R2
    0000010C 8FEC                   BF/S        L32
    0000010E 7504                   ADD         #4,R5
    00000110 D13E                   MOV.L       L47+42,R1  ; __$tc
    00000112 D73F                   MOV.L       L47+46,R7  ; __$cks
    00000114 2162                   MOV.L       R6,@R1     ; tc
    00000116 2741                   MOV.W       R4,@R7     ; cks
    00000118              L35:
            n4i7237.c        449                break;
            n4i7237.c        450        }
            n4i7237.c        451    
            n4i7237.c        452      #ifdef HOOK
            n4i7237.c        453        TICK_RATE = 0;
            n4i7237.c        454      #endif
            n4i7237.c        455        if (cks > 3 || tc == 0L)
    00000118 32D7                   CMP/GT      R13,R2
    0000011A 8918                   BT          L38
    0000011C 2668                   TST         R6,R6
    0000011E 8916                   BT          L38
    00000120 0EE0040C               MOVI20      #-130036,R14; H'FFFE040C
            n4i7237.c        456            return; /* エラー */
            n4i7237.c        457    
            n4i7237.c        458        /* タイマユニット初期化 */
            n4i7237.c        459    
            n4i7237.c        460        sfr_clr(STBCR4, 0x4);           /* CMTへのクロック供給 */
    00000124 E500                   MOV         #0,R5      ; H'00000000
    00000126 6253                   MOV         R5,R2
    00000128 0DE0C000               MOVI20      #-81920,R13; H'FFFEC000
    0000012C 32EC                   ADD         R14,R2
            n4i7237.c        461        sfr_clrw(CMT_CMSTR, 0x01 << CH);/* カウント一旦停止 */
    0000012E 6653                   MOV         R5,R6
    00000130 6120                   MOV.B       @R2,R1
    00000132 36DC                   ADD         R13,R6
            n4i7237.c        462        sfr_outw(CMT_CMCOR, (UH)(-1));  /* 比較値 */
    00000134 00E0C006               MOVI20      #-81914,R0 ; H'FFFEC006
    00000138 E7FF                   MOV         #-1,R7     ; H'FFFFFFFF
    0000013A 8612                   BCLR        #2,R1
    0000013C 2210                   MOV.B       R1,@R2
    0000013E 6261                   MOV.W       @R6,R2
    00000140 8620                   BCLR        #0,R2
    00000142 2621                   MOV.W       R2,@R6
    00000144 0575                   MOV.W       R7,@(R0,R5)
            n4i7237.c        463        sfr_outw(CMT_CMCSR, cks);       /* クロック選択 */
    00000146 70FC                   ADD         #-4,R0
    00000148 0545                   MOV.W       R4,@(R0,R5)
            n4i7237.c        464        sfr_outw(CMT_CMCNT, 0x00);      /* カウンタクリア */
    0000014A 7002                   ADD         #2,R0
    0000014C 0555                   MOV.W       R5,@(R0,R5)
    0000014E              L38:
    0000014E 7F10                   ADD         #16,R15
    00000150 6EF6                   MOV.L       @R15+,R14
            n4i7237.c        465    }
    00000152 000B                   RTS
    00000154 6DF6                   MOV.L       @R15+,R13
            n4i7237.c        466    
            n4i7237.c        467    ER intsta(void)
    00000156              _intsta:                         ; function: intsta
                                                           ; frame size=4
    00000156 4F22                   STS.L       PR,@-R15
            n4i7237.c        468    {
            n4i7237.c        469        if (cks > 3 || tc == 0L)
    00000158 D72D                   MOV.L       L47+46,R7  ; __$cks
    0000015A 6271                   MOV.W       @R7,R2     ; cks
    0000015C E603                   MOV         #3,R6      ; H'00000003
    0000015E 3266                   CMP/HI      R6,R2
    00000160 8933                   BT          L42
    00000162 D12A                   MOV.L       L47+42,R1  ; __$tc
    00000164 6212                   MOV.L       @R1,R2     ; tc
    00000166 2228                   TST         R2,R2
    00000168 892F                   BT          L42
            n4i7237.c        470            return E_PAR; /* エラー */
            n4i7237.c        471    
            n4i7237.c        472        /* 割込み定義 */
            n4i7237.c        473    
            n4i7237.c        474      #if (INTVSZ!=0) /* ROMに定義する場合は不要 */
            n4i7237.c        475        acre_isr(&disr_isritm);
    0000016A D52A                   MOV.L       L47+50,R5  ; _disr_isritm
    0000016C D72A                   MOV.L       L47+54,R7  ; _v4_cre_isr
    0000016E 470B                   JSR         @R7
    00000170 E400                   MOV         #0,R4      ; H'00000000
    00000172 05E00C04               MOVI20      #-127996,R5; H'FFFE0C04
            n4i7237.c        476      #endif
            n4i7237.c        477    
            n4i7237.c        478        /* 割込み優先レベル設定 */
            n4i7237.c        479    
            n4i7237.c        480      /* ↓下記、コメントにすると _RESET繰り返しは起きない。 */
            n4i7237.c        481        sfr_setw(INTC_IPR08, (IP) << (12 - CH * 4));
    00000176 E400                   MOV         #0,R4      ; H'00000000
    00000178 6243                   MOV         R4,R2
    0000017A E670                   MOV         #112,R6    ; H'00000070
    0000017C 325C                   ADD         R5,R2
    0000017E 4618                   SHLL8       R6
    00000180 6121                   MOV.W       @R2,R1
            n4i7237.c        482    
            n4i7237.c        483      
            n4i7237.c        484        /* タイマ初期化 */
            n4i7237.c        485    
            n4i7237.c        486      #ifdef HOOK
            n4i7237.c        487        TICK_RATE = (UW)tc;
            n4i7237.c        488        TOTAL_TICKCK = ((sfr_inw(CMT_CMCNT)*MSEC*1000)/TICK_RATE);
            n4i7237.c        489      #endif
            n4i7237.c        490    
            n4i7237.c        491        sfr_clrw(CMT_CMSTR, 0x01 << CH);/* カウント一旦停止 */
    00000182 6543                   MOV         R4,R5
            n4i7237.c        492        sfr_outw(CMT_CMCOR, (H)(tc));   /* 比較値 */
    00000184 00E0C006               MOVI20      #-81914,R0 ; H'FFFEC006
    00000188 216B                   OR          R6,R1
    0000018A 06E0C000               MOVI20      #-81920,R6 ; H'FFFEC000
    0000018E 2211                   MOV.W       R1,@R2
    00000190 356C                   ADD         R6,R5
    00000192 6651                   MOV.W       @R5,R6
            n4i7237.c        493        sfr_outw(CMT_CMCNT, (H)(0));    /* カウンタクリア */
            n4i7237.c        494        sfr_outw(CMT_CMCSR, 0x40|cks);  /* コンペアマッチ割り込みを許可 */
    00000194 D71E                   MOV.L       L47+46,R7  ; __$cks
    00000196 8660                   BCLR        #0,R6
    00000198 2561                   MOV.W       R6,@R5
    0000019A D61C                   MOV.L       L47+42,R6  ; __$tc
    0000019C 6262                   MOV.L       @R6,R2     ; tc
    0000019E 0425                   MOV.W       R2,@(R0,R4)
    000001A0 70FE                   ADD         #-2,R0
    000001A2 0445                   MOV.W       R4,@(R0,R4)
    000001A4 70FE                   ADD         #-2,R0
    000001A6 6171                   MOV.W       @R7,R1     ; cks
            n4i7237.c        495                                        /* クロック選択 */
            n4i7237.c        496      INTC.IPR08.BIT._CMT0 = 8;                   // CMT0割り込みレベル = 4
    000001A8 07E00C04               MOVI20      #-127996,R7; H'FFFE0C04
    000001AC 861E                   BSET        #6,R1
    000001AE 0415                   MOV.W       R1,@(R0,R4)
            n4i7237.c        497        sfr_setw(CMT_CMSTR, 0x01 << CH);/* カウント動作再スタート */
            n4i7237.c        498    
            n4i7237.c        499        return E_OK;
    000001B0 6043                   MOV         R4,R0
    000001B2 6271                   MOV.W       @R7,R2
    000001B4 01000FFF               MOVI20      #4095,R1   ; H'00000FFF
    000001B8 2219                   AND         R1,R2
    000001BA 01008000               MOVI20      #32768,R1  ; H'00008000
    000001BE 221B                   OR          R1,R2
    000001C0 2721                   MOV.W       R2,@R7
    000001C2 6251                   MOV.W       @R5,R2
    000001C4 8628                   BSET        #0,R2
    000001C6 A001                   BRA         L44
    000001C8 2521                   MOV.W       R2,@R5
    000001CA              L42:
    000001CA E0EF                   MOV         #-17,R0    ; H'FFFFFFEF
    000001CC              L44:
    000001CC 4F26                   LDS.L       @R15+,PR
            n4i7237.c        500    }
    000001CE 006B                   RTS/N
            n4i7237.c        501    
            n4i7237.c        502    /*****************************************************************************
            n4i7237.c        503    * 周期タイマ割込サービスルーチン (内蔵 CMT)
            n4i7237.c        504    *
            n4i7237.c        505    ******************************************************************************/
            n4i7237.c        506    
            n4i7237.c        507    #if (INTVSZ==0) /* ROMに定義する場合は割込みハンドラ */
            n4i7237.c        508    void isritm(void)
            n4i7237.c        509    #else
            n4i7237.c        510    void isritm(VP_INT exinf)
    000001D0              _isritm:                         ; function: isritm
                                                           ; frame size=0
            n4i7237.c        511    #endif
            n4i7237.c        512    {
            n4i7237.c        513      #ifdef HOOK
            n4i7237.c        514        UINT psw;
            n4i7237.c        515    
            n4i7237.c        516        psw = vdis_psw();
            n4i7237.c        517        TOTAL_TICKCK += MSEC*1000;
            n4i7237.c        518      #endif
            n4i7237.c        519        sfr_clrw(CMT_CMCSR, 0x80);      /* CMF コンペアマッチフラグクリア */
    000001D0 05E0C002               MOVI20      #-81918,R5 ; H'FFFEC002
            n4i7237.c        520      #ifdef HOOK
            n4i7237.c        521        vset_psw(psw);
            n4i7237.c        522      #endif
            n4i7237.c        523        isig_tim();                     /* システムクロック処理 */
    000001D4 6151                   MOV.W       @R5,R1
    000001D6 8617                   BCLR        #7,R1
    000001D8 D410                   MOV.L       L47+58,R4  ; _v3_sig_tim
    000001DA 442B                   JMP         @R4
    000001DC 2511                   MOV.W       R1,@R5
            n4i7237.c        524    }
            n4i7237.c        525    
            n4i7237.c        526    /*****************************************************************************
            n4i7237.c        527    * 周期タイマ割込みハンドラ (内蔵 CMT)
            n4i7237.c        528    *
            n4i7237.c        529    ******************************************************************************/
            n4i7237.c        530    
            n4i7237.c        531    #if (INTVSZ==0)
            n4i7237.c        532    INTHDR inthdr(void)
            n4i7237.c        533    {
            n4i7237.c        534        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        535        isritm();                       /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        536        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        537    }
            n4i7237.c        538    INTHDR int_sio0_rx(void)
            n4i7237.c        539    {
            n4i7237.c        540        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        541        int_sio0_rxi();                 /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        542        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        543    }
            n4i7237.c        544    INTHDR int_sio0_er(void)
            n4i7237.c        545    {
            n4i7237.c        546        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        547        int_sio0_eri();                 /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        548        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        549    }
            n4i7237.c        550    
            n4i7237.c        551    INTHDR int_sio1_rx(void)
            n4i7237.c        552    {
            n4i7237.c        553        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        554        int_sio_rxEx(SIO_EX1);          /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        555        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        556    }
            n4i7237.c        557    INTHDR int_sio1_er(void)
            n4i7237.c        558    {
            n4i7237.c        559        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        560        int_sio_erEx(SIO_EX1);          /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        561        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        562    }
            n4i7237.c        563    INTHDR int_sio2_rx(void)
            n4i7237.c        564    {
            n4i7237.c        565        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        566        int_sio_rxEx(SIO_EX2);          /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        567        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        568    }
            n4i7237.c        569    INTHDR int_sio2_er(void)
            n4i7237.c        570    {
            n4i7237.c        571        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        572        int_sio_erEx(SIO_EX2);          /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        573        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        574    }
            n4i7237.c        575    // 5/11INTHDR int_sio3_rx(void)
            n4i7237.c        576    // 5/11{
            n4i7237.c        577    // 5/11    ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        578    // 5/11    int_sio_rxEx(SIO_EX3);          /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        579    // 5/11    ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        580    // 5/11}
            n4i7237.c        581    // 5/11INTHDR int_sio3_er(void)
            n4i7237.c        582    // 5/11{
            n4i7237.c        583    // 5/11    ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        584    // 5/11    int_sio_erEx(SIO_EX3);          /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        585    // 5/11    ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        586    // 5/11}
            n4i7237.c        587    
            n4i7237.c        588    INTHDR int_irq4(void)
            n4i7237.c        589    {
            n4i7237.c        590        ent_int();                      /* 割込みハンドラの開始 */
            n4i7237.c        591        IRQ4_ISR();                     /* 割込サービスルーチンを呼ぶ */
            n4i7237.c        592        ret_int();                      /* 割込みハンドラから復帰する */
            n4i7237.c        593    }
            n4i7237.c        594    #endif
            n4i7237.c        595    
            n4i7237.c        596    /*****************************************************************************
            n4i7237.c        597    * Tick入力積算値を算出 (内蔵CMT)
            n4i7237.c        598    *
            n4i7237.c        599    ******************************************************************************/
            n4i7237.c        600    
            n4i7237.c        601    #ifdef HOOK
            n4i7237.c        602    #if (HOOK==1)
            n4i7237.c        603    UW tickck_read(void)
            n4i7237.c        604    #else
            n4i7237.c        605    UW ctex_timer_read(void)
            n4i7237.c        606    #endif
            n4i7237.c        607    {
            n4i7237.c        608        UW ret, tmp;
            n4i7237.c        609        UH tmp_flg;
            n4i7237.c        610    
            n4i7237.c        611        if (TICK_RATE) {
            n4i7237.c        612            /* 周期タイマー起動後 */
            n4i7237.c        613    
            n4i7237.c        614            do {
            n4i7237.c        615                ret = *((volatile UW*)&TOTAL_TICKCK);
            n4i7237.c        616                tmp_flg = sfr_inw(CMT_CMCSR);
            n4i7237.c        617                tmp = sfr_inw(CMT_CMCNT);
            n4i7237.c        618            } while((tmp == TICK_RATE) || (ret != *((volatile UW*)&TOTAL_TICKCK)));
            n4i7237.c        619            /* コンペアマッチを起こしていると想定される場合は再度計算しなおす。*/
            n4i7237.c        620    
            n4i7237.c        621            if (tmp_flg & 0x80) {
            n4i7237.c        622                tmp += TICK_RATE;
            n4i7237.c        623            }
            n4i7237.c        624    
            n4i7237.c        625            return (ret + ((tmp*MSEC*1000)/TICK_RATE));
            n4i7237.c        626    
            n4i7237.c        627        } else {
            n4i7237.c        628            /* 周期タイマー起動前 */
            n4i7237.c        629            return ((sfr_inw(CMT_CMCNT)*MSEC*1000)/tc);
            n4i7237.c        630        }
            n4i7237.c        631    }
            n4i7237.c        632    
            n4i7237.c        633    #else
            n4i7237.c        634    
            n4i7237.c        635    UW tickck_read(void)
    000001DE              _tickck_read:                    ; function: tickck_read
                                                           ; frame size=0
            n4i7237.c        636    {
            n4i7237.c        637        return 0L;
            n4i7237.c        638    }
    000001DE 000B                   RTS
    000001E0 E000                   MOV         #0,R0      ; H'00000000
    000001E2              L47:
    000001E2 00000002               .RES.W      1
    000001E4 <00000000>             .DATA.L     __VECT_BGN
    000001E8 <00000000>             .DATA.L     __kernel_interr
    000001EC <00000000>             .DATA.L     __P_BGN
    000001F0 <00000000>             .DATA.L     __P_END
    000001F4 <00000000>             .DATA.L     __C_BGN
    000001F8 <00000000>             .DATA.L     __C_END
    000001FC <00000000>             .DATA.L     _v3_vdis_psw
    00000200 <00000000>             .DATA.L     _v3_vset_psw
    00000204 <00000000>             .DATA.L     L48
    00000208 17D78400               .DATA.L     H'17D78400
    0000020C <00000000>             .DATA.L     __$tc
    00000210 <00000000>             .DATA.L     __$cks
    00000214 <00000000>             .DATA.L     _disr_isritm
    00000218 <00000000>             .DATA.L     _v4_cre_isr
    0000021C <00000000>             .DATA.L     _v3_sig_tim
            n4i7237.c        639    #endif
            n4i7237.c        640    
            n4i7237.c        641    /* end */
C   00000000              _disr_isritm:                    ; static: disr_isritm
    00000000 0000000000             .DATA.L     H'00000000,H'00000000,H'0000008C
             0000000000   
             008C         
    0000000C <00000000>   
                                    .DATA.L     _isritm
    00000010 00000000               .DATA.L     H'00000000
    00000014              L48:
    00000014 0000000800             .DATA.L     H'00000008,H'00000020,H'00000080,H'00000200
             0000200000   
             0080000002   
             00           
B   00000000              __$tc:                           ; static: __$tc
    00000000 00000004               .RES.L      1
    00000004              __$cks:                          ; static: __$cks
    00000004 00000002               .RES.W      1
SH SERIES C/C++ Compiler (V.9.02.00.003)                                                         08-Sep-2023 13:46:33  PAGE    1


******** STATISTICS INFORMATION ********


********** ERROR INFORMATION ***********

NUMBER OF ERRORS:           0
NUMBER OF WARNINGS:         0




******* SOURCE LINE INFORMATION ********

COMPILED SOURCE LINE:      641



******* SECTION SIZE INFORMATION *******

PROGRAM  SECTION (P):                                 00000220 Byte(s)
CONSTANT SECTION (C):                                 00000024 Byte(s)
DATA     SECTION (D):                                 00000000 Byte(s)
BSS      SECTION (B):                                 00000006 Byte(s)

TOTAL PROGRAM  SECTION: 00000220 Byte(s)
TOTAL CONSTANT SECTION: 00000024 Byte(s)
TOTAL DATA     SECTION: 00000000 Byte(s)
TOTAL BSS      SECTION: 00000006 Byte(s)

    TOTAL PROGRAM SIZE: 0000024A Byte(s)



********** LABEL INFORMATION ***********

NUMBER OF EXTERNAL REFERENCE SYMBOLS:           10
NUMBER OF EXTERNAL DEFINITION SYMBOLS:          11
NUMBER OF INTERNAL/EXTERNAL SYMBOLS:            38



*** COMMAND PARAMETER ***

-subcommand=C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\Debug\n4i7237.shc
-cpu=sh2a
-include="C:\NORTi\INC","C:\NORTi\INC\Dummy","C:\NORTi\INC","C:\NORTi\LIB"
-object="C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\Debug\n4i7237.obj"
-debug
-listfile="C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\Debug\n4i7237.lst"
-show=source,tab=4
-gbr=auto
-chgincpath
-errorpath
"C:\Users\SeijiYamazaki\Documents\Quickgene\Soft_Firm\QuickGene_Project2\n4i7237.c"
-global_volatile=0
-opt_range=all
-infinite_loop=0
-del_vacant_loop=0
-struct_alloc=1
-lang=c
-nologo
