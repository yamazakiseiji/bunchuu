SH SERIES C/C++ Compiler (V.9.04.03.000)                                                         07-Sep-2023 20:41:33  PAGE    1

************ OBJECT LISTING ************

FILE NAME: C:\WorkSpace\QuickGene\Soft_Firm\QuickGene_Project\mnet.c

SCT OFFSET   CODE       C LABEL     INSTRUCTION OPERAND    COMMENT

               mnet.c          1    /******************************************************************************
               mnet.c          2    * モーションネット管理タスク                                                  *
               mnet.c          3    *                                                                             *
               mnet.c          4    * File name : mnet.c                                                          *
               mnet.c          5    *                                                                             *
               mnet.c          6    * Copyright (c) 2018 NICHIRYO Co., Ltd.                                       *
               mnet.c          7    *                                                                             *
               mnet.c          8    ******************************************************************************/
               mnet.c          9    #include <kernel.h>
               mnet.c         10    #include "iodefine.h"
               mnet.c         11    #include "define.h"
               mnet.c         12    #include "datastruct.h" 
               mnet.c         13    #include "mnet.h"
               mnet.c         14    #include "sub.h"
               mnet.c         15    #include "automachine.h"
               mnet.c         16    #include "macro.h"
               mnet.c         17    
               mnet.c         18    
               mnet.c         19    // *****************************************************
               mnet.c         20    //  コンパイルスイッチ
               mnet.c         21    // *****************************************************
               mnet.c         22    #define WAIT_TYPE_IFB 1   // 定義:IFBフラグ監視
               mnet.c         23    #define WAIT_END_CHK  1   // 定義:完了待ちﾙｰﾌﾟ
               mnet.c         24    #define WAIT_TYPE_RW  1   // 定義:RWディレイ
               mnet.c         25    
               mnet.c         26    #define DEBUG_INFO                1       // ☆ 1 = DEBUG用, 0 = 製品用
               mnet.c         27    
               mnet.c         28    
               mnet.c         29    // *****************************************************
               mnet.c         30    //  関数定義
               mnet.c         31    // *****************************************************
               mnet.c         32    ER    MntInit( void );
               mnet.c         33    BOOL pio_Init();
               mnet.c         34    BOOL motor_Init(void);
               mnet.c         35    
               mnet.c         36    void pio_ALLIN(UB *data);
               mnet.c         37    UB pio_BIN(UB ch);
               mnet.c         38    void pio_BOUT(UB ch, UB sw);
               mnet.c         39    void pio_PATOUT(UB sw1, UB sw2, UB sw3);
               mnet.c         40    ER motor_POWER(UB pm, UB sw);
               mnet.c         41    ER motor_LIMIT(UB mm, UB dr, UB md, INT sp );
               mnet.c         42    ER motor_SCAN(UB pm, UH dir);
               mnet.c         43    ER motor_SET(UB pm, ST_MOTOR_PARAM mp);
               mnet.c         44    ER motor_PSET(UB pm, INT cnt, INT enc, INT def);
               mnet.c         45    ER motor_ABSMV(UB pm, INT pos, UB status);
               mnet.c         46    ER motor_RELMV(UB pm, INT pos, UB status);
               mnet.c         47    ER motor_STOP(UB pm);
               mnet.c         48    ER motor_ABORT(UB pm);
               mnet.c         49    ER motor_STATUS(UB pm, ST_MOTOR_STATUS *status);
               mnet.c         50    
               mnet.c         51    static BOOL WriteMemory(INT addr, UH data);
               mnet.c         52    static BOOL WriteMemoryInt(INT addr, INT data);
               mnet.c         53    static BOOL ReadMemory(INT addr,  UH *data);
               mnet.c         54    static BOOL SetMainCommand(UH command);
               mnet.c         55    static BOOL GetMainStatus(MNETStatus* status);
               mnet.c         56    
               mnet.c         57    // PCD4611 ---
               mnet.c         58    static void WriteMemoryPCD4611(UB data);
               mnet.c         59    static void WriteMemoryIntPCD4611(INT data);
               mnet.c         60    static INT  ReadMemoryPCD4611();
               mnet.c         61    // PCD4611 ---
               mnet.c         62    
               mnet.c         63     BOOL SetMotorRegisterInt(UB dev_no, UH reg, INT value);//★
               mnet.c         64    //static BOOL SetMotorRegisterInt(UB dev_no, UH reg, INT value);
               mnet.c         65    static BOOL SetMotorRegister(UB dev_no, UH reg, UH value);
               mnet.c         66           BOOL GetMotorStatus(UB dev_no, MotorStatus* status);
               mnet.c         67    static BOOL GetMotorSubStatus(UB dev_no, MNETSubStatus* substs);
               mnet.c         68    static BOOL SetMainRegister(UH reg, UH data);
               mnet.c         69           BOOL IsExist(UB dev_no);
               mnet.c         70    static BOOL SetMotorCommand(UB dev_no, UH command);
               mnet.c         71           BOOL   GetMotorRegister(UB dev_no, UH reg, INT* value);
               mnet.c         72    static ER   motor_SetAllRegister(UB pm);
               mnet.c         73    static ER   motor_CalcMotorReg(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg);
               mnet.c         74    static ER motor_CalcMotorRegPCD4611(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg);
               mnet.c         75    static void motor_RegistCommand(UB pm, UH cmd);
               mnet.c         76           void g_Sleep(INT usec);
               mnet.c         77    static void ClearInterrupt(void);
               mnet.c         78    static BOOL IfbIdleWait(void);    // ＩＦＢアイドリング待ち
               mnet.c         79    static BOOL ChkIFB( void );       // ＩＦＢ状態取得
               mnet.c         80    static BOOL EndIdleWait(void);    // 完了待ち
               mnet.c         81    static BOOL ChkEnd( void );       // エンド状態取得
               mnet.c         82    static BOOL motor_InitController(void);
               mnet.c         83    static UB ChkRbsy( void );
               mnet.c         84    static UB ChkDbsy( void );
               mnet.c         85    static UB ChkSbsy( void );
               mnet.c         86    
               mnet.c         87    
               mnet.c         88    
               mnet.c         89    static ER SetRenv1Fu( UB dev_no );                // RENV1 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         90    static ER SetRenv1PCD4611( UB dev_no );           // 
               mnet.c         91    static ER SetRenv2Fu( UB dev_no, UB teibai ); // RENV2 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         92    static ER SetRenv2PCD4611( UB dev_no, UB teibai );
               mnet.c         93    static ER SetRenv3Fu( UB dev_no, UB enc );        // RENV3 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         94    static ER SetRmdFu( UB dev_no, UB mod );      // RMD   設定( BCD-4020FUA , BCD-4020FU )
               mnet.c         95    static ER SetRmv( UB dev_no, INT pos );           // RMV   設定
               mnet.c         96    static ER SetRmvPCD4611( UB dev_no, INT pos );
               mnet.c         97    void  check_main_pulsemotor_initialize( );
               mnet.c         98    
               mnet.c         99    #ifdef DEBUG_INFO
               mnet.c        100    static void DebugMnetInfo( UB mm );
               mnet.c        101    #endif
               mnet.c        102    static ER SetRenv3PCD4611( UB dev_no, UB enc );
               mnet.c        103    static ER SetRmdPCD4611( UB dev_no, UB mod );
               mnet.c        104    
               mnet.c        105    
               mnet.c        106    /***********************************************************************
               mnet.c        107    * 構造体
               mnet.c        108    ***********************************************************************/
               mnet.c        109    
               mnet.c        110    
               mnet.c        111    
               mnet.c        112    /***********************************************************************
               mnet.c        113    * テーブル
               mnet.c        114    ***********************************************************************/
               mnet.c        115    
               mnet.c        116    static const INT MOTORSPD_TBL[10] = {
               mnet.c        117      1999,
               mnet.c        118       999,
               mnet.c        119       399,
               mnet.c        120       199,
               mnet.c        121        99,
               mnet.c        122        39,
               mnet.c        123        19,
               mnet.c        124         9,
               mnet.c        125         3,
               mnet.c        126         2
               mnet.c        127    };
               mnet.c        128    static const INT MOTORSPD_TBL_PCD4611[10] = {
               mnet.c        129      3999,// 0.3
               mnet.c        130      2399,// 0.5
               mnet.c        131      1199,// 1
               mnet.c        132       599,// 2
               mnet.c        133       239,// 5
               mnet.c        134        59,// 10
               mnet.c        135        29,// 20
               mnet.c        136        14,// 50
               mnet.c        137         5,// 100
               mnet.c        138         2 // 200
               mnet.c        139    };
               mnet.c        140    
               mnet.c        141    // LIMITコマンド時のモード選択
               mnet.c        142    static const UB LMMOD_TBL[2][3] = {
               mnet.c        143    //    規定外   CW      CCW
               mnet.c        144      { MOD20  , MOD20,  MOD28 }, // GENTEN_POS
               mnet.c        145      { MOD22  , MOD22,  MOD2A }  // NUKEDA_POS
               mnet.c        146    };
               mnet.c        147    
               mnet.c        148    /***********************************************************************
               mnet.c        149    * データ定義
               mnet.c        150    ***********************************************************************/
               mnet.c        151    volatile struct   StMotionnet *pMotionnet;
               mnet.c        152    volatile struct   StPulseMotor    *pPulseMotor;
               mnet.c        153    
               mnet.c        154    
               mnet.c        155    static    ST_PM_INFO      _pmInfo[20];            // パルスモータ情報配列
               mnet.c        156    static    BOOL            Initialized = FALSE;    // 
               mnet.c        157    static    INT factor;
               mnet.c        158    static    INT param;
               mnet.c        159    static    INT RMG;
               mnet.c        160    static    INT RFL;
               mnet.c        161    static    INT RFH;
               mnet.c        162    static    INT RUR;
               mnet.c        163    static    INT RUS;
               mnet.c        164    static    INT RDS;
               mnet.c        165    
               mnet.c        166    #define   PULSEMOTOR_CMD_CUN1R    0x20            // カウンタリセット（COUNTER1）
               mnet.c        167    #define   PULSEMOTOR_CMD_CUN2R    0x21            // カウンタリセット（COUNTER2）
               mnet.c        168    #define   PULSEMOTOR_CMD_STOP     0x49            // 即停止
               mnet.c        169    #define   PULSEMOTOR_CMD_STAFL    0x50            // FL低速スタート
               mnet.c        170    #define   PULSEMOTOR_CMD_WPRFL    0x81            // [W] 初速度
               mnet.c        171    #define   PULSEMOTOR_CMD_WPRMG    0x85            // [W] 速度倍率
               mnet.c        172    #define   PULSEMOTOR_CMD_WPRMD    0x87            // [W] 動作モード
               mnet.c        173    #define   PULSEMOTOR_CMD_WRENV1   0x9C            // [W] 環境設定1
               mnet.c        174    #define   PULSEMOTOR_CMD_WRENV2   0x9D            // [W] 環境設定2
               mnet.c        175    #define   PULSEMOTOR_CMD_RRENV1   0xDC            // [R] 環境設定1
               mnet.c        176    #define   PULSEMOTOR_CMD_RCUN1    0xE3            // [R] COUNTER1（指令位置カウンタ）
               mnet.c        177    #define   PULSEMOTOR_CMD_RCUN2    0xE4            // [R] COUNTER2（機械位置カウンタ）
               mnet.c        178    #define   PULSEMOTOR_CMD_RREST    0xF2            // [R] エラー割り込み要因取得
               mnet.c        179    
               mnet.c        180    
               mnet.c        181    
               mnet.c        182    
               mnet.c        183    /******************************************************************************
               mnet.c        184    * 
               mnet.c        185    * [概要]
               mnet.c        186    * 
               mnet.c        187    * 
               mnet.c        188    * 
               mnet.c        189    ******************************************************************************/
               mnet.c        190    ER    MntInit( void )
P   00000000              _MntInit:                        ; function: MntInit
                                                           ; frame size=12
    00000000 4DF0                   MOVMU.L     R13,@-R15
               mnet.c        191    {
               mnet.c        192      BOOL    blnResult;
               mnet.c        193      UB      rtycnt = 0;
               mnet.c        194      int setValue;
               mnet.c        195    
               mnet.c        196      pMotionnet = (struct StMotionnet *)MNET_BASE_ADDRESS;
    00000002 D253                   MOV.L       L617+2,R2  ; H'0C008000
               mnet.c        197    
               mnet.c        198      blnResult = SetMainCommand(MNET_CENTER_RESET);              //  100h
    00000004 E401                   MOV         #1,R4      ; H'00000001
    00000006 D653                   MOV.L       L617+6,R6  ; _pMotionnet
    00000008 2622                   MOV.L       R2,@R6     ; pMotionnet
    0000000A B75E                   BSR         __$SetMainCommand
    0000000C 4418                   SHLL8       R4
               mnet.c        199    
               mnet.c        200      check_main_pulsemotor_initialize();// PCD4611 初期化追加
    0000000E B040                   BSR         _check_main_pulsemotor_initialize
    00000010 0009                   NOP
    00000012 EE00                   MOV         #0,R14     ; H'00000000
    00000014              L11:
               mnet.c        201    
               mnet.c        202      // BUSY解除まで待つ
               mnet.c        203      while( ChkRbsy() ){};
    00000014 D350                   MOV.L       L617+10,R3 ; __$ChkRbsy
    00000016 434B                   JSR/N       @R3
    00000018 620C                   EXTU.B      R0,R2
    0000001A 2228                   TST         R2,R2
    0000001C 8BFA                   BF          L11
               mnet.c        204      
               mnet.c        205      blnResult = SetMainRegister(MNET_CENTER_WRENV0, 0x037F);    // 5500h
    0000001E E455                   MOV         #85,R4     ; H'00000055
    00000020 ED0A                   MOV         #10,R13    ; H'0000000A
    00000022 0500037F               MOVI20      #895,R5    ; H'0000037F
    00000026 B78E                   BSR         __$SetMainRegister
    00000028 4418                   SHLL8       R4
               mnet.c        206      blnResult = SetMainCommand(MNET_CMD_CLEAR_SEND_FIFO);       //  200h
    0000002A E402                   MOV         #2,R4      ; H'00000002
    0000002C B74D                   BSR         __$SetMainCommand
    0000002E 4418                   SHLL8       R4
               mnet.c        207      blnResult = SetMainCommand(MNET_CMD_CLEAR_RECV_FIFO);       //  300h
    00000030 E403                   MOV         #3,R4      ; H'00000003
    00000032 B74A                   BSR         __$SetMainCommand
    00000034 4418                   SHLL8       R4
               mnet.c        208      blnResult = SetMainCommand(MNET_CENTER_SYSCOM);             // 1000h
    00000036 E410                   MOV         #16,R4     ; H'00000010
    00000038 B747                   BSR         __$SetMainCommand
    0000003A 4418                   SHLL8       R4
    0000003C              L13:
               mnet.c        209    
               mnet.c        210      // BUSY解除まで待つ
               mnet.c        211      while( 1)
               mnet.c        212      {
               mnet.c        213          if( ChkDbsy() == CLR ) break;
    0000003C D347                   MOV.L       L617+14,R3 ; __$ChkDbsy
    0000003E 434B                   JSR/N       @R3
    00000040 620C                   EXTU.B      R0,R2
    00000042 2228                   TST         R2,R2
    00000044 890A                   BT          L15
               mnet.c        214    
               mnet.c        215          rtycnt++;
    00000046 7E01                   ADD         #1,R14
               mnet.c        216          dly_tsk(DLY_1M);
    00000048 D645                   MOV.L       L617+18,R6 ; _v4_dly_tsk
    0000004A 460B                   JSR         @R6
    0000004C E401                   MOV         #1,R4      ; H'00000001
               mnet.c        217    
               mnet.c        218          if( rtycnt > SYS_RTY_OVER )
    0000004E 67EC                   EXTU.B      R14,R7
    00000050 37D7                   CMP/GT      R13,R7
    00000052 00000440               MOVI20      #1088,R0   ; H'00000440
    00000056 891A                   BT          L16
    00000058 AFF0                   BRA         L13
    0000005A 0009                   NOP
    0000005C              L15:
               mnet.c        219          {
               mnet.c        220              return( E_CON_SYSCOM );
               mnet.c        221          }
               mnet.c        222      };
               mnet.c        223    
               mnet.c        224      // センター通信開始
               mnet.c        225      rtycnt = 0;
               mnet.c        226      blnResult = SetMainCommand(MNET_CENTER_STA_IOCOM);          // 3000h
    0000005C E430                   MOV         #48,R4     ; H'00000030
    0000005E EE00                   MOV         #0,R14     ; H'00000000
    00000060 B733                   BSR         __$SetMainCommand
    00000062 4418                   SHLL8       R4
    00000064              L17:
               mnet.c        227      while(1)
               mnet.c        228      {
               mnet.c        229          if( ChkSbsy() ) break;
    00000064 D33F                   MOV.L       L617+22,R3 ; __$ChkSbsy
    00000066 434B                   JSR/N       @R3
    00000068 620C                   EXTU.B      R0,R2
    0000006A 2228                   TST         R2,R2
    0000006C 8B0A                   BF          L19
               mnet.c        230          rtycnt++;
    0000006E 7E01                   ADD         #1,R14
               mnet.c        231          dly_tsk(DLY_1M);
    00000070 D13B                   MOV.L       L617+18,R1 ; _v4_dly_tsk
    00000072 410B                   JSR         @R1
    00000074 E401                   MOV         #1,R4      ; H'00000001
               mnet.c        232    
               mnet.c        233          // BUSY解除されず
               mnet.c        234          if( rtycnt > SYS_RTY_OVER )
    00000076 65EC                   EXTU.B      R14,R5
    00000078 35D7                   CMP/GT      R13,R5
    0000007A 00000441               MOVI20      #1089,R0   ; H'00000441
    0000007E 8906                   BT          L16
    00000080 AFF0                   BRA         L17
    00000082 0009                   NOP
    00000084              L19:
               mnet.c        235          {
               mnet.c        236              // 通信異常と判断
               mnet.c        237              return( E_CON_IO_COM );
               mnet.c        238          }
               mnet.c        239      }
               mnet.c        240      
               mnet.c        241      
               mnet.c        242      pio_Init();
    00000084 B0DC                   BSR         _pio_Init
    00000086 0009                   NOP
               mnet.c        243      motor_Init();
    00000088 B02F                   BSR         _motor_Init
    0000008A 0009                   NOP
               mnet.c        244    
               mnet.c        245      return( E_SUCCESS );
    0000008C E000                   MOV         #0,R0      ; H'00000000
    0000008E              L16:
    0000008E 4DF4                   MOVMU.L     @R15+,R13
               mnet.c        246    
               mnet.c        247    }
    00000090 006B                   RTS/N
               mnet.c        248    //==============================================================================
               mnet.c        249    //    Function    : check_main_pulsemotor_initialize
               mnet.c        250    //    Description : メイン基板のパルスモータ検査の初期化
               mnet.c        251    //    Parameters  : なし
               mnet.c        252    //    Return      : なし
               mnet.c        253    //    Note        : 
               mnet.c        254    //    Global      : 
               mnet.c        255    //==============================================================================
               mnet.c        256    void  check_main_pulsemotor_initialize( )
    00000092              _check_main_pulsemotor_initialize:
                                                           ; function: check_main_pulsemotor_initialize
                                                           ; frame size=12
    00000092 4DF0                   MOVMU.L     R13,@-R15
               mnet.c        257    {
               mnet.c        258    //    int setValue;
               mnet.c        259      
               mnet.c        260      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000094 D234                   MOV.L       L617+26,R2 ; H'0C009000
               mnet.c        261    
               mnet.c        262    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRFL, _pmInfo[MT_HEAD_Y0].reg[R1] );   // RFL
               mnet.c        263    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRFH, _pmInfo[MT_HEAD_Y0].reg[R2] );   // RFH
               mnet.c        264    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRUR, _pmInfo[MT_HEAD_Y0].reg[R3] );   // RUR
               mnet.c        265    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRDR, 0                           );   // RDR
               mnet.c        266    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRMG, _pmInfo[MT_HEAD_Y0].reg[R4] );   // RMG
               mnet.c        267    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRDP, 0                           );   // RDP
               mnet.c        268    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRDS, _pmInfo[MT_HEAD_Y0].reg[R9] );   // RDS
               mnet.c        269    //    SetMotorRegisterInt( MT_HEAD_Y0, WRG_PRMG, 1199                        );   // RMG
               mnet.c        270    #if 1
               mnet.c        271      SetMotorRegisterInt( MT_Y0, WRG_PRMG,   1199              );    // 
    00000096 E585                   MOV         #-123,R5   ; H'FFFFFF85
    00000098 D734                   MOV.L       L617+30,R7 ; _pPulseMotor
    0000009A 2722                   MOV.L       R2,@R7     ; pPulseMotor
    0000009C 655C                   EXTU.B      R5,R5
    0000009E EE01                   MOV         #1,R14     ; H'00000001
    000000A0 6D53                   MOV         R5,R13
    000000A2 060004AF               MOVI20      #1199,R6   ; H'000004AF
    000000A6 64E3                   MOV         R14,R4
               mnet.c        272      SetMotorRegisterInt( MT_Y0, WPCD_PRFL,  50                );    // 
    000000A8 B779                   BSR         _SetMotorRegisterInt
    000000AA 7DFC                   ADD         #-4,R13
    000000AC E632                   MOV         #50,R6     ; H'00000032
    000000AE 64E3                   MOV         R14,R4
    000000B0 65D3                   MOV         R13,R5
               mnet.c        273      SetMotorRegisterInt( MT_Y0, WPCD_PRFH,  300               );    // 
    000000B2 B774                   BSR         _SetMotorRegisterInt
    000000B4 7D01                   ADD         #1,R13
    000000B6 E64B                   MOV         #75,R6     ; H'0000004B
    000000B8 64E3                   MOV         R14,R4
    000000BA 4608                   SHLL2       R6
    000000BC 65D3                   MOV         R13,R5
               mnet.c        274      SetMotorRegisterInt( MT_Y0, WPCD_PRUR,  500               );    // 
    000000BE B76E                   BSR         _SetMotorRegisterInt
    000000C0 7D01                   ADD         #1,R13
    000000C2 E67D                   MOV         #125,R6    ; H'0000007D
    000000C4 64E3                   MOV         R14,R4
    000000C6 4608                   SHLL2       R6
    000000C8 65D3                   MOV         R13,R5
               mnet.c        275      SetMotorRegisterInt( MT_Y0, WPCD_RENV2, 0x00000005        );    // 
    000000CA B768                   BSR         _SetMotorRegisterInt
    000000CC 7D1A                   ADD         #26,R13
    000000CE E605                   MOV         #5,R6      ; H'00000005
    000000D0 65D3                   MOV         R13,R5
    000000D2 B764                   BSR         _SetMotorRegisterInt
    000000D4 64E3                   MOV         R14,R4
               mnet.c        276      WriteMemoryPCD4611 ( CMD_CUN1R );                           // CUN1R : 
    000000D6 B6FE                   BSR         __$WriteMemoryPCD4611
    000000D8 E420                   MOV         #32,R4     ; H'00000020
               mnet.c        277      WriteMemoryPCD4611 ( CMD_CUN2R );                           // CUN2R : 
    000000DA B6FC                   BSR         __$WriteMemoryPCD4611
    000000DC E421                   MOV         #33,R4     ; H'00000021
               mnet.c        278    #endif
               mnet.c        279    
               mnet.c        280    #if 0
               mnet.c        281      WriteMemoryIntPCD4611( 1199 );
               mnet.c        282      WriteMemoryPCD4611( WPCD_PRMG );        // PRMG : 速度倍率設定
               mnet.c        283    
               mnet.c        284      WriteMemoryIntPCD4611( 50 );
               mnet.c        285      WriteMemoryPCD4611( WPCD_PRFL );        // PRFL : 初速設定
               mnet.c        286    
               mnet.c        287      WriteMemoryIntPCD4611( 300 );
               mnet.c        288      WriteMemoryPCD4611( WPCD_PRFH );        // PRFH : 高速設定
               mnet.c        289    
               mnet.c        290      WriteMemoryIntPCD4611( 500 );
               mnet.c        291      WriteMemoryPCD4611( WPCD_PRUR );        // PRUR : 
               mnet.c        292    
               mnet.c        293      WriteMemoryIntPCD4611( 500 );
               mnet.c        294      WriteMemoryPCD4611( WPCD_PRDR );        // PRDR : 
               mnet.c        295    
               mnet.c        296      WriteMemoryIntPCD4611( 0x00000005 );
               mnet.c        297      WriteMemoryPCD4611( WPCD_RENV2 );       // RENV2 : 
               mnet.c        298      
               mnet.c        299      WriteMemoryPCD4611( CMD_CUN1R );        // CUN1R : 
               mnet.c        300      WriteMemoryPCD4611( CMD_CUN2R );        // CUN2R : 
               mnet.c        301    #endif
               mnet.c        302    
               mnet.c        303    #if 0
               mnet.c        304      // PRMG : 速度倍率設定
               mnet.c        305      setValue = 1199;                            // 倍率 = 1
               mnet.c        306      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        307      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        308      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        309      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        310      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRMG;    // 0x85;
               mnet.c        311    
               mnet.c        312      // PRFL : 初速設定
               mnet.c        313      setValue = 50;                              // 初速設定 = 50[pps]
               mnet.c        314      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        315      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        316      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        317      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        318      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRFL;    // 0x81;
               mnet.c        319    
               mnet.c        320      // PRFH
               mnet.c        321      setValue = 300;
               mnet.c        322      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        323      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        324      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        325      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        326      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRFH;    // 0x82;
               mnet.c        327    
               mnet.c        328      // PRUR
               mnet.c        329      setValue = 500;
               mnet.c        330      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        331      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        332      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        333      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        334      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRUR;    // 0x83;
               mnet.c        335    
               mnet.c        336      // PRDR
               mnet.c        337      setValue = 500;
               mnet.c        338      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        339      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        340      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        341      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        342      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_PRDR;    // 0x84;
               mnet.c        343    
               mnet.c        344      // RENV2 : 環境設定2
               mnet.c        345      setValue = 0x00000005;                      // EA/EB: A/B相1逓倍, P1〜P0: 汎用出力
               mnet.c        346      pPulseMotor->BUFB0 = (unsigned char)( setValue >> 0 );
               mnet.c        347      pPulseMotor->BUFB1 = (unsigned char)( setValue >> 8 );
               mnet.c        348      pPulseMotor->BUFB2 = (unsigned char)( setValue >> 16 );
               mnet.c        349      pPulseMotor->BUFB3 = (unsigned char)( setValue >> 24 );
               mnet.c        350      pPulseMotor->unCmdSts.stWrite.COMB0 = WPCD_RENV2;   // 0x9D
               mnet.c        351    #endif
               mnet.c        352      
               mnet.c        353      // 初期状態の設定
               mnet.c        354      // 汎用出力（"P0", "P1"）を"L"にする ... HOLDで可変
               mnet.c        355      pPulseMotor->unCmdSts.stWrite.OTPB = 0x00;
    000000DE D123                   MOV.L       L617+30,R1 ; _pPulseMotor
    000000E0 6E12                   MOV.L       @R1,R14    ; pPulseMotor
    000000E2 E000                   MOV         #0,R0      ; H'00000000
    000000E4 80E2                   MOV.B       R0,@(2,R14); (pPulseMotor)->OTPB
    000000E6 4DF4                   MOVMU.L     @R15+,R13
               mnet.c        356    }
    000000E8 006B                   RTS/N
               mnet.c        357    
               mnet.c        358    
               mnet.c        359    
               mnet.c        360    BOOL motor_Init(void)
    000000EA              _motor_Init:                     ; function: motor_Init
                                                           ; frame size=28
    000000EA 49F0                   MOVMU.L     R9,@-R15
    000000EC DE20                   MOV.L       L617+34,R14; H'0000007F+__$_pmInfo
    000000EE E97D                   MOV         #125,R9    ; H'0000007D
    000000F0 7E49                   ADD         #73,R14
    000000F2 4908                   SHLL2       R9
               mnet.c        361    {
               mnet.c        362      UB i;
               mnet.c        363    
               mnet.c        364      motor_InitController();
    000000F4 B042                   BSR         __$motor_InitController
    000000F6 ED02                   MOV         #2,R13     ; H'00000002
    000000F8 EC00                   MOV         #0,R12     ; H'00000000
    000000FA EA07                   MOV         #7,R10     ; H'00000007
    000000FC 0B000320               MOVI20      #800,R11   ; H'00000320
    00000100              L22:
               mnet.c        365    
               mnet.c        366      for (i=DVMIN+1; i<=DVMAX; i++)
               mnet.c        367      {
               mnet.c        368          if (IsExist( i ))
    00000100 D31C                   MOV.L       L617+38,R3 ; _IsExist
    00000102 430B                   JSR         @R3
    00000104 64D3                   MOV         R13,R4
    00000106 2008                   TST         R0,R0
    00000108 891A                   BT          L24
               mnet.c        369          {
               mnet.c        370              _pmInfo[i].factor           = 2;
               mnet.c        371              _pmInfo[i].pos              = 0;
               mnet.c        372              _pmInfo[i].power            = OFF;
               mnet.c        373              _pmInfo[i].paused           = FALSE;
               mnet.c        374              _pmInfo[i].command.code     = CMD_NOCOMMAND;
               mnet.c        375              _pmInfo[i].startParam       = CMD_NOTYPE;
               mnet.c        376    
               mnet.c        377              _pmInfo[i].reg[R0]          = 0;        // Pls
               mnet.c        378              _pmInfo[i].reg[R1]          = 200;      // RFL
    0000010A E6C8                   MOV         #-56,R6    ; H'FFFFFFC8
    0000010C E102                   MOV         #2,R1      ; H'00000002
    0000010E 666C                   EXTU.B      R6,R6
    00000110 2E12                   MOV.L       R1,@R14    ; _pmInfo[].factor
    00000112 3EC12014               MOV.L       R12,@(80:12,R14); _pmInfo[].pos
    00000116 3EC1102A               MOV.W       R12,@(84:12,R14); _pmInfo[].power
    0000011A 3EC12016               MOV.L       R12,@(88:12,R14); _pmInfo[].paused
    0000011E 3EC1102E               MOV.W       R12,@(92:12,R14); _pmInfo[].code
    00000122 3EC11030               MOV.W       R12,@(96:12,R14); _pmInfo[].startParam
    00000126 1EC9                   MOV.L       R12,@(36,R14); _pmInfo[].reg[]
               mnet.c        379              _pmInfo[i].reg[R2]          = 800;      // RFH
               mnet.c        380              _pmInfo[i].reg[R3]          = 500;      // RUR
               mnet.c        381              _pmInfo[i].reg[R4]          = 500;
               mnet.c        382              _pmInfo[i].reg[R5]          = 0;
               mnet.c        383              _pmInfo[i].reg[R6]          = 0;
               mnet.c        384              _pmInfo[i].reg[R7]          = 0;
               mnet.c        385    
               mnet.c        386              motor_PowerUp(i, _pmInfo[i].power);
    00000128 E500                   MOV         #0,R5      ; H'00000000
    0000012A 1E6A                   MOV.L       R6,@(40,R14); _pmInfo[].reg[]
    0000012C 1EBB                   MOV.L       R11,@(44,R14); _pmInfo[].reg[]
    0000012E 1E9C                   MOV.L       R9,@(48,R14); _pmInfo[].reg[]
    00000130 1E9D                   MOV.L       R9,@(52,R14); _pmInfo[].reg[]
    00000132 1ECE                   MOV.L       R12,@(56,R14); _pmInfo[].reg[]
    00000134 1ECF                   MOV.L       R12,@(60,R14); _pmInfo[].reg[]
    00000136 3EC12010               MOV.L       R12,@(64:12,R14); _pmInfo[].reg[]
    0000013A D30F                   MOV.L       L617+42,R3 ; _motor_PowerUp
    0000013C 430B                   JSR         @R3
    0000013E 64D3                   MOV         R13,R4
    00000140              L24:
    00000140 7D01                   ADD         #1,R13
    00000142 7E64                   ADD         #100,R14
    00000144 3DA7                   CMP/GT      R10,R13
    00000146 8FDB                   BF/S        L22
    00000148 E001                   MOV         #1,R0      ; H'00000001
    0000014A 49F4                   MOVMU.L     @R15+,R9
               mnet.c        387          }
               mnet.c        388      }
               mnet.c        389    
               mnet.c        390      return TRUE;
               mnet.c        391    }
    0000014C 006B                   RTS/N
    0000014E              L617:
    0000014E 00000002               .RES.W      1
    00000150 0C008000               .DATA.L     H'0C008000
    00000154 <00000000>             .DATA.L     _pMotionnet
    00000158 <00000000>             .DATA.L     __$ChkRbsy
    0000015C <00000000>             .DATA.L     __$ChkDbsy
    00000160 <00000000>             .DATA.L     _v4_dly_tsk
    00000164 <00000000>             .DATA.L     __$ChkSbsy
    00000168 0C009000               .DATA.L     H'0C009000
    0000016C <00000000>             .DATA.L     _pPulseMotor
    00000170 <0000007F>             .DATA.L     H'0000007F+__$_pmInfo
    00000174 <00000000>             .DATA.L     _IsExist
    00000178 <00000000>             .DATA.L     _motor_PowerUp
               mnet.c        392    ///<summary>
               mnet.c        393    /// モータコントローラを初期化する関数
               mnet.c        394    ///</summary>
               mnet.c        395    static BOOL motor_InitController(void)
    0000017C              __$motor_InitController:         ; function: __$motor_InitController
                                                           ; frame size=20
    0000017C 4CF0                   MOVMU.L     R12,@-R15
    0000017E 7FFC                   ADD         #-4,R15
               mnet.c        396    {
               mnet.c        397      UB pm;
               mnet.c        398      UB enc;
               mnet.c        399      UB mnet_drv_typ;
               mnet.c        400    
               mnet.c        401      // メインデバイスの全割り込みを無効化
               mnet.c        402      if (!SetMainRegister(MNET_CENTER_WRENV0, 0x037F))               return FALSE;
    00000180 E455                   MOV         #85,R4     ; H'00000055
    00000182 0500037F               MOVI20      #895,R5    ; H'0000037F
    00000186 B6DE                   BSR         __$SetMainRegister
    00000188 4418                   SHLL8       R4
    0000018A 2008                   TST         R0,R0
    0000018C 8953                   BT          L33
               mnet.c        403    
               mnet.c        404      for (pm=DVMIN; pm<=DVMAX; pm++)
    0000018E EE01                   MOV         #1,R14     ; H'00000001
    00000190 EC07                   MOV         #7,R12     ; H'00000007
    00000192              L34:
               mnet.c        405      {
               mnet.c        406          if (IsExist( pm ))                                          // デバイス接続しているか(≠0：接続)
    00000192 D378                   MOV.L       L618+2,R3  ; _IsExist
    00000194 430B                   JSR         @R3
    00000196 64E3                   MOV         R14,R4
    00000198 2008                   TST         R0,R0
    0000019A 8947                   BT          L36
               mnet.c        407          {
               mnet.c        408              mnet_drv_typ = MNET_DRV_TYPE[pm];                       // デバイス情報取得
    0000019C D676                   MOV.L       L618+6,R6  ; _MNET_DRV_TYPE
    0000019E 60E3                   MOV         R14,R0
    000001A0 026C                   MOV.B       @(R0,R6),R2; MNET_DRV_TYPE[]
    000001A2 602C                   EXTU.B      R2,R0
               mnet.c        409    
               mnet.c        410              switch( mnet_drv_typ )
    000001A4 8801                   CMP/EQ      #1,R0
    000001A6 8905                   BT          L38
    000001A8 2008                   TST         R0,R0
    000001AA 8922                   BT          L40
    000001AC 8809                   CMP/EQ      #9,R0
    000001AE 8938                   BT          L41
    000001B0 A03C                   BRA         L36
    000001B2 0009                   NOP
    000001B4              L38:
               mnet.c        411              {
               mnet.c        412              case BCD4020FUA:
               mnet.c        413                  if (!SetMotorCommand(pm, CMD_SRST))                 continue;
    000001B4 E504                   MOV         #4,R5      ; H'00000004
    000001B6 B6D4                   BSR         __$SetMotorCommand
    000001B8 64E3                   MOV         R14,R4
    000001BA 2008                   TST         R0,R0
    000001BC 8936                   BT          L36
               mnet.c        414                  if( IsEncoderExist(pm) == TRUE )                    enc = EC_3;
    000001BE 64E3                   MOV         R14,R4
    000001C0 D36E                   MOV.L       L618+10,R3 ; _IsEncoderExist
    000001C2 430B                   JSR         @R3
    000001C4 ED00                   MOV         #0,R13     ; H'00000000
    000001C6 8801                   CMP/EQ      #1,R0
    000001C8 8B00                   BF          L44
    000001CA ED03                   MOV         #3,R13     ; H'00000003
    000001CC              L44:
               mnet.c        415                  else                                                enc = EC_N;
               mnet.c        416    
               mnet.c        417                  if( SetRenv1Fu( pm ))                               return FALSE;// RENV1設定
    000001CC D36C                   MOV.L       L618+14,R3 ; __$SetRenv1Fu
    000001CE 430B                   JSR         @R3
    000001D0 64E3                   MOV         R14,R4
    000001D2 2008                   TST         R0,R0
    000001D4 8B2F                   BF          L33
               mnet.c        418                  if( SetRenv2Fu( pm, enc ))                          return FALSE;// RENV2設定
    000001D6 64E3                   MOV         R14,R4
    000001D8 D36A                   MOV.L       L618+18,R3 ; __$SetRenv2Fu
    000001DA 430B                   JSR         @R3
    000001DC 65D3                   MOV         R13,R5
    000001DE 2008                   TST         R0,R0
    000001E0 8B29                   BF          L33
               mnet.c        419                  if( SetRenv3Fu( pm, enc ))                          return FALSE;// RENV3設定
    000001E2 64E3                   MOV         R14,R4
    000001E4 D368                   MOV.L       L618+22,R3 ; __$SetRenv3Fu
    000001E6 430B                   JSR         @R3
    000001E8 65D3                   MOV         R13,R5
    000001EA 2008                   TST         R0,R0
    000001EC 8B23                   BF          L33
    000001EE A018                   BRA         L41
    000001F0 0009                   NOP
    000001F2              L40:
               mnet.c        420                  break;
               mnet.c        421    
               mnet.c        422              case BCD4020FU:
               mnet.c        423                  if (!SetMotorCommand(pm, CMD_SRST))                 continue;
    000001F2 E504                   MOV         #4,R5      ; H'00000004
    000001F4 B6B5                   BSR         __$SetMotorCommand
    000001F6 64E3                   MOV         R14,R4
    000001F8 2008                   TST         R0,R0
    000001FA 8917                   BT          L36
               mnet.c        424                  if( IsEncoderExist(pm) == TRUE )                    enc = EC_3;
    000001FC D35F                   MOV.L       L618+10,R3 ; _IsEncoderExist
    000001FE 430B                   JSR         @R3
    00000200 64E3                   MOV         R14,R4
    00000202 8801                   CMP/EQ      #1,R0
    00000204 8F01                   BF/S        L49
    00000206 E500                   MOV         #0,R5      ; H'00000000
    00000208 E503                   MOV         #3,R5      ; H'00000003
    0000020A              L49:
               mnet.c        425                  else                                                enc = EC_N;
               mnet.c        426    
               mnet.c        427                  if( SetRenv1Fu( pm ))                               return FALSE;// RENV1設定
    0000020A 2F50                   MOV.B       R5,@R15    ; enc
    0000020C D35C                   MOV.L       L618+14,R3 ; __$SetRenv1Fu
    0000020E 430B                   JSR         @R3
    00000210 64E3                   MOV         R14,R4
    00000212 2008                   TST         R0,R0
    00000214 8B0F                   BF          L33
               mnet.c        428                  if( SetRenv2Fu( pm, enc ))                          return FALSE;// RENV2設定
    00000216 65F0                   MOV.B       @R15,R5    ; enc
    00000218 D35A                   MOV.L       L618+18,R3 ; __$SetRenv2Fu
    0000021A 430B                   JSR         @R3
    0000021C 64E3                   MOV         R14,R4
    0000021E 2008                   TST         R0,R0
    00000220 8B09                   BF          L33
    00000222              L41:
    00000222 E5AC                   MOV         #-84,R5    ; H'FFFFFFAC
               mnet.c        429                  break;
               mnet.c        430    
               mnet.c        431              case PCD4611:
               mnet.c        432    //                if( SetRenv1PCD4611( pm ))                          return FALSE;// RENV1設定
               mnet.c        433    //                if( SetRenv2PCD4611( pm, enc ))                     return FALSE;// RENV2設定
               mnet.c        434                  break;
               mnet.c        435    
               mnet.c        436              default:
               mnet.c        437                  // モータドライバ以外は、スキップ
               mnet.c        438                  continue;
               mnet.c        439                  break;
               mnet.c        440              }
               mnet.c        441              // RIRQ
               mnet.c        442              SetMotorRegisterInt(pm, WRG_RIRQ, 0x00000000);
    00000224 E600                   MOV         #0,R6      ; H'00000000
    00000226 655C                   EXTU.B      R5,R5
    00000228 B6B9                   BSR         _SetMotorRegisterInt
    0000022A 64E3                   MOV         R14,R4
    0000022C              L36:
    0000022C 7E01                   ADD         #1,R14
    0000022E 3EC7                   CMP/GT      R12,R14
    00000230 8BAF                   BF          L34
               mnet.c        443          }
               mnet.c        444      }
               mnet.c        445      return TRUE;
    00000232 A001                   BRA         L52
    00000234 0029                   MOVT        R0
    00000236              L33:
    00000236 E000                   MOV         #0,R0      ; H'00000000
    00000238              L52:
    00000238 7F04                   ADD         #4,R15
    0000023A 4CF4                   MOVMU.L     @R15+,R12
               mnet.c        446    }
    0000023C 006B                   RTS/N
               mnet.c        447    ////////////////////////////////////////////////////////////////////////////////
               mnet.c        448    //
               mnet.c        449    // 割り込みハンドラ
               mnet.c        450    
               mnet.c        451    ///<summary>
               mnet.c        452    /// コマンド実行結果を取得します
               mnet.c        453    ///</summary>
               mnet.c        454    void IRQ4_ISR()
    0000023E              _IRQ4_ISR:                       ; function: IRQ4_ISR
                                                           ; frame size=0
               mnet.c        455    {
               mnet.c        456    #if 0 
               mnet.c        457      MNETStatus status;
               mnet.c        458      status.UNID.data = pMotionnet->commandStatus0 ;
               mnet.c        459      ClearInterrupt();
               mnet.c        460      INTC.IRQRR.BIT.IRQ4F = 0;
               mnet.c        461    #endif
               mnet.c        462    }
    0000023E 006B                   RTS/N
               mnet.c        463    
               mnet.c        464    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        465    // 
               mnet.c        466    // IO系
               mnet.c        467    // 
               mnet.c        468    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        469    ///<summary>
               mnet.c        470    /// IOトローラを初期化する関数
               mnet.c        471    ///</summary>
               mnet.c        472    BOOL pio_Init()
    00000240              _pio_Init:                       ; function: pio_Init
                                                           ; frame size=4
    00000240 4F22                   STS.L       PR,@-R15
               mnet.c        473    {
               mnet.c        474    // シュミレーションモード
               mnet.c        475    #if DEBUG_SIM_MODE != 0
               mnet.c        476      return TRUE;
               mnet.c        477    #endif
               mnet.c        478      // メインデバイスの全割り込みを無効化
               mnet.c        479      SetMainRegister(MNET_CENTER_WRENV0, 0x037F);
    00000242 E455                   MOV         #85,R4     ; H'00000055
    00000244 0500037F               MOVI20      #895,R5    ; H'0000037F
    00000248 B67D                   BSR         __$SetMainRegister
    0000024A 4418                   SHLL8       R4
               mnet.c        480    
               mnet.c        481      return TRUE;
    0000024C 4F26                   LDS.L       @R15+,PR
               mnet.c        482    }
    0000024E 000B                   RTS
    00000250 E001                   MOV         #1,R0      ; H'00000001
               mnet.c        483    
               mnet.c        484    
               mnet.c        485    /******************************************************************************
               mnet.c        486    * 
               mnet.c        487    * [概要]  全入力チャネルの状態を取得する
               mnet.c        488    * [引数]  data    入力値格納先
               mnet.c        489    * [戻り値]    TRUE:成功、FALSE:失敗
               mnet.c        490    * 
               mnet.c        491    ******************************************************************************/
               mnet.c        492    void pio_ALLIN(UB *data)
    00000252              _pio_ALLIN:                      ; function: pio_ALLIN
                                                           ; frame size=32
    00000252 48F0                   MOVMU.L     R8,@-R15
    00000254 D24D                   MOV.L       L618+26,R2 ; H'0C008000
    00000256 EB01                   MOV         #1,R11     ; H'00000001
               mnet.c        493    {
               mnet.c        494      INT Loopn;
               mnet.c        495      INT amari;
               mnet.c        496      INT syou;
               mnet.c        497      INT sftdat;
               mnet.c        498      UB  sftbit;
               mnet.c        499      UB  ret;
               mnet.c        500    
               mnet.c        501      sftbit = 0x01;
               mnet.c        502    
               mnet.c        503      pMotionnet = (struct StMotionnet *)MNET_BASE_ADDRESS;
    00000258 D64D                   MOV.L       L618+30,R6 ; _pMotionnet
    0000025A 2622                   MOV.L       R2,@R6     ; pMotionnet
    0000025C 68B3                   MOV         R11,R8
    0000025E 6A43                   MOV         R4,R10
               mnet.c        504    
               mnet.c        505      // ※補足）実装されていない入力個所０
               mnet.c        506      // bit1    チャネル2
               mnet.c        507      // ・
               mnet.c        508      // bit63   チャネル64
               mnet.c        509    
               mnet.c        510      
               mnet.c        511      // ※補足）実装されていない入力個所０
               mnet.c        512      // Ch0は無効のため検査しない
               mnet.c        513      for( Loopn = MIN_CH; Loopn <= MAX_CH; Loopn++ ) // 2020/2/12 １はじまり対応
    00000260 EC3F                   MOV         #63,R12    ; H'0000003F
    00000262 ED00                   MOV         #0,R13     ; H'00000000
    00000264 D94B                   MOV.L       L618+34,R9 ; _GetInputDat
    00000266              L56:
               mnet.c        514      {
               mnet.c        515          sftbit = 0x01;
               mnet.c        516    
               mnet.c        517          syou    = ( (Loopn - MIN_CH) / 8 );         // 余り取得
               mnet.c        518          amari   = ( (Loopn - MIN_CH) % 8 );         // 余り取得
               mnet.c        519          sftdat  = ( sftbit << amari );              // 余りをシフト
    00000266 4D11                   CMP/PZ      R13
    00000268 8905                   BT          L58
    0000026A 60D7                   NOT         R13,R0
    0000026C 7001                   ADD         #1,R0
    0000026E C907                   AND         #7,R0
    00000270 6207                   NOT         R0,R2
    00000272 A003                   BRA         L59
    00000274 7201                   ADD         #1,R2
    00000276              L58:
    00000276 60D3                   MOV         R13,R0
    00000278 C907                   AND         #7,R0
    0000027A 6203                   MOV         R0,R2
    0000027C              L59:
    0000027C 6E83                   MOV         R8,R14
    0000027E 4E2C                   SHAD        R2,R14
               mnet.c        520    
               mnet.c        521    // シュミレーションモード
               mnet.c        522    #if DEBUG_SIM_MODE != 0
               mnet.c        523          ret = 0;
               mnet.c        524    #else
               mnet.c        525          ret = GetInputDat( Loopn ) ;
    00000280 490B                   JSR         @R9
    00000282 64B3                   MOV         R11,R4
    00000284 4D11                   CMP/PZ      R13
    00000286 620C                   EXTU.B      R0,R2
               mnet.c        526    #endif
               mnet.c        527    
               mnet.c        528          if( ret )
    00000288 8D01                   BT/S        L61
    0000028A 66D3                   MOV         R13,R6
    0000028C 7607                   ADD         #7,R6
    0000028E              L61:
    0000028E E1FD                   MOV         #-3,R1     ; H'FFFFFFFD
    00000290 2228                   TST         R2,R2
    00000292 461C                   SHAD        R1,R6
    00000294 36AC                   ADD         R10,R6
    00000296 6563                   MOV         R6,R5
    00000298 8D02                   BT/S        L63
    0000029A 6660                   MOV.B       @R6,R6     ; data[]
               mnet.c        529          {
               mnet.c        530              data[syou] |= sftdat;
    0000029C A002                   BRA         L64
    0000029E 26EB                   OR          R14,R6
    000002A0              L63:
               mnet.c        531          }
               mnet.c        532          else
               mnet.c        533          {
               mnet.c        534              data[syou] &= (~sftdat);
    000002A0 62E7                   NOT         R14,R2
    000002A2 2629                   AND         R2,R6
    000002A4              L64:
    000002A4 4C10                   DT          R12
    000002A6 2560                   MOV.B       R6,@R5     ; data[]
    000002A8 7D01                   ADD         #1,R13
    000002AA 8FDC                   BF/S        L56
    000002AC 7B01                   ADD         #1,R11
    000002AE 48F4                   MOVMU.L     @R15+,R8
               mnet.c        535          }
               mnet.c        536      }
               mnet.c        537    }
    000002B0 006B                   RTS/N
               mnet.c        538    
               mnet.c        539    /******************************************************************************
               mnet.c        540    * 
               mnet.c        541    * [概要]  入力チャネルから信号を取得する
               mnet.c        542    * [引数]  ch      入力チャネル(０〜)
               mnet.c        543    *             sw      [out]チャネルの状態(TRUE:ON、FALSE：OFF)
               mnet.c        544    * [戻り値]    1:High、0:Low
               mnet.c        545    * 
               mnet.c        546    ******************************************************************************/
               mnet.c        547    UB pio_BIN(UB ch)
    000002B2              _pio_BIN:                        ; function: pio_BIN
                                                           ; frame size=4
    000002B2 4F22                   STS.L       PR,@-R15
               mnet.c        548    {
               mnet.c        549      UB retdat = OFF;
               mnet.c        550      
               mnet.c        551    // シュミレーションモード
               mnet.c        552    #if DEBUG_SIM_MODE != 0
               mnet.c        553      if( ch == 4 )
               mnet.c        554      {
               mnet.c        555          return(1);
               mnet.c        556      }
               mnet.c        557      else
               mnet.c        558      {
               mnet.c        559          return(0);
               mnet.c        560      }
               mnet.c        561    #endif
               mnet.c        562      
               mnet.c        563      if( ( ch == I_DOORSW1 )||( ch == I_DOORSW2 ) )
    000002B4 644C                   EXTU.B      R4,R4
    000002B6 6043                   MOV         R4,R0
    000002B8 8801                   CMP/EQ      #1,R0
    000002BA 8D05                   BT/S        L68
    000002BC E600                   MOV         #0,R6      ; H'00000000
    000002BE 8802                   CMP/EQ      #2,R0
    000002C0 8902                   BT          L68
               mnet.c        564      {
               mnet.c        565          
               mnet.c        566          
               mnet.c        567          
               mnet.c        568          
               mnet.c        569      }
               mnet.c        570      else
               mnet.c        571      {
               mnet.c        572          retdat = GetInputDat( ch );
    000002C2 D234                   MOV.L       L618+34,R2 ; _GetInputDat
    000002C4 424B                   JSR/N       @R2
    000002C6 6603                   MOV         R0,R6
    000002C8              L68:
    000002C8 4F26                   LDS.L       @R15+,PR
               mnet.c        573      }
               mnet.c        574      
               mnet.c        575      
               mnet.c        576      return ( retdat );
               mnet.c        577    }
    000002CA 067B                   RTV/N       R6
               mnet.c        578    /******************************************************************************
               mnet.c        579    * 
               mnet.c        580    * [概要]  出力チャネルへの出力データ
               mnet.c        581    * [引数]  ch      出力チャネル
               mnet.c        582    *             sw      ON:HIGH出力、OFF:LOW出力
               mnet.c        583    * [戻り値]    −
               mnet.c        584    * 
               mnet.c        585    ******************************************************************************/
               mnet.c        586    void pio_BOUT(UB ch, UB sw)
    000002CC              _pio_BOUT:                       ; function: pio_BOUT
                                                           ; frame size=44
    000002CC 49F0                   MOVMU.L     R9,@-R15
    000002CE 7FF0                   ADD         #-16,R15
    000002D0 604C                   EXTU.B      R4,R0
    000002D2 E601                   MOV         #1,R6      ; H'00000001
    000002D4 3063                   CMP/GE      R6,R0
               mnet.c        587    {
               mnet.c        588      INT waittim = WAITTIM;
               mnet.c        589      INT cnt;
               mnet.c        590      UB rdata = 0;
               mnet.c        591      UB wdata = 0;
               mnet.c        592      UB devno;
               mnet.c        593      UB portno;
               mnet.c        594      UB mskbit;
               mnet.c        595    
               mnet.c        596      if(( ch < MIN_CH )||( ch > MAX_CH )) return;    // 2020/2/12 １はじまり対応
    000002D6 8D02                   BT/S        L630
    000002D8 6E5C                   EXTU.B      R5,R14
    000002DA A093                   BRA         L75
    000002DC 0009                   NOP
    000002DE              L630:
    000002DE E63F                   MOV         #63,R6     ; H'0000003F
    000002E0 3067                   CMP/GT      R6,R0
    000002E2 8B01                   BF          L631
    000002E4 A08E                   BRA         L75
    000002E6 0009                   NOP
    000002E8              L631:
               mnet.c        597    
               mnet.c        598      if( ch == O_DAIAPMP )
    000002E8 8801                   CMP/EQ      #1,R0
    000002EA 8B0E                   BF          L78
    000002EC 2EE8                   TST         R14,R14
               mnet.c        599      {
               mnet.c        600    //        switch( sw )
               mnet.c        601    //        {
               mnet.c        602    //        case 1:     //正転
               mnet.c        603    //            PE.DR.BIT.B0 = 1;
               mnet.c        604    //            PE.DR.BIT.B1 = 0;
               mnet.c        605    //            break;
               mnet.c        606    //        case 2:     //逆転
               mnet.c        607    //            PE.DR.BIT.B0 = 0;
               mnet.c        608    //            PE.DR.BIT.B1 = 1;
               mnet.c        609    //            break;
               mnet.c        610    //        default:    //停止
               mnet.c        611    //            PE.DR.BIT.B0 = 0;
               mnet.c        612    //            PE.DR.BIT.B1 = 0;
               mnet.c        613    //            break;
               mnet.c        614    //        }
               mnet.c        615          
               mnet.c        616          switch( sw )
    000002EE 8F05                   BF/S        L80
    000002F0 64E3                   MOV         R14,R4
               mnet.c        617          {
               mnet.c        618          case 0:
               mnet.c        619              DpumpStop();
    000002F2 D229                   MOV.L       L618+38,R2 ; _DpumpStop
    000002F4 7F10                   ADD         #16,R15
    000002F6 49F4                   MOVMU.L     @R15+,R9
    000002F8 422B                   JMP         @R2
    000002FA 0009                   NOP
    000002FC              L80:
               mnet.c        620              break;
               mnet.c        621          default:
               mnet.c        622              SetDpumpDuty( sw );
    000002FC D127                   MOV.L       L618+42,R1 ; _SetDpumpDuty
    000002FE 414B                   JSR/N       @R1
               mnet.c        623              DpumpStart();
    00000300 D527                   MOV.L       L618+46,R5 ; _DpumpStart
    00000302 7F10                   ADD         #16,R15
    00000304 49F4                   MOVMU.L     @R15+,R9
    00000306 452B                   JMP         @R5
    00000308 0009                   NOP
    0000030A              L78:
               mnet.c        624              break;
               mnet.c        625          }
               mnet.c        626      }
               mnet.c        627      else
               mnet.c        628      {
               mnet.c        629          // CLRリクエスト
               mnet.c        630          devno  = OUTPUTCH_INFTBL[ch][0];
    0000030A 664C                   EXTU.B      R4,R6
    0000030C E003                   MOV         #3,R0      ; H'00000003
    0000030E 4680                   MULR        R0,R6
    00000310 D224                   MOV.L       L618+50,R2 ; _OUTPUTCH_INFTBL
               mnet.c        631          portno = OUTPUTCH_INFTBL[ch][1];
               mnet.c        632          mskbit = OUTPUTCH_INFTBL[ch][2];
               mnet.c        633          
               mnet.c        634          // 出力値作成
               mnet.c        635          if(( devno != NONE )&&( portno != NONE ))
    00000312 E1FF                   MOV         #-1,R1     ; H'FFFFFFFF
    00000314 611C                   EXTU.B      R1,R1
    00000316 362C                   ADD         R2,R6
    00000318 8461                   MOV.B       @(1,R6),R0 ; OUTPUTCH_INFTBL[]
    0000031A 35618000               MOVU.B      @(0,R6),R5 ; OUTPUTCH_INFTBL[]
    0000031E 6403                   MOV         R0,R4
    00000320 8462                   MOV.B       @(2,R6),R0 ; OUTPUTCH_INFTBL[]
    00000322 3510                   CMP/EQ      R1,R5
    00000324 8D6E                   BT/S        L75
    00000326 2F00                   MOV.B       R0,@R15    ; mskbit
    00000328 624C                   EXTU.B      R4,R2
    0000032A 3210                   CMP/EQ      R1,R2
    0000032C 896A                   BT          L75
               mnet.c        636          {
               mnet.c        637      // 本モード
               mnet.c        638    #if DEBUG_SIM_MODE == 0
               mnet.c        639              // 書込みデータベース取得
               mnet.c        640              MAC_READ( pMotionnet->portData[devno][portno], wdata );
    0000032E 4508                   SHLL2       R5
    00000330 ED01                   MOV         #1,R13     ; H'00000001
    00000332 644C                   EXTU.B      R4,R4
    00000334 EB05                   MOV         #5,R11     ; H'00000005
    00000336 D916                   MOV.L       L618+30,R9 ; _pMotionnet
    00000338 354C                   ADD         R4,R5
    0000033A 6492                   MOV.L       @R9,R4     ; pMotionnet
    0000033C 4D18                   SHLL8       R13
    0000033E 6643                   MOV         R4,R6
    00000340 36DC                   ADD         R13,R6
    00000342 6053                   MOV         R5,R0
    00000344 026C                   MOV.B       @(R0,R6),R2; pMotionnet->portData[]
    00000346 6C53                   MOV         R5,R12
    00000348 E500                   MOV         #0,R5      ; H'00000000
    0000034A 60C3                   MOV         R12,R0
    0000034C 1F61                   MOV.L       R6,@(4,R15)
    0000034E 672C                   EXTU.B      R2,R7
    00000350 6173                   MOV         R7,R1
    00000352              L83:
    00000352 5AF1                   MOV.L       @(4,R15),R10
    00000354 02AC                   MOV.B       @(R0,R10),R2; pMotionnet->portData[]
    00000356 662C                   EXTU.B      R2,R6
    00000358 3670                   CMP/EQ      R7,R6
    0000035A 8902                   BT          L85
    0000035C E500                   MOV         #0,R5      ; H'00000000
    0000035E 6163                   MOV         R6,R1
    00000360 6763                   MOV         R6,R7
    00000362              L85:
    00000362 7501                   ADD         #1,R5
    00000364 35B3                   CMP/GE      R11,R5
    00000366 8BF4                   BF          L83
               mnet.c        641    #endif
               mnet.c        642    
               mnet.c        643              // SETリクエスト
               mnet.c        644              if( sw )
    00000368 2EE8                   TST         R14,R14
    0000036A 891D                   BT          L89
               mnet.c        645              {
               mnet.c        646                  wdata |= mskbit;
    0000036C 62F0                   MOV.B       @R15,R2    ; mskbit
    0000036E A01E                   BRA         L90
    00000370 212B                   OR          R2,R1
    00000372              L618:
    00000372 00000002               .RES.W      1
    00000374 <00000000>             .DATA.L     _IsExist
    00000378 <00000000>             .DATA.L     _MNET_DRV_TYPE
    0000037C <00000000>             .DATA.L     _IsEncoderExist
    00000380 <00000000>             .DATA.L     __$SetRenv1Fu
    00000384 <00000000>             .DATA.L     __$SetRenv2Fu
    00000388 <00000000>             .DATA.L     __$SetRenv3Fu
    0000038C 0C008000               .DATA.L     H'0C008000
    00000390 <00000000>             .DATA.L     _pMotionnet
    00000394 <00000000>             .DATA.L     _GetInputDat
    00000398 <00000000>             .DATA.L     _DpumpStop
    0000039C <00000000>             .DATA.L     _SetDpumpDuty
    000003A0 <00000000>             .DATA.L     _DpumpStart
    000003A4 <00000000>             .DATA.L     _OUTPUTCH_INFTBL
    000003A8              L89:
               mnet.c        647              }
               mnet.c        648              // CLRリクエスト
               mnet.c        649              else
               mnet.c        650              {
               mnet.c        651                  wdata &= (~mskbit);
    000003A8 66F0                   MOV.B       @R15,R6    ; mskbit
    000003AA 6267                   NOT         R6,R2
    000003AC 2129                   AND         R2,R1
    000003AE              L90:
    000003AE 621C                   EXTU.B      R1,R2
    000003B0 34CC                   ADD         R12,R4
               mnet.c        652              }
               mnet.c        653    
               mnet.c        654    // 本モード
               mnet.c        655    #if DEBUG_SIM_MODE == 0
               mnet.c        656              // 指定Chへ出力
               mnet.c        657              for( cnt = 0; cnt < READ_RTY_MAX; cnt++ )
    000003B2 6013                   MOV         R1,R0
    000003B4 80F8                   MOV.B       R0,@(8,R15); wdata
    000003B6 1F23                   MOV.L       R2,@(12,R15)
    000003B8 6E43                   MOV         R4,R14
    000003BA EA03                   MOV         #3,R10     ; H'00000003
    000003BC              L91:
               mnet.c        658              {
               mnet.c        659                  MAC_WRIT( pMotionnet->portData[devno][portno], wdata  );
    000003BC 84F8                   MOV.B       @(8,R15),R0; wdata
    000003BE 6103                   MOV         R0,R1
    000003C0 3E010100               MOV.B       R0,@(256:12,R14); pMotionnet->portData[]
    000003C4 E605                   MOV         #5,R6      ; H'00000005
    000003C6 60C3                   MOV         R12,R0
    000003C8              L93:
    000003C8 6492                   MOV.L       @R9,R4     ; pMotionnet
    000003CA 4610                   DT          R6
    000003CC 34DC                   ADD         R13,R4
    000003CE 8FFB                   BF/S        L93
    000003D0 0414                   MOV.B       R1,@(R0,R4); pMotionnet->portData[]
               mnet.c        660                  g_Sleep(waittim);
    000003D2 D388                   MOV.L       L619,R3    ; _g_Sleep
    000003D4 430B                   JSR         @R3
    000003D6 E43C                   MOV         #60,R4     ; H'0000003C
               mnet.c        661                  MAC_READ( pMotionnet->portData[devno][portno], rdata );
    000003D8 6E92                   MOV.L       @R9,R14    ; pMotionnet
    000003DA E500                   MOV         #0,R5      ; H'00000000
    000003DC 3ECC                   ADD         R12,R14
    000003DE 37E18100               MOVU.B      @(256,R14),R7; pMotionnet->portData[]
    000003E2 6473                   MOV         R7,R4
    000003E4              L95:
    000003E4 32E18100               MOVU.B      @(256,R14),R2; pMotionnet->portData[]
    000003E8 3240                   CMP/EQ      R4,R2
    000003EA 8902                   BT          L97
    000003EC E500                   MOV         #0,R5      ; H'00000000
    000003EE 6723                   MOV         R2,R7
    000003F0 6423                   MOV         R2,R4
    000003F2              L97:
    000003F2 7501                   ADD         #1,R5
    000003F4 35B3                   CMP/GE      R11,R5
    000003F6 8BF5                   BF          L95
    000003F8 56F3                   MOV.L       @(12,R15),R6
               mnet.c        662                  if( wdata == rdata )    break;
    000003FA 627C                   EXTU.B      R7,R2
    000003FC 3620                   CMP/EQ      R2,R6
    000003FE 8901                   BT          L75
    00000400 4A10                   DT          R10
    00000402 8BDB                   BF          L91
    00000404              L75:
    00000404 7F10                   ADD         #16,R15
    00000406 49F4                   MOVMU.L     @R15+,R9
    00000408 006B                   RTS/N
               mnet.c        663              }
               mnet.c        664    #endif
               mnet.c        665          }
               mnet.c        666      }
               mnet.c        667    }
               mnet.c        668    
               mnet.c        669    /******************************************************************************
               mnet.c        670    * 
               mnet.c        671    * [概要]  パトライト専用出力
               mnet.c        672    * [引数]  sw      ON:HIGH出力、OFF:LOW出力
               mnet.c        673    * [戻り値]    −
               mnet.c        674    * 
               mnet.c        675    ******************************************************************************/
               mnet.c        676    void pio_PATOUT(UB sw1, UB sw2, UB sw3)
    0000040A              _pio_PATOUT:                     ; function: pio_PATOUT
                                                           ; frame size=32
    0000040A 2F86                   MOV.L       R8,@-R15
    0000040C 2F96                   MOV.L       R9,@-R15
    0000040E 2FA6                   MOV.L       R10,@-R15
    00000410 2FB6                   MOV.L       R11,@-R15
    00000412 2FC6                   MOV.L       R12,@-R15
    00000414 2FD6                   MOV.L       R13,@-R15
    00000416 2FE6                   MOV.L       R14,@-R15
    00000418 7FFC                   ADD         #-4,R15
    0000041A D977                   MOV.L       L619+4,R9  ; _OUTPUTCH_INFTBL
               mnet.c        677    {
               mnet.c        678      UB data1 = 0;
               mnet.c        679      UB data2 = 0;
               mnet.c        680      UB mskbit = 0;
               mnet.c        681      UB devcno1 = 0;
               mnet.c        682      UB portno1 = 0;
               mnet.c        683      UB devcno2 = 0;
               mnet.c        684      UB portno2 = 0;
               mnet.c        685    
               mnet.c        686    // 本モード
               mnet.c        687    #if DEBUG_SIM_MODE == 0
               mnet.c        688      devcno1 = OUTPUTCH_INFTBL[O_PATLRED][0];
    0000041C 684C                   EXTU.B      R4,R8
    0000041E ED01                   MOV         #1,R13     ; H'00000001
    00000420 32918015               MOVU.B      @(21,R9),R2; OUTPUTCH_INFTBL[]
    00000424 D475                   MOV.L       L619+8,R4  ; _pMotionnet
               mnet.c        689      portno1 = OUTPUTCH_INFTBL[O_PATLRED][1];
    00000426 3A918016               MOVU.B      @(22,R9),R10; OUTPUTCH_INFTBL[]
    0000042A 6B42                   MOV.L       @R4,R11    ; pMotionnet
               mnet.c        690      MAC_READ( pMotionnet->portData[devcno1][portno1], data1 );
    0000042C 4208                   SHLL2       R2
    0000042E 4D18                   SHLL8       R13
    00000430 EC05                   MOV         #5,R12     ; H'00000005
    00000432 6053                   MOV         R5,R0
    00000434 80F3                   MOV.B       R0,@(3,R15); sw2
    00000436 6023                   MOV         R2,R0
    00000438 30AC                   ADD         R10,R0
    0000043A 3BDC                   ADD         R13,R11
    0000043C 3A2C                   ADD         R2,R10
    0000043E 06BC                   MOV.B       @(R0,R11),R6; pMotionnet->portData[]
    00000440 60A3                   MOV         R10,R0
    00000442 E500                   MOV         #0,R5      ; H'00000000
    00000444 616C                   EXTU.B      R6,R1
    00000446 6413                   MOV         R1,R4
    00000448              L102:
    00000448 02BC                   MOV.B       @(R0,R11),R2; pMotionnet->portData[]
    0000044A 662C                   EXTU.B      R2,R6
    0000044C 3640                   CMP/EQ      R4,R6
    0000044E 8902                   BT          L104
    00000450 E500                   MOV         #0,R5      ; H'00000000
    00000452 6163                   MOV         R6,R1
    00000454 6463                   MOV         R6,R4
    00000456              L104:
    00000456 7501                   ADD         #1,R5
    00000458 35C3                   CMP/GE      R12,R5
    0000045A 8BF5                   BF          L102
               mnet.c        691      
               mnet.c        692      devcno2 = OUTPUTCH_INFTBL[O_PATLGRN][0];
    0000045C 32918018               MOVU.B      @(24,R9),R2; OUTPUTCH_INFTBL[]
               mnet.c        693      portno2 = OUTPUTCH_INFTBL[O_PATLGRN][1];
    00000460 3E918019               MOVU.B      @(25,R9),R14; OUTPUTCH_INFTBL[]
               mnet.c        694      MAC_READ( pMotionnet->portData[devcno2][portno2], data2 );
    00000464 4208                   SHLL2       R2
    00000466 E500                   MOV         #0,R5      ; H'00000000
    00000468 6023                   MOV         R2,R0
    0000046A 30EC                   ADD         R14,R0
    0000046C 06BC                   MOV.B       @(R0,R11),R6; pMotionnet->portData[]
    0000046E 3E2C                   ADD         R2,R14
    00000470 60E3                   MOV         R14,R0
    00000472 676C                   EXTU.B      R6,R7
    00000474 6473                   MOV         R7,R4
    00000476              L107:
    00000476 02BC                   MOV.B       @(R0,R11),R2; pMotionnet->portData[]
    00000478 662C                   EXTU.B      R2,R6
    0000047A 3640                   CMP/EQ      R4,R6
    0000047C 8902                   BT          L109
    0000047E E500                   MOV         #0,R5      ; H'00000000
    00000480 6763                   MOV         R6,R7
    00000482 6463                   MOV         R6,R4
    00000484              L109:
    00000484 7501                   ADD         #1,R5
    00000486 35C3                   CMP/GE      R12,R5
    00000488 8BF5                   BF          L107
               mnet.c        695      
               mnet.c        696    #endif
               mnet.c        697    
               mnet.c        698      // 赤
               mnet.c        699      mskbit  = OUTPUTCH_INFTBL[O_PATLRED][2];
               mnet.c        700      if( sw1 )
    0000048A 2888                   TST         R8,R8
    0000048C 32914017               MOV.B       @(23:12,R9),R2; OUTPUTCH_INFTBL[]
    00000490 8901                   BT          L113
               mnet.c        701      {
               mnet.c        702          data1 |= mskbit;
    00000492 A002                   BRA         L114
    00000494 212B                   OR          R2,R1
    00000496              L113:
               mnet.c        703      }
               mnet.c        704      else
               mnet.c        705      {
               mnet.c        706          data1 &= (~mskbit);
    00000496 6227                   NOT         R2,R2
    00000498 2129                   AND         R2,R1
    0000049A              L114:
               mnet.c        707      }
               mnet.c        708    
               mnet.c        709      // 緑
               mnet.c        710      mskbit  = OUTPUTCH_INFTBL[O_PATLGRN][2];
               mnet.c        711      if( sw2 )
    0000049A 84F3                   MOV.B       @(3,R15),R0; sw2
    0000049C 3291401A               MOV.B       @(26:12,R9),R2; OUTPUTCH_INFTBL[]
    000004A0 2008                   TST         R0,R0
    000004A2 8901                   BT          L116
               mnet.c        712      {
               mnet.c        713          data2 |= mskbit;
    000004A4 A002                   BRA         L117
    000004A6 272B                   OR          R2,R7
    000004A8              L116:
               mnet.c        714      }
               mnet.c        715      else
               mnet.c        716      {
               mnet.c        717          data2 &= (~mskbit);
    000004A8 6227                   NOT         R2,R2
    000004AA 2729                   AND         R2,R7
    000004AC              L117:
               mnet.c        718      }
               mnet.c        719      
               mnet.c        720    // 本モード
               mnet.c        721    #if DEBUG_SIM_MODE == 0
               mnet.c        722      MAC_WRIT( pMotionnet->portData[devcno1][portno1], data1 );
    000004AC 60A3                   MOV         R10,R0
    000004AE 0B14                   MOV.B       R1,@(R0,R11); pMotionnet->portData[]
    000004B0 60A3                   MOV         R10,R0
    000004B2 E605                   MOV         #5,R6      ; H'00000005
    000004B4 D251                   MOV.L       L619+8,R2  ; _pMotionnet
    000004B6              L118:
    000004B6 6522                   MOV.L       @R2,R5     ; pMotionnet
    000004B8 4610                   DT          R6
    000004BA 35DC                   ADD         R13,R5
    000004BC 8FFB                   BF/S        L118
    000004BE 0514                   MOV.B       R1,@(R0,R5); pMotionnet->portData[]
               mnet.c        723      MAC_WRIT( pMotionnet->portData[devcno2][portno2], data2 );
    000004C0 6422                   MOV.L       @R2,R4     ; pMotionnet
    000004C2 60E3                   MOV         R14,R0
    000004C4 D24D                   MOV.L       L619+8,R2  ; _pMotionnet
    000004C6 34DC                   ADD         R13,R4
    000004C8 E605                   MOV         #5,R6      ; H'00000005
    000004CA 0474                   MOV.B       R7,@(R0,R4); pMotionnet->portData[]
    000004CC 60E3                   MOV         R14,R0
    000004CE              L120:
    000004CE 6522                   MOV.L       @R2,R5     ; pMotionnet
    000004D0 4610                   DT          R6
    000004D2 35DC                   ADD         R13,R5
    000004D4 8FFB                   BF/S        L120
    000004D6 0574                   MOV.B       R7,@(R0,R5); pMotionnet->portData[]
    000004D8 7F04                   ADD         #4,R15
    000004DA 6EF6                   MOV.L       @R15+,R14
    000004DC 6DF6                   MOV.L       @R15+,R13
    000004DE 6CF6                   MOV.L       @R15+,R12
    000004E0 6BF6                   MOV.L       @R15+,R11
    000004E2 6AF6                   MOV.L       @R15+,R10
    000004E4 69F6                   MOV.L       @R15+,R9
               mnet.c        724    #endif
               mnet.c        725    }
    000004E6 000B                   RTS
    000004E8 68F6                   MOV.L       @R15+,R8
               mnet.c        726    
               mnet.c        727    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        728    // 
               mnet.c        729    // モータ系
               mnet.c        730    // 
               mnet.c        731    //■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c        732    /*-----------------------------------------------------------------------------
               mnet.c        733      機能：速度の設定
               mnet.c        734      機能：no      モータ番号
               mnet.c        735            type    １：Ｓ字、０：台形
               mnet.c        736            resol   速度倍率
               mnet.c        737            lspd    初速[Hz]
               mnet.c        738            hspd    高速[Hz]
               mnet.c        739            tim     加減速時間
               mnet.c        740            sarea   Ｓ字変速領域[Hz] ※台形の時は無視
               mnet.c        741      戻値：エラーコード
               mnet.c        742     ----------------------------------------------------------------------------*/
               mnet.c        743    ER motor_SET(UB pm, ST_MOTOR_PARAM mp)
    000004EA              _motor_SET:                      ; function: motor_SET
                                                           ; frame size=52
    000004EA 4DF0                   MOVMU.L     R13,@-R15
    000004EC 7FD8                   ADD         #-40,R15
               mnet.c        744    {
               mnet.c        745      ER Result = E_SUCCESS ;
               mnet.c        746      PM_REG  pm_reg = {0};
    000004EE D544                   MOV.L       L619+12,R5 ; L648
    000004F0 6252                   MOV.L       @R5,R2
    000004F2 E601                   MOV         #1,R6      ; H'00000001
    000004F4 5151                   MOV.L       @(4,R5),R1
    000004F6 5752                   MOV.L       @(8,R5),R7
    000004F8 5D53                   MOV.L       @(12,R5),R13
    000004FA 2F22                   MOV.L       R2,@R15    ; (part of)pm_reg
    000004FC 1F11                   MOV.L       R1,@(4,R15); (part of)pm_reg
    000004FE 1F72                   MOV.L       R7,@(8,R15); (part of)pm_reg
    00000500 1FD3                   MOV.L       R13,@(12,R15); (part of)pm_reg
    00000502 5D54                   MOV.L       @(16,R5),R13
    00000504 5E55                   MOV.L       @(20,R5),R14
    00000506 1FD4                   MOV.L       R13,@(16,R15); (part of)pm_reg
               mnet.c        747    
               mnet.c        748      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000508 6D4C                   EXTU.B      R4,R13
    0000050A 1FE5                   MOV.L       R14,@(20,R15); (part of)pm_reg
    0000050C 3D63                   CMP/GE      R6,R13
    0000050E 5156                   MOV.L       @(24,R5),R1
    00000510 5E57                   MOV.L       @(28,R5),R14
    00000512 5758                   MOV.L       @(32,R5),R7
    00000514 5259                   MOV.L       @(36,R5),R2
    00000516 1F16                   MOV.L       R1,@(24,R15); (part of)pm_reg
    00000518 1FE7                   MOV.L       R14,@(28,R15); (part of)pm_reg
    0000051A 1F78                   MOV.L       R7,@(32,R15); (part of)pm_reg
    0000051C 8F40                   BF/S        L124
    0000051E 1F29                   MOV.L       R2,@(36,R15); (part of)pm_reg
    00000520 E207                   MOV         #7,R2      ; H'00000007
    00000522 3D27                   CMP/GT      R2,R13
    00000524 893C                   BT          L124
               mnet.c        749    
               mnet.c        750    // シュミレーションモード
               mnet.c        751    #if DEBUG_SIM_MODE != 0
               mnet.c        752      return (E_SUCCESS );
               mnet.c        753    #endif
               mnet.c        754      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00000526 D637                   MOV.L       L619+16,R6 ; _MNET_DRV_TYPE
    00000528 6E4C                   EXTU.B      R4,R14
    0000052A 60E3                   MOV         R14,R0
    0000052C 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    0000052E 880A                   CMP/EQ      #10,R0
    00000530 8B01                   BF          L127
               mnet.c        755      {
               mnet.c        756          return( E_SUCCESS );
    00000532 A037                   BRA         L128
    00000534 E000                   MOV         #0,R0      ; H'00000000
    00000536              L127:
               mnet.c        757      }
               mnet.c        758    
               mnet.c        759      // PCD4611通信接続時
               mnet.c        760      if( MNET_DRV_TYPE[pm] == PCD4611 )
    00000536 8809                   CMP/EQ      #9,R0
    00000538 65F3                   MOV         R15,R5
    0000053A 64F3                   MOV         R15,R4
    0000053C 8F04                   BF/S        L130
    0000053E 7434                   ADD         #52,R4
               mnet.c        761      {
               mnet.c        762          Result = motor_CalcMotorRegPCD4611(&mp, &pm_reg);
    00000540 D331                   MOV.L       L619+20,R3 ; __$motor_CalcMotorRegPCD4611
    00000542 434B                   JSR/N       @R3
    00000544 A002                   BRA         L131
    00000546 0009                   NOP
    00000548              L130:
               mnet.c        763      }
               mnet.c        764      else
               mnet.c        765      {
               mnet.c        766          Result = motor_CalcMotorReg(&mp, &pm_reg);
    00000548 D330                   MOV.L       L619+24,R3 ; __$motor_CalcMotorReg
    0000054A 434B                   JSR/N       @R3
    0000054C              L131:
    0000054C 2008                   TST         R0,R0
               mnet.c        767      }
               mnet.c        768    
               mnet.c        769      if( Result != E_SUCCESS)                                return( Result );
    0000054E 8F25                   BF/S        L133
    00000550 6203                   MOV         R0,R2
               mnet.c        770      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm )); // デバイス接続確認
    00000552 B60D                   BSR         _IsExist
    00000554 64D3                   MOV         R13,R4
    00000556 2008                   TST         R0,R0
    00000558 8B04                   BF          L135
    0000055A E604                   MOV         #4,R6      ; H'00000004
    0000055C 4618                   SHLL8       R6
    0000055E 3E6C                   ADD         R6,R14
    00000560 A020                   BRA         L128
    00000562 60E3                   MOV         R14,R0
    00000564              L135:
               mnet.c        771      if (motor_IsBusy(pm))                                   return(( E_BUSY + pm ));    // ビジー確認
    00000564 B63F                   BSR         _motor_IsBusy
    00000566 64D3                   MOV         R13,R4
    00000568 2008                   TST         R0,R0
    0000056A 8904                   BT          L137
    0000056C E601                   MOV         #1,R6      ; H'00000001
    0000056E 4618                   SHLL8       R6
    00000570 3E6C                   ADD         R6,R14
    00000572 A017                   BRA         L128
    00000574 60E3                   MOV         R14,R0
    00000576              L137:
               mnet.c        772    
               mnet.c        773      _pmInfo[pm].reg[R1] = pm_reg.reg[R1];
    00000576 E064                   MOV         #100,R0    ; H'00000064
    00000578 54F1                   MOV.L       @(4,R15),R4; pm_reg.reg[]
    0000057A 4E80                   MULR        R0,R14
    0000057C D124                   MOV.L       L619+28,R1 ; __$_pmInfo
               mnet.c        774      _pmInfo[pm].reg[R2] = pm_reg.reg[R2];
    0000057E 55F2                   MOV.L       @(8,R15),R5; pm_reg.reg[]
               mnet.c        775      _pmInfo[pm].reg[R3] = pm_reg.reg[R3];
    00000580 56F3                   MOV.L       @(12,R15),R6; pm_reg.reg[]
    00000582 3E1C                   ADD         R1,R14
               mnet.c        776      _pmInfo[pm].reg[R4] = pm_reg.reg[R4];
    00000584 57F4                   MOV.L       @(16,R15),R7; pm_reg.reg[]
    00000586 1E4A                   MOV.L       R4,@(40,R14); _pmInfo[].reg[]
               mnet.c        777      _pmInfo[pm].reg[R5] = pm_reg.reg[R5];
               mnet.c        778      _pmInfo[pm].reg[R6] = pm_reg.reg[R6];
               mnet.c        779    
               mnet.c        780      Result =  motor_SetAllRegister(pm);
    00000588 64D3                   MOV         R13,R4
    0000058A 1E5B                   MOV.L       R5,@(44,R14); _pmInfo[].reg[]
    0000058C 51F5                   MOV.L       @(20,R15),R1; pm_reg.reg[]
    0000058E 55F6                   MOV.L       @(24,R15),R5; pm_reg.reg[]
    00000590 1E6C                   MOV.L       R6,@(48,R14); _pmInfo[].reg[]
    00000592 1E7D                   MOV.L       R7,@(52,R14); _pmInfo[].reg[]
    00000594 1E1E                   MOV.L       R1,@(56,R14); _pmInfo[].reg[]
    00000596 B735                   BSR         __$motor_SetAllRegister
    00000598 1E5F                   MOV.L       R5,@(60,R14); _pmInfo[].reg[]
    0000059A 6203                   MOV         R0,R2
    0000059C              L133:
    0000059C A002                   BRA         L128
    0000059E 6023                   MOV         R2,R0
    000005A0              L124:
    000005A0 00000801               MOVI20      #2049,R0   ; H'00000801
    000005A4              L128:
    000005A4 7F28                   ADD         #40,R15
    000005A6 4DF4                   MOVMU.L     @R15+,R13
               mnet.c        781      if( Result != E_SUCCESS )                               return( Result );
               mnet.c        782    
               mnet.c        783      return Result;
               mnet.c        784    }
    000005A8 006B                   RTS/N
               mnet.c        785    
               mnet.c        786    /******************************************************************************
               mnet.c        787    * 
               mnet.c        788    * [概要]  アドレスカウンタのリセット
               mnet.c        789    * [引数]  pm:モータ番号、cnt:カウント設定値、enc:エンコーダ設定値、dv:未使用、def:偏差カウンタ
               mnet.c        790    * [戻値]  エラーコード
               mnet.c        791    * 
               mnet.c        792    ******************************************************************************/
               mnet.c        793    ER motor_PSET(UB pm, INT cnt, INT enc, INT def)
    000005AA              _motor_PSET:                     ; function: motor_PSET
                                                           ; frame size=28
    000005AA 4AF0                   MOVMU.L     R10,@-R15
    000005AC 7FFC                   ADD         #-4,R15
    000005AE 6B4C                   EXTU.B      R4,R11
    000005B0 E101                   MOV         #1,R1      ; H'00000001
    000005B2 3B13                   CMP/GE      R1,R11
               mnet.c        794    {
               mnet.c        795      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    000005B4 6A73                   MOV         R7,R10
    000005B6 6C63                   MOV         R6,R12
    000005B8 8F5D                   BF/S        L140
    000005BA 6D53                   MOV         R5,R13
    000005BC E207                   MOV         #7,R2      ; H'00000007
    000005BE 3B27                   CMP/GT      R2,R11
    000005C0 8959                   BT          L140
               mnet.c        796    
               mnet.c        797    // シュミレーションモード
               mnet.c        798    #if DEBUG_SIM_MODE != 0
               mnet.c        799      return (E_SUCCESS );
               mnet.c        800    #endif
               mnet.c        801      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    000005C2 D610                   MOV.L       L619+16,R6 ; _MNET_DRV_TYPE
    000005C4 6E4C                   EXTU.B      R4,R14
    000005C6 36EC                   ADD         R14,R6
    000005C8 6060                   MOV.B       @R6,R0     ; MNET_DRV_TYPE[]
    000005CA 880A                   CMP/EQ      #10,R0
    000005CC 8D51                   BT/S        L143
    000005CE 2F62                   MOV.L       R6,@R15
               mnet.c        802      {
               mnet.c        803          return( E_SUCCESS );
               mnet.c        804      }
               mnet.c        805    
               mnet.c        806      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm )); // デバイス接続確認
    000005D0 B5CE                   BSR         _IsExist
    000005D2 64B3                   MOV         R11,R4
    000005D4 2008                   TST         R0,R0
    000005D6 8B04                   BF          L145
    000005D8 E604                   MOV         #4,R6      ; H'00000004
    000005DA 4618                   SHLL8       R6
    000005DC 3E6C                   ADD         R6,R14
    000005DE A04C                   BRA         L146
    000005E0 60E3                   MOV         R14,R0
    000005E2              L145:
               mnet.c        807      if (motor_IsBusy(pm))                                   return(( E_BUSY + pm ));    // ビジー確認
    000005E2 B600                   BSR         _motor_IsBusy
    000005E4 64B3                   MOV         R11,R4
    000005E6 2008                   TST         R0,R0
    000005E8 8914                   BT          L148
    000005EA E601                   MOV         #1,R6      ; H'00000001
    000005EC 4618                   SHLL8       R6
    000005EE 3E6C                   ADD         R6,R14
    000005F0 A043                   BRA         L146
    000005F2 60E3                   MOV         R14,R0
    000005F4              L619:
    000005F4 <00000000>             .DATA.L     _g_Sleep
    000005F8 <00000000>             .DATA.L     _OUTPUTCH_INFTBL
    000005FC <00000000>             .DATA.L     _pMotionnet
    00000600 <00000000>             .DATA.L     L648
    00000604 <00000000>             .DATA.L     _MNET_DRV_TYPE
    00000608 <00000000>             .DATA.L     __$motor_CalcMotorRegPCD4611
    0000060C <00000000>             .DATA.L     __$motor_CalcMotorReg
    00000610 <00000000>             .DATA.L     __$_pmInfo
    00000614              L148:
    00000614 E064                   MOV         #100,R0    ; H'00000064
    00000616 E5A3                   MOV         #-93,R5    ; H'FFFFFFA3
    00000618 4E80                   MULR        R0,R14
               mnet.c        808    
               mnet.c        809      _pmInfo[pm].pos = cnt;
    0000061A D27B                   MOV.L       L620+2,R2  ; H'00000050+__$_pmInfo
    0000061C 66D3                   MOV         R13,R6
    0000061E 64B3                   MOV         R11,R4
    00000620 60E3                   MOV         R14,R0
    00000622 02D6                   MOV.L       R13,@(R0,R2); _pmInfo[].pos
               mnet.c        810    
               mnet.c        811      // PCD4611通信接続時
               mnet.c        812      if( MNET_DRV_TYPE[pm] == PCD4611 )
    00000624 62F2                   MOV.L       @R15,R2
    00000626 6020                   MOV.B       @R2,R0     ; MNET_DRV_TYPE[]
    00000628 8809                   CMP/EQ      #9,R0
    0000062A 8F06                   BF/S        L150
    0000062C 655C                   EXTU.B      R5,R5
               mnet.c        813      {
               mnet.c        814          if (!SetMotorRegisterInt(pm, WRG_RCUN1, cnt))       return(( E_MNT_ACCESS + WRG_RCUN1 ));
    0000062E B4B6                   BSR         _SetMotorRegisterInt
    00000630 0009                   NOP
    00000632 2008                   TST         R0,R0
    00000634 8919                   BT          L151
    00000636 A01C                   BRA         L143
    00000638 0009                   NOP
    0000063A              L150:
               mnet.c        815      }
               mnet.c        816      else
               mnet.c        817      {
               mnet.c        818          if (!SetMotorRegisterInt(pm, WRG_RCUN1, cnt))       return(( E_MNT_ACCESS + WRG_RCUN1 ));
    0000063A B4B0                   BSR         _SetMotorRegisterInt
    0000063C 0009                   NOP
    0000063E 2008                   TST         R0,R0
    00000640 8913                   BT          L151
               mnet.c        819          if (!SetMotorRegisterInt(pm, WRG_RCUN2, enc))       return(( E_MNT_ACCESS + WRG_RCUN2 ));
    00000642 E5A4                   MOV         #-92,R5    ; H'FFFFFFA4
    00000644 66C3                   MOV         R12,R6
    00000646 655C                   EXTU.B      R5,R5
    00000648 B4A9                   BSR         _SetMotorRegisterInt
    0000064A 64B3                   MOV         R11,R4
    0000064C 2008                   TST         R0,R0
    0000064E 000005A4               MOVI20      #1444,R0   ; H'000005A4
    00000652 8912                   BT          L146
               mnet.c        820          if (!SetMotorRegisterInt(pm, WRG_RCUN3, def))       return(( E_MNT_ACCESS + WRG_RCUN3 ));
    00000654 E5A5                   MOV         #-91,R5    ; H'FFFFFFA5
    00000656 66A3                   MOV         R10,R6
    00000658 655C                   EXTU.B      R5,R5
    0000065A B4A0                   BSR         _SetMotorRegisterInt
    0000065C 64B3                   MOV         R11,R4
    0000065E 2008                   TST         R0,R0
    00000660 8B07                   BF          L143
    00000662 000005A5               MOVI20      #1445,R0   ; H'000005A5
    00000666 A008                   BRA         L146
    00000668 0009                   NOP
    0000066A              L151:
    0000066A 000005A3               MOVI20      #1443,R0   ; H'000005A3
    0000066E A004                   BRA         L146
    00000670 0009                   NOP
    00000672              L143:
    00000672 A002                   BRA         L146
    00000674 E000                   MOV         #0,R0      ; H'00000000
    00000676              L140:
    00000676 00000801               MOVI20      #2049,R0   ; H'00000801
    0000067A              L146:
    0000067A 7F04                   ADD         #4,R15
    0000067C 4AF4                   MOVMU.L     @R15+,R10
               mnet.c        821      }
               mnet.c        822    
               mnet.c        823      return( E_SUCCESS );
               mnet.c        824    }
    0000067E 006B                   RTS/N
               mnet.c        825    
               mnet.c        826    /*-----------------------------------------------------------------------------
               mnet.c        827      機能：絶対アドレス移動
               mnet.c        828      機能：pm      モータ番号
               mnet.c        829            pos     目的地パルス
               mnet.c        830            status  動作指定
               mnet.c        831      戻値：エラーコード
               mnet.c        832     ----------------------------------------------------------------------------*/
               mnet.c        833    ER motor_ABSMV(UB pm, INT pos, UB status)
    00000680              _motor_ABSMV:                    ; function: motor_ABSMV
                                                           ; frame size=36
    00000680 4AF0                   MOVMU.L     R10,@-R15
    00000682 7FF4                   ADD         #-12,R15
    00000684 4511                   CMP/PZ      R5
               mnet.c        834    {
               mnet.c        835      INT rcnt1 = 0;
               mnet.c        836      ER  Result = E_SUCCESS;
               mnet.c        837      UH  dir = (pos >=0 ? CW : CCW);
    00000686 6B53                   MOV         R5,R11
    00000688 6C63                   MOV         R6,R12
    0000068A 8F01                   BF/S        L157
    0000068C ED02                   MOV         #2,R13     ; H'00000002
    0000068E ED01                   MOV         #1,R13     ; H'00000001
    00000690              L157:
               mnet.c        838    
               mnet.c        839      if (pm < DVMIN || DVMAX < pm)           return((E_PAR_OUTRNG + PARAM1));
    00000690 6A4C                   EXTU.B      R4,R10
    00000692 E601                   MOV         #1,R6      ; H'00000001
    00000694 3A63                   CMP/GE      R6,R10
    00000696 8B75                   BF          L158
    00000698 E207                   MOV         #7,R2      ; H'00000007
    0000069A 3A27                   CMP/GT      R2,R10
    0000069C 8972                   BT          L158
               mnet.c        840    
               mnet.c        841    // シュミレーションモード
               mnet.c        842    #if DEBUG_SIM_MODE != 0
               mnet.c        843      return (E_SUCCESS );
               mnet.c        844    #endif
               mnet.c        845      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    0000069E D65B                   MOV.L       L620+6,R6  ; _MNET_DRV_TYPE
    000006A0 6E4C                   EXTU.B      R4,R14
    000006A2 36EC                   ADD         R14,R6
    000006A4 6060                   MOV.B       @R6,R0     ; MNET_DRV_TYPE[]
    000006A6 880A                   CMP/EQ      #10,R0
    000006A8 8D6A                   BT/S        L162
    000006AA 2F62                   MOV.L       R6,@R15
               mnet.c        846      {
               mnet.c        847          return( E_SUCCESS );
               mnet.c        848      }
               mnet.c        849    
               mnet.c        850      if (!IsExist( pm ))                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    000006AC B560                   BSR         _IsExist
    000006AE 64A3                   MOV         R10,R4
    000006B0 2008                   TST         R0,R0
    000006B2 8960                   BT          L164
               mnet.c        851      if (motor_IsBusy(pm))                   return(( E_BUSY + pm ));        // ビジー確認
    000006B4 B597                   BSR         _motor_IsBusy
    000006B6 64A3                   MOV         R10,R4
    000006B8 2008                   TST         R0,R0
    000006BA 8B57                   BF          L166
               mnet.c        852      if (motor_IsLimit(pm, dir))             return( E_SUCCESS );            // 現在リミットか確認
    000006BC 65DD                   EXTU.W      R13,R5
    000006BE B5D3                   BSR         _motor_IsLimit
    000006C0 64A3                   MOV         R10,R4
    000006C2 2008                   TST         R0,R0
    000006C4 8B5C                   BF          L162
               mnet.c        853    
               mnet.c        854      motor_SetAllRegister(pm);                                               // Limit後だとLimit時の速さのままとなるため、ここで通常の設定速度に変更
    000006C6 B69D                   BSR         __$motor_SetAllRegister
    000006C8 64A3                   MOV         R10,R4
               mnet.c        855      SetMotorCommand (pm, CMD_INTRS);                                        // 割込み出力リセット
    000006CA E508                   MOV         #8,R5      ; H'00000008
    000006CC B449                   BSR         __$SetMotorCommand
    000006CE 64A3                   MOV         R10,R4
               mnet.c        856      _pmInfo[pm].reg[R0]     = (INT)pos;
    000006D0 E064                   MOV         #100,R0    ; H'00000064
               mnet.c        857    
               mnet.c        858      _pmInfo[pm].startParam  = CMD_STAUD;                                    // スタートコマンド動作指定
    000006D2 E253                   MOV         #83,R2     ; H'00000053
    000006D4 4E80                   MULR        R0,R14
    000006D6 D14E                   MOV.L       L620+10,R1 ; __$_pmInfo
               mnet.c        859      if( status == REQ_STAFH )   _pmInfo[pm].startParam  = CMD_STAFH;
    000006D8 60CC                   EXTU.B      R12,R0
    000006DA 8801                   CMP/EQ      #1,R0
    000006DC 3E1C                   ADD         R1,R14
    000006DE 1EB9                   MOV.L       R11,@(36,R14); _pmInfo[].reg[]
    000006E0 3E211030               MOV.W       R2,@(96:12,R14); _pmInfo[].startParam
    000006E4 8906                   BT          L169
    000006E6 8802                   CMP/EQ      #2,R0
    000006E8 8B07                   BF          L170
               mnet.c        860      if( status == REQ_STAFL )   _pmInfo[pm].startParam  = CMD_STAFL;
    000006EA E550                   MOV         #80,R5     ; H'00000050
    000006EC 3E511030               MOV.W       R5,@(96:12,R14); _pmInfo[].startParam
    000006F0 A003                   BRA         L170
    000006F2 0009                   NOP
    000006F4              L169:
    000006F4 E551                   MOV         #81,R5     ; H'00000051
    000006F6 3E511030               MOV.W       R5,@(96:12,R14); _pmInfo[].startParam
    000006FA              L170:
               mnet.c        861      _pmInfo[pm].paused      = FALSE;
               mnet.c        862    
               mnet.c        863      
               mnet.c        864      // PCD4611通信接続時
               mnet.c        865      if( MNET_DRV_TYPE[pm] == PCD4611 )
    000006FA 66F2                   MOV.L       @R15,R6
    000006FC E500                   MOV         #0,R5      ; H'00000000
    000006FE 3E512016               MOV.L       R5,@(88:12,R14); _pmInfo[].paused
    00000702 6060                   MOV.B       @R6,R0     ; MNET_DRV_TYPE[]
    00000704 8809                   CMP/EQ      #9,R0
    00000706 8915                   BT          L173
               mnet.c        866      {
               mnet.c        867          WriteMemoryPCD4611(RRG_RCUN1);
               mnet.c        868          rcnt1 = ReadMemoryPCD4611();
               mnet.c        869    
               mnet.c        870          SetMotorRegisterInt( MT_Y0, WRG_RMD, MOD41 );
               mnet.c        871          SetMotorRegisterInt( MT_Y0, WRG_RMV, (pos - rcnt1) );
               mnet.c        872          
               mnet.c        873          WriteMemoryPCD4611( CMD_STAUD );
               mnet.c        874      }
               mnet.c        875      // MNET_BCD4020FU(A)接続時
               mnet.c        876      else
               mnet.c        877      {
               mnet.c        878          Result = SetRenv1Fu( pm );          if( Result != E_SUCCESS )   return( Result );   // RENV1設定
    00000708 D342                   MOV.L       L620+14,R3 ; __$SetRenv1Fu
    0000070A 430B                   JSR         @R3
    0000070C 64A3                   MOV         R10,R4
    0000070E 2008                   TST         R0,R0
    00000710 8F0E                   BF/S        L175
    00000712 6203                   MOV         R0,R2
               mnet.c        879          Result = SetRmdFu( pm, MOD42 );     if( Result != E_SUCCESS )   return( Result );   // RMD設定
    00000714 E542                   MOV         #66,R5     ; H'00000042
    00000716 D340                   MOV.L       L620+18,R3 ; __$SetRmdFu
    00000718 430B                   JSR         @R3
    0000071A 64A3                   MOV         R10,R4
    0000071C 2008                   TST         R0,R0
    0000071E 8F07                   BF/S        L175
    00000720 6203                   MOV         R0,R2
               mnet.c        880          Result = SetRmv( pm, pos );         if( Result != E_SUCCESS )   return( Result );   // RMV設定
    00000722 65B3                   MOV         R11,R5
    00000724 D33D                   MOV.L       L620+22,R3 ; __$SetRmv
    00000726 430B                   JSR         @R3
    00000728 64A3                   MOV         R10,R4
    0000072A 2008                   TST         R0,R0
    0000072C 8D18                   BT/S        L177
    0000072E 6203                   MOV         R0,R2
    00000730              L175:
    00000730 A02A                   BRA         L178
    00000732 6023                   MOV         R2,R0
    00000734              L173:
    00000734 B3CF                   BSR         __$WriteMemoryPCD4611
    00000736 E4E3                   MOV         #-29,R4    ; H'FFFFFFE3
    00000738 B3F3                   BSR         __$ReadMemoryPCD4611
    0000073A 0009                   NOP
    0000073C E597                   MOV         #-105,R5   ; H'FFFFFF97
    0000073E 1F01                   MOV.L       R0,@(4,R15)
    00000740 655C                   EXTU.B      R5,R5
    00000742 E641                   MOV         #65,R6     ; H'00000041
    00000744 6053                   MOV         R5,R0
    00000746 81F4                   MOV.W       R0,@(8,R15)
    00000748 B429                   BSR         _SetMotorRegisterInt
    0000074A E401                   MOV         #1,R4      ; H'00000001
    0000074C 51F1                   MOV.L       @(4,R15),R1
    0000074E E401                   MOV         #1,R4      ; H'00000001
    00000750 85F4                   MOV.W       @(8,R15),R0
    00000752 3B18                   SUB         R1,R11
    00000754 70F9                   ADD         #-7,R0
    00000756 66B3                   MOV         R11,R6
    00000758 B421                   BSR         _SetMotorRegisterInt
    0000075A 6503                   MOV         R0,R5
    0000075C B3BB                   BSR         __$WriteMemoryPCD4611
    0000075E E453                   MOV         #83,R4     ; H'00000053
    00000760              L177:
               mnet.c        881    
               mnet.c        882      }
               mnet.c        883      motor_RegistCommand(pm, CMD_ABSMV);
    00000760 E50A                   MOV         #10,R5     ; H'0000000A
    00000762 D32F                   MOV.L       L620+26,R3 ; __$motor_RegistCommand
    00000764 430B                   JSR         @R3
    00000766 64A3                   MOV         R10,R4
    00000768 A00A                   BRA         L162
    0000076A 0009                   NOP
    0000076C              L166:
    0000076C E601                   MOV         #1,R6      ; H'00000001
    0000076E 4618                   SHLL8       R6
    00000770 3E6C                   ADD         R6,R14
    00000772 A009                   BRA         L178
    00000774 60E3                   MOV         R14,R0
    00000776              L164:
    00000776 E604                   MOV         #4,R6      ; H'00000004
    00000778 4618                   SHLL8       R6
    0000077A 3E6C                   ADD         R6,R14
    0000077C A004                   BRA         L178
    0000077E 60E3                   MOV         R14,R0
    00000780              L162:
    00000780 A002                   BRA         L178
    00000782 E000                   MOV         #0,R0      ; H'00000000
    00000784              L158:
    00000784 00000801               MOVI20      #2049,R0   ; H'00000801
    00000788              L178:
    00000788 7F0C                   ADD         #12,R15
    0000078A 4AF4                   MOVMU.L     @R15+,R10
               mnet.c        884      
               mnet.c        885      return( E_SUCCESS );
               mnet.c        886    }
    0000078C 006B                   RTS/N
               mnet.c        887    /*-----------------------------------------------------------------------------
               mnet.c        888      機能：相対アドレス移動
               mnet.c        889      機能：pm      モータ番号
               mnet.c        890            pos     目的地パルス
               mnet.c        891            status  動作指定
               mnet.c        892      戻値：エラーコード
               mnet.c        893     ----------------------------------------------------------------------------*/
               mnet.c        894    ER motor_RELMV(UB pm, INT pos, UB status)
    0000078E              _motor_RELMV:                    ; function: motor_RELMV
                                                           ; frame size=28
    0000078E 4AF0                   MOVMU.L     R10,@-R15
    00000790 7FFC                   ADD         #-4,R15
    00000792 4511                   CMP/PZ      R5
               mnet.c        895    {
               mnet.c        896      unsigned long   setValue;
               mnet.c        897      UB  mod;
               mnet.c        898      ER  Result = E_SUCCESS;
               mnet.c        899      UH  dir = (pos >=0 ? CW : CCW);
    00000794 6B53                   MOV         R5,R11
    00000796 6D43                   MOV         R4,R13
    00000798 EE02                   MOV         #2,R14     ; H'00000002
    0000079A 8F01                   BF/S        L181
    0000079C 6C63                   MOV         R6,R12
    0000079E EE01                   MOV         #1,R14     ; H'00000001
    000007A0              L181:
               mnet.c        900    
               mnet.c        901      if (pm < DVMIN || DVMAX < pm)           return(( E_PAR_OUTRNG + PARAM1 ));
    000007A0 6ADC                   EXTU.B      R13,R10
    000007A2 E601                   MOV         #1,R6      ; H'00000001
    000007A4 3A63                   CMP/GE      R6,R10
    000007A6 8B76                   BF          L182
    000007A8 E207                   MOV         #7,R2      ; H'00000007
    000007AA 3A27                   CMP/GT      R2,R10
    000007AC 8973                   BT          L182
               mnet.c        902    
               mnet.c        903    // シュミレーションモード
               mnet.c        904    #if DEBUG_SIM_MODE != 0
               mnet.c        905      return (E_SUCCESS );
               mnet.c        906    #endif
               mnet.c        907      if (!IsExist( pm ))                     return(( E_CON_ERR + pm )); // デバイス接続確認
    000007AE B4DF                   BSR         _IsExist
    000007B0 64A3                   MOV         R10,R4
    000007B2 2008                   TST         R0,R0
    000007B4 896A                   BT          L186
               mnet.c        908      if (motor_IsBusy(pm))                   return(( E_BUSY + pm ));    // ビジー確認
    000007B6 B516                   BSR         _motor_IsBusy
    000007B8 64A3                   MOV         R10,R4
    000007BA 2008                   TST         R0,R0
    000007BC 8B61                   BF          L188
               mnet.c        909      if (motor_IsLimit(pm, dir))             return( E_SUCCESS );        // 現在リミットか確認
    000007BE 65ED                   EXTU.W      R14,R5
    000007C0 B552                   BSR         _motor_IsLimit
    000007C2 64A3                   MOV         R10,R4
    000007C4 2008                   TST         R0,R0
    000007C6 8B5A                   BF          L190
               mnet.c        910    
               mnet.c        911      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    000007C8 D610                   MOV.L       L620+6,R6  ; _MNET_DRV_TYPE
    000007CA 6DDC                   EXTU.B      R13,R13
    000007CC 60D3                   MOV         R13,R0
    000007CE 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    000007D0 880A                   CMP/EQ      #10,R0
    000007D2 8954                   BT          L190
               mnet.c        912      {
               mnet.c        913          return( E_SUCCESS );
               mnet.c        914      }
               mnet.c        915      
               mnet.c        916      // PCD4611通信接続時
               mnet.c        917      if( MNET_DRV_TYPE[pm] == PCD4611 )
    000007D4 8809                   CMP/EQ      #9,R0
    000007D6 8946                   BT          L193
               mnet.c        918      {
               mnet.c        919          WriteMemoryIntPCD4611( MOD41 );
               mnet.c        920          WriteMemoryPCD4611( WRG_RMD );
               mnet.c        921    
               mnet.c        922          WriteMemoryIntPCD4611( pos );
               mnet.c        923          WriteMemoryPCD4611( WRG_RMV );
               mnet.c        924          
               mnet.c        925          WriteMemoryPCD4611( CMD_STAUD );
               mnet.c        926      }
               mnet.c        927      // MNET_BCD4020FU(A)接続時
               mnet.c        928      else
               mnet.c        929      {
               mnet.c        930          motor_SetAllRegister(pm);                                           // Limit後だとLimit時の速さのままとなるため、ここで通常の設定速度に変更
    000007D8 B614                   BSR         __$motor_SetAllRegister
    000007DA 64A3                   MOV         R10,R4
               mnet.c        931          SetMotorCommand (pm, CMD_INTRS);                                    // 割込み出力リセット
    000007DC E508                   MOV         #8,R5      ; H'00000008
    000007DE B3C0                   BSR         __$SetMotorCommand
    000007E0 64A3                   MOV         R10,R4
               mnet.c        932          _pmInfo[pm].reg[R0]     = (INT)pos;
    000007E2 E064                   MOV         #100,R0    ; H'00000064
               mnet.c        933    
               mnet.c        934          _pmInfo[pm].startParam  = CMD_STAUD;                                // スタートコマンド動作指定
    000007E4 E253                   MOV         #83,R2     ; H'00000053
    000007E6 4D80                   MULR        R0,R13
    000007E8 D109                   MOV.L       L620+10,R1 ; __$_pmInfo
               mnet.c        935          if( status == REQ_STAFH )   _pmInfo[pm].startParam  = CMD_STAFH;
    000007EA 60CC                   EXTU.B      R12,R0
    000007EC 8801                   CMP/EQ      #1,R0
    000007EE 3D1C                   ADD         R1,R13
    000007F0 1DB9                   MOV.L       R11,@(36,R13); _pmInfo[].reg[]
    000007F2 3D211030               MOV.W       R2,@(96:12,R13); _pmInfo[].startParam
    000007F6 8915                   BT          L195
    000007F8 8802                   CMP/EQ      #2,R0
    000007FA 8B16                   BF          L196
               mnet.c        936          if( status == REQ_STAFL )   _pmInfo[pm].startParam  = CMD_STAFL;
    000007FC E650                   MOV         #80,R6     ; H'00000050
    000007FE 3D611030               MOV.W       R6,@(96:12,R13); _pmInfo[].startParam
    00000802 A012                   BRA         L196
    00000804 0009                   NOP
    00000806              L620:
    00000806 00000002               .RES.W      1
    00000808 <00000050>             .DATA.L     H'00000050+__$_pmInfo
    0000080C <00000000>             .DATA.L     _MNET_DRV_TYPE
    00000810 <00000000>             .DATA.L     __$_pmInfo
    00000814 <00000000>             .DATA.L     __$SetRenv1Fu
    00000818 <00000000>             .DATA.L     __$SetRmdFu
    0000081C <00000000>             .DATA.L     __$SetRmv
    00000820 <00000000>             .DATA.L     __$motor_RegistCommand
    00000824              L195:
    00000824 E651                   MOV         #81,R6     ; H'00000051
    00000826 3D611030               MOV.W       R6,@(96:12,R13); _pmInfo[].startParam
    0000082A              L196:
               mnet.c        937          
               mnet.c        938          _pmInfo[pm].paused      = FALSE;
    0000082A E600                   MOV         #0,R6      ; H'00000000
    0000082C 3D612016               MOV.L       R6,@(88:12,R13); _pmInfo[].paused
               mnet.c        939    
               mnet.c        940          Result = SetRenv1Fu( pm );          if( Result != E_SUCCESS )   return( Result );   // RENV1設定
    00000830 D386                   MOV.L       L621,R3    ; __$SetRenv1Fu
    00000832 430B                   JSR         @R3
    00000834 64A3                   MOV         R10,R4
    00000836 2008                   TST         R0,R0
    00000838 8F13                   BF/S        L199
    0000083A 6203                   MOV         R0,R2
               mnet.c        941          Result = SetRmdFu( pm, MOD41 );     if( Result != E_SUCCESS )   return( Result );   // RMD設定
    0000083C E541                   MOV         #65,R5     ; H'00000041
    0000083E D384                   MOV.L       L621+4,R3  ; __$SetRmdFu
    00000840 430B                   JSR         @R3
    00000842 64A3                   MOV         R10,R4
    00000844 2008                   TST         R0,R0
    00000846 8F0C                   BF/S        L199
    00000848 6203                   MOV         R0,R2
               mnet.c        942          Result = SetRmv( pm, pos );         if( Result != E_SUCCESS )   return( Result );   // RMV設定
    0000084A 65B3                   MOV         R11,R5
    0000084C D381                   MOV.L       L621+8,R3  ; __$SetRmv
    0000084E 430B                   JSR         @R3
    00000850 64A3                   MOV         R10,R4
    00000852 2008                   TST         R0,R0
    00000854 8F05                   BF/S        L199
    00000856 6203                   MOV         R0,R2
               mnet.c        943          
               mnet.c        944          motor_RegistCommand(pm, CMD_RELMV); 
    00000858 E509                   MOV         #9,R5      ; H'00000009
    0000085A B7EC                   BSR         __$motor_RegistCommand
    0000085C 64A3                   MOV         R10,R4
    0000085E A00E                   BRA         L190
    00000860 0009                   NOP
    00000862              L199:
    00000862 A01A                   BRA         L202
    00000864 6023                   MOV         R2,R0
    00000866              L193:
    00000866 B349                   BSR         __$WriteMemoryIntPCD4611
    00000868 E441                   MOV         #65,R4     ; H'00000041
    0000086A E497                   MOV         #-105,R4   ; H'FFFFFF97
    0000086C B333                   BSR         __$WriteMemoryPCD4611
    0000086E 2F40                   MOV.B       R4,@R15
    00000870 B344                   BSR         __$WriteMemoryIntPCD4611
    00000872 64B3                   MOV         R11,R4
    00000874 64F0                   MOV.B       @R15,R4
    00000876 B32E                   BSR         __$WriteMemoryPCD4611
    00000878 74F9                   ADD         #-7,R4
    0000087A B32C                   BSR         __$WriteMemoryPCD4611
    0000087C E453                   MOV         #83,R4     ; H'00000053
    0000087E              L190:
    0000087E A00C                   BRA         L202
    00000880 E000                   MOV         #0,R0      ; H'00000000
    00000882              L188:
    00000882 E601                   MOV         #1,R6      ; H'00000001
    00000884 60DC                   EXTU.B      R13,R0
    00000886 4618                   SHLL8       R6
    00000888 A007                   BRA         L202
    0000088A 306C                   ADD         R6,R0
    0000088C              L186:
    0000088C E604                   MOV         #4,R6      ; H'00000004
    0000088E 60DC                   EXTU.B      R13,R0
    00000890 4618                   SHLL8       R6
    00000892 A002                   BRA         L202
    00000894 306C                   ADD         R6,R0
    00000896              L182:
    00000896 00000801               MOVI20      #2049,R0   ; H'00000801
    0000089A              L202:
    0000089A 7F04                   ADD         #4,R15
    0000089C 4AF4                   MOVMU.L     @R15+,R10
               mnet.c        945      }
               mnet.c        946      return( E_SUCCESS );
               mnet.c        947    }
    0000089E 006B                   RTS/N
               mnet.c        948    
               mnet.c        949    /*-----------------------------------------------------------------------------
               mnet.c        950      機能：リミット位置移動
               mnet.c        951      機能：no      モータ番号
               mnet.c        952            dir     方向(MOTOR_CW/MOTOR_CCW)
               mnet.c        953            spd     速度(定速)
               mnet.c        954            st      リザーブ
               mnet.c        955      戻値：エラーコード
               mnet.c        956     ----------------------------------------------------------------------------*/
               mnet.c        957    ER motor_LIMIT(UB mm, UB dr, UB md, INT sp )
    000008A0              _motor_LIMIT:                    ; function: motor_LIMIT
                                                           ; frame size=28
    000008A0 4AF0                   MOVMU.L     R10,@-R15
    000008A2 7FFC                   ADD         #-4,R15
    000008A4 6A4C                   EXTU.B      R4,R10
    000008A6 E101                   MOV         #1,R1      ; H'00000001
    000008A8 3A13                   CMP/GE      R1,R10
               mnet.c        958    {
               mnet.c        959      ER  Result = E_SUCCESS;
               mnet.c        960      UB  mod;
               mnet.c        961      
               mnet.c        962      if (mm < DVMIN || DVMAX < mm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    000008AA 6B73                   MOV         R7,R11
    000008AC 6C53                   MOV         R5,R12
    000008AE 8F7B                   BF/S        L205
    000008B0 6D63                   MOV         R6,R13
    000008B2 E207                   MOV         #7,R2      ; H'00000007
    000008B4 3A27                   CMP/GT      R2,R10
    000008B6 8977                   BT          L205
               mnet.c        963    
               mnet.c        964    // シュミレーションモード
               mnet.c        965    #if DEBUG_SIM_MODE != 0
               mnet.c        966      return (E_SUCCESS );
               mnet.c        967    #endif
               mnet.c        968    
               mnet.c        969      if( MNET_DRV_TYPE[mm] == NCPRSUNIT )// 圧力ユニット
    000008B8 D667                   MOV.L       L621+12,R6 ; _MNET_DRV_TYPE
    000008BA 6E4C                   EXTU.B      R4,R14
    000008BC 36EC                   ADD         R14,R6
    000008BE 6060                   MOV.B       @R6,R0     ; MNET_DRV_TYPE[]
    000008C0 880A                   CMP/EQ      #10,R0
    000008C2 8D6F                   BT/S        L208
    000008C4 2F62                   MOV.L       R6,@R15
               mnet.c        970      {
               mnet.c        971          return( E_SUCCESS );
               mnet.c        972      }
               mnet.c        973      
               mnet.c        974      if (!IsExist( mm ))                                     return(( E_CON_ERR + mm )); // デバイス接続確認
    000008C6 B453                   BSR         _IsExist
    000008C8 64A3                   MOV         R10,R4
    000008CA 2008                   TST         R0,R0
    000008CC 8B04                   BF          L210
    000008CE E604                   MOV         #4,R6      ; H'00000004
    000008D0 4618                   SHLL8       R6
    000008D2 3E6C                   ADD         R6,R14
    000008D4 A06A                   BRA         L211
    000008D6 60E3                   MOV         R14,R0
    000008D8              L210:
               mnet.c        975      if (motor_IsBusy(mm))                                   return(( E_BUSY + mm ));    // ビジー確認
    000008D8 B485                   BSR         _motor_IsBusy
    000008DA 64A3                   MOV         R10,R4
    000008DC 2008                   TST         R0,R0
    000008DE 8904                   BT          L213
    000008E0 E601                   MOV         #1,R6      ; H'00000001
    000008E2 4618                   SHLL8       R6
    000008E4 3E6C                   ADD         R6,R14
    000008E6 A061                   BRA         L211
    000008E8 60E3                   MOV         R14,R0
    000008EA              L213:
               mnet.c        976    
               mnet.c        977      // PCD4611通信接続時
               mnet.c        978      if( MNET_DRV_TYPE[mm] == PCD4611 )
    000008EA 66F2                   MOV.L       @R15,R6
    000008EC 6060                   MOV.B       @R6,R0     ; MNET_DRV_TYPE[]
    000008EE 8809                   CMP/EQ      #9,R0
    000008F0 8914                   BT          L214
               mnet.c        979      {
               mnet.c        980    //        if( dr == CW )  mod = MOD00;
               mnet.c        981    //        else            mod = MOD08;
               mnet.c        982          if( dr == CW )  mod = MOD10;
               mnet.c        983          else            mod = MOD18;
               mnet.c        984    
               mnet.c        985          WriteMemoryIntPCD4611( mod );
               mnet.c        986          WriteMemoryPCD4611( WRG_RMD );
               mnet.c        987          
               mnet.c        988          WriteMemoryPCD4611( CMD_STAFL );
               mnet.c        989      }
               mnet.c        990      // MNET_BCD4020FU(A)接続時
               mnet.c        991      else
               mnet.c        992      {
               mnet.c        993          SetMotorCommand (mm, CMD_INTRS);            // 割込み出力リセット
    000008F2 E508                   MOV         #8,R5      ; H'00000008
    000008F4 B335                   BSR         __$SetMotorCommand
    000008F6 64A3                   MOV         R10,R4
               mnet.c        994    
               mnet.c        995          _pmInfo[mm].reg[R0]     = 0xFFFFFF;
    000008F8 E064                   MOV         #100,R0    ; H'00000064
    000008FA 04110000               MOVI20S     #16777216,R4; H'01000000
    000008FE 4E80                   MULR        R0,R14
    00000900 D256                   MOV.L       L621+16,R2 ; __$_pmInfo
    00000902 74FF                   ADD         #-1,R4
               mnet.c        996          _pmInfo[mm].startParam  = CMD_STAFL;
    00000904 E650                   MOV         #80,R6     ; H'00000050
               mnet.c        997          _pmInfo[mm].paused      = FALSE;
    00000906 E700                   MOV         #0,R7      ; H'00000000
    00000908 3E2C                   ADD         R2,R14
    0000090A 1E49                   MOV.L       R4,@(36,R14); _pmInfo[].reg[]
    0000090C 3E611030               MOV.W       R6,@(96:12,R14); _pmInfo[].startParam
    00000910 3E712016               MOV.L       R7,@(88:12,R14); _pmInfo[].paused
               mnet.c        998    
               mnet.c        999          if( MNET_DRV_TYPE[mm] == PCD4611 )          // PCD4611通信接続時
    00000914 6EF2                   MOV.L       @R15,R14
    00000916 60E0                   MOV.B       @R14,R0    ; MNET_DRV_TYPE[]
    00000918 8809                   CMP/EQ      #9,R0
    0000091A 8B0C                   BF          L216
    0000091C              L214:
               mnet.c       1000          {
               mnet.c       1001              if( dr == CW )  mod = MOD10;
    0000091C 60CC                   EXTU.B      R12,R0
    0000091E 8801                   CMP/EQ      #1,R0
    00000920 8F01                   BF/S        L218
    00000922 E218                   MOV         #24,R2     ; H'00000018
    00000924 E210                   MOV         #16,R2     ; H'00000010
    00000926              L218:
    00000926 B2E9                   BSR         __$WriteMemoryIntPCD4611
    00000928 6423                   MOV         R2,R4
    0000092A B2D4                   BSR         __$WriteMemoryPCD4611
    0000092C E497                   MOV         #-105,R4   ; H'FFFFFF97
    0000092E B2D2                   BSR         __$WriteMemoryPCD4611
    00000930 E450                   MOV         #80,R4     ; H'00000050
    00000932 A037                   BRA         L208
    00000934 0009                   NOP
    00000936              L216:
               mnet.c       1002              else            mod = MOD18;
               mnet.c       1003              
               mnet.c       1004              WriteMemoryIntPCD4611( mod );
               mnet.c       1005              WriteMemoryPCD4611( WRG_RMD );
               mnet.c       1006              WriteMemoryPCD4611( CMD_STAFL );
               mnet.c       1007          }
               mnet.c       1008          // MNET_BCD4020FU(A)接続時
               mnet.c       1009          else
               mnet.c       1010          {
               mnet.c       1011              Result = SetRenv1Fu( mm );                          if( Result != E_SUCCESS )   return( Result );   // RENV1設定
    00000936 B7EC                   BSR         __$SetRenv1Fu
    00000938 64A3                   MOV         R10,R4
    0000093A 2008                   TST         R0,R0
    0000093C 8F30                   BF/S        L220
    0000093E 6603                   MOV         R0,R6
    00000940 6DDC                   EXTU.B      R13,R13
    00000942 E003                   MOV         #3,R0      ; H'00000003
    00000944 4D80                   MULR        R0,R13
    00000946 60CC                   EXTU.B      R12,R0
               mnet.c       1012              Result = SetRmdFu( mm, LMMOD_TBL[md][dr] );         if( Result != E_SUCCESS )   return( Result );   // RMD設定
    00000948 D145                   MOV.L       L621+20,R1 ; __$LMMOD_TBL
    0000094A 64A3                   MOV         R10,R4
    0000094C 30DC                   ADD         R13,R0
    0000094E D340                   MOV.L       L621+4,R3  ; __$SetRmdFu
    00000950 430B                   JSR         @R3
    00000952 051C                   MOV.B       @(R0,R1),R5; LMMOD_TBL[]
    00000954 2008                   TST         R0,R0
    00000956 8F23                   BF/S        L220
    00000958 6603                   MOV         R0,R6
               mnet.c       1013    
               mnet.c       1014              if (!SetMotorRegisterInt(mm, WRG_RFL, sp))          return(( E_MNT_ACCESS + WRG_RFL ));
    0000095A E591                   MOV         #-111,R5   ; H'FFFFFF91
    0000095C 66B3                   MOV         R11,R6
    0000095E 655C                   EXTU.B      R5,R5
    00000960 B31D                   BSR         _SetMotorRegisterInt
    00000962 64A3                   MOV         R10,R4
    00000964 2008                   TST         R0,R0
    00000966 00000591               MOVI20      #1425,R0   ; H'00000591
    0000096A 891F                   BT          L211
               mnet.c       1015              if (!SetMotorRegisterInt(mm, WRG_RFH, sp))          return(( E_MNT_ACCESS + WRG_RFH ));
    0000096C E592                   MOV         #-110,R5   ; H'FFFFFF92
    0000096E 66B3                   MOV         R11,R6
    00000970 655C                   EXTU.B      R5,R5
    00000972 B314                   BSR         _SetMotorRegisterInt
    00000974 64A3                   MOV         R10,R4
    00000976 2008                   TST         R0,R0
    00000978 00000592               MOVI20      #1426,R0   ; H'00000592
    0000097C 8916                   BT          L211
               mnet.c       1016              if (!SetMotorRegisterInt(mm, WRG_RMG, 199))         return(( E_MNT_ACCESS + WRG_RMG ));
    0000097E E6C7                   MOV         #-57,R6    ; H'FFFFFFC7
    00000980 E595                   MOV         #-107,R5   ; H'FFFFFF95
    00000982 666C                   EXTU.B      R6,R6
    00000984 655C                   EXTU.B      R5,R5
    00000986 B30A                   BSR         _SetMotorRegisterInt
    00000988 64A3                   MOV         R10,R4
    0000098A 2008                   TST         R0,R0
    0000098C 8B03                   BF          L225
    0000098E 00000595               MOVI20      #1429,R0   ; H'00000595
    00000992 A00B                   BRA         L211
    00000994 0009                   NOP
    00000996              L225:
               mnet.c       1017              motor_RegistCommand(mm, CMD_LIMIT);
    00000996 E50C                   MOV         #12,R5     ; H'0000000C
    00000998 B74D                   BSR         __$motor_RegistCommand
    0000099A 64A3                   MOV         R10,R4
    0000099C A002                   BRA         L208
    0000099E 0009                   NOP
    000009A0              L220:
    000009A0 A004                   BRA         L211
    000009A2 6063                   MOV         R6,R0
    000009A4              L208:
    000009A4 A002                   BRA         L211
    000009A6 E000                   MOV         #0,R0      ; H'00000000
    000009A8              L205:
    000009A8 00000801               MOVI20      #2049,R0   ; H'00000801
    000009AC              L211:
    000009AC 7F04                   ADD         #4,R15
    000009AE 4AF4                   MOVMU.L     @R15+,R10
               mnet.c       1018          }
               mnet.c       1019      }
               mnet.c       1020      return( E_SUCCESS );
               mnet.c       1021    }
    000009B0 006B                   RTS/N
               mnet.c       1022    
               mnet.c       1023    
               mnet.c       1024    /*-----------------------------------------------------------------------------
               mnet.c       1025      機能：減速停止
               mnet.c       1026      機能：no      モータ番号
               mnet.c       1027      戻値：エラーコード
               mnet.c       1028     ----------------------------------------------------------------------------*/
               mnet.c       1029    ER motor_STOP(UB pm)
    000009B2              _motor_STOP:                     ; function: motor_STOP
                                                           ; frame size=12
    000009B2 4DF0                   MOVMU.L     R13,@-R15
               mnet.c       1030    {
               mnet.c       1031      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    000009B4 6D4C                   EXTU.B      R4,R13
    000009B6 E601                   MOV         #1,R6      ; H'00000001
    000009B8 3D63                   CMP/GE      R6,R13
    000009BA 8B20                   BF          L228
    000009BC E207                   MOV         #7,R2      ; H'00000007
    000009BE 3D27                   CMP/GT      R2,R13
    000009C0 891D                   BT          L228
               mnet.c       1032    
               mnet.c       1033    // シュミレーションモード
               mnet.c       1034    #if DEBUG_SIM_MODE != 0
               mnet.c       1035      return (E_SUCCESS );
               mnet.c       1036    #endif
               mnet.c       1037      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    000009C2 D625                   MOV.L       L621+12,R6 ; _MNET_DRV_TYPE
    000009C4 6E4C                   EXTU.B      R4,R14
    000009C6 60E3                   MOV         R14,R0
    000009C8 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    000009CA 880A                   CMP/EQ      #10,R0
    000009CC 8915                   BT          L231
               mnet.c       1038      {
               mnet.c       1039          return( E_SUCCESS );
               mnet.c       1040      }
               mnet.c       1041      
               mnet.c       1042    
               mnet.c       1043      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    000009CE B3CF                   BSR         _IsExist
    000009D0 64D3                   MOV         R13,R4
    000009D2 2008                   TST         R0,R0
    000009D4 8B04                   BF          L233
    000009D6 E604                   MOV         #4,R6      ; H'00000004
    000009D8 4618                   SHLL8       R6
    000009DA 3E6C                   ADD         R6,R14
    000009DC A011                   BRA         L234
    000009DE 60E3                   MOV         R14,R0
    000009E0              L233:
               mnet.c       1044      motor_RegistCommand(pm, CMD_STOP);
    000009E0 E549                   MOV         #73,R5     ; H'00000049
    000009E2 B728                   BSR         __$motor_RegistCommand
    000009E4 64D3                   MOV         R13,R4
               mnet.c       1045      if( !SetMotorCommand(pm, CMD_SDSTP) )                   return(( E_BUSY + pm ));
    000009E6 E54A                   MOV         #74,R5     ; H'0000004A
    000009E8 B2BB                   BSR         __$SetMotorCommand
    000009EA 64D3                   MOV         R13,R4
    000009EC 2008                   TST         R0,R0
    000009EE 8B04                   BF          L231
    000009F0 E601                   MOV         #1,R6      ; H'00000001
    000009F2 4618                   SHLL8       R6
    000009F4 3E6C                   ADD         R6,R14
    000009F6 A004                   BRA         L234
    000009F8 60E3                   MOV         R14,R0
    000009FA              L231:
    000009FA A002                   BRA         L234
    000009FC E000                   MOV         #0,R0      ; H'00000000
    000009FE              L228:
    000009FE 00000801               MOVI20      #2049,R0   ; H'00000801
    00000A02              L234:
    00000A02 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1046    
               mnet.c       1047      return( E_SUCCESS );
               mnet.c       1048    }
    00000A04 006B                   RTS/N
               mnet.c       1049    
               mnet.c       1050    /*-----------------------------------------------------------------------------
               mnet.c       1051      機能：即停止
               mnet.c       1052      機能：no      モータ番号
               mnet.c       1053      戻値：エラーコード
               mnet.c       1054     ----------------------------------------------------------------------------*/
               mnet.c       1055    ER motor_ABORT(UB pm)
    00000A06              _motor_ABORT:                    ; function: motor_ABORT
                                                           ; frame size=12
    00000A06 4DF0                   MOVMU.L     R13,@-R15
               mnet.c       1056    {
               mnet.c       1057      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000A08 6D4C                   EXTU.B      R4,R13
    00000A0A E601                   MOV         #1,R6      ; H'00000001
    00000A0C 3D63                   CMP/GE      R6,R13
    00000A0E 8B29                   BF          L238
    00000A10 E207                   MOV         #7,R2      ; H'00000007
    00000A12 3D27                   CMP/GT      R2,R13
    00000A14 8926                   BT          L238
               mnet.c       1058    
               mnet.c       1059    // シュミレーションモード
               mnet.c       1060    #if DEBUG_SIM_MODE != 0
               mnet.c       1061      return (E_SUCCESS );
               mnet.c       1062    #endif
               mnet.c       1063      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00000A16 D610                   MOV.L       L621+12,R6 ; _MNET_DRV_TYPE
    00000A18 6E4C                   EXTU.B      R4,R14
    00000A1A 60E3                   MOV         R14,R0
    00000A1C 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00000A1E 880A                   CMP/EQ      #10,R0
    00000A20 8912                   BT          L241
               mnet.c       1064      {
               mnet.c       1065          return( E_SUCCESS );
               mnet.c       1066      }
               mnet.c       1067      
               mnet.c       1068      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    00000A22 B3A5                   BSR         _IsExist
    00000A24 64D3                   MOV         R13,R4
    00000A26 2008                   TST         R0,R0
    00000A28 8B04                   BF          L243
    00000A2A E604                   MOV         #4,R6      ; H'00000004
    00000A2C 4618                   SHLL8       R6
    00000A2E 3E6C                   ADD         R6,R14
    00000A30 A01A                   BRA         L244
    00000A32 60E3                   MOV         R14,R0
    00000A34              L243:
               mnet.c       1069      if( !SetMotorCommand(pm, CMD_STOP))                     return(( E_BUSY + pm ));
    00000A34 E549                   MOV         #73,R5     ; H'00000049
    00000A36 B294                   BSR         __$SetMotorCommand
    00000A38 64D3                   MOV         R13,R4
    00000A3A 2008                   TST         R0,R0
    00000A3C 8B04                   BF          L241
    00000A3E E601                   MOV         #1,R6      ; H'00000001
    00000A40 4618                   SHLL8       R6
    00000A42 3E6C                   ADD         R6,R14
    00000A44 A010                   BRA         L244
    00000A46 60E3                   MOV         R14,R0
    00000A48              L241:
    00000A48 A00E                   BRA         L244
    00000A4A E000                   MOV         #0,R0      ; H'00000000
    00000A4C              L621:
    00000A4C <00000000>             .DATA.L     __$SetRenv1Fu
    00000A50 <00000000>             .DATA.L     __$SetRmdFu
    00000A54 <00000000>             .DATA.L     __$SetRmv
    00000A58 <00000000>             .DATA.L     _MNET_DRV_TYPE
    00000A5C <00000000>             .DATA.L     __$_pmInfo
    00000A60 <00000000>             .DATA.L     __$LMMOD_TBL
    00000A64              L238:
    00000A64 00000801               MOVI20      #2049,R0   ; H'00000801
    00000A68              L244:
    00000A68 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1070    
               mnet.c       1071      return( E_SUCCESS );
               mnet.c       1072    }
    00000A6A 006B                   RTS/N
               mnet.c       1073    
               mnet.c       1074    /*-----------------------------------------------------------------------------
               mnet.c       1075      機能：励磁のON/OFF設定
               mnet.c       1076      機能：no      モータ番号
               mnet.c       1077            sw      １：励磁ON、０：励磁OFF
               mnet.c       1078      戻値：エラーコード
               mnet.c       1079     ----------------------------------------------------------------------------*/
               mnet.c       1080    ER motor_POWER(UB pm, UB sw)
    00000A6C              _motor_POWER:                    ; function: motor_POWER
                                                           ; frame size=16
    00000A6C 4CF0                   MOVMU.L     R12,@-R15
    00000A6E 6D4C                   EXTU.B      R4,R13
    00000A70 E601                   MOV         #1,R6      ; H'00000001
    00000A72 3D63                   CMP/GE      R6,R13
               mnet.c       1081    {
               mnet.c       1082      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000A74 8F2D                   BF/S        L248
    00000A76 6C53                   MOV         R5,R12
    00000A78 E207                   MOV         #7,R2      ; H'00000007
    00000A7A 3D27                   CMP/GT      R2,R13
    00000A7C 8929                   BT          L248
               mnet.c       1083    
               mnet.c       1084    // シュミレーションモード
               mnet.c       1085    #if DEBUG_SIM_MODE != 0
               mnet.c       1086      return (E_SUCCESS );
               mnet.c       1087    #endif
               mnet.c       1088      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00000A7E D687                   MOV.L       L622,R6    ; _MNET_DRV_TYPE
    00000A80 6E4C                   EXTU.B      R4,R14
    00000A82 60E3                   MOV         R14,R0
    00000A84 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00000A86 880A                   CMP/EQ      #10,R0
    00000A88 8921                   BT          L251
               mnet.c       1089      {
               mnet.c       1090          return( E_SUCCESS );
               mnet.c       1091      }
               mnet.c       1092    
               mnet.c       1093      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));     // デバイス接続確認
    00000A8A B371                   BSR         _IsExist
    00000A8C 64D3                   MOV         R13,R4
    00000A8E 2008                   TST         R0,R0
    00000A90 8B04                   BF          L253
    00000A92 E604                   MOV         #4,R6      ; H'00000004
    00000A94 4618                   SHLL8       R6
    00000A96 3E6C                   ADD         R6,R14
    00000A98 A01D                   BRA         L254
    00000A9A 60E3                   MOV         R14,R0
    00000A9C              L253:
               mnet.c       1094      if (motor_IsBusy(pm))                                   return(( E_BUSY + pm ));        // ビジー確認
    00000A9C B3A3                   BSR         _motor_IsBusy
    00000A9E 64D3                   MOV         R13,R4
    00000AA0 2008                   TST         R0,R0
    00000AA2 8904                   BT          L256
    00000AA4 E601                   MOV         #1,R6      ; H'00000001
    00000AA6 4618                   SHLL8       R6
    00000AA8 3E6C                   ADD         R6,R14
    00000AAA A014                   BRA         L254
    00000AAC 60E3                   MOV         R14,R0
    00000AAE              L256:
               mnet.c       1095      if (!motor_PowerUp(pm, sw))                             return(( E_CUR_ERR + pm ));     // 励磁
    00000AAE 65CC                   EXTU.B      R12,R5
    00000AB0 B444                   BSR         _motor_PowerUp
    00000AB2 64D3                   MOV         R13,R4
    00000AB4 2008                   TST         R0,R0
    00000AB6 8B04                   BF          L258
    00000AB8 E602                   MOV         #2,R6      ; H'00000002
    00000ABA 4618                   SHLL8       R6
    00000ABC 3E6C                   ADD         R6,R14
    00000ABE A00A                   BRA         L254
    00000AC0 60E3                   MOV         R14,R0
    00000AC2              L258:
    00000AC2 E064                   MOV         #100,R0    ; H'00000064
    00000AC4 6CCC                   EXTU.B      R12,R12
    00000AC6 4E80                   MULR        R0,R14
               mnet.c       1096    
               mnet.c       1097      _pmInfo[pm].power = sw;
    00000AC8 D275                   MOV.L       L622+4,R2  ; H'00000054+__$_pmInfo
    00000ACA 60E3                   MOV         R14,R0
    00000ACC 02C5                   MOV.W       R12,@(R0,R2); _pmInfo[].power
    00000ACE              L251:
    00000ACE A002                   BRA         L254
    00000AD0 E000                   MOV         #0,R0      ; H'00000000
    00000AD2              L248:
    00000AD2 00000801               MOVI20      #2049,R0   ; H'00000801
    00000AD6              L254:
    00000AD6 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1098    
               mnet.c       1099      return ( E_SUCCESS );
               mnet.c       1100    }
    00000AD8 006B                   RTS/N
               mnet.c       1101    
               mnet.c       1102    /*-----------------------------------------------------------------------------
               mnet.c       1103      機能：モータ状態の読み出し
               mnet.c       1104      機能：no      モータ番号
               mnet.c       1105      戻値：エラーコード
               mnet.c       1106     ----------------------------------------------------------------------------*/
               mnet.c       1107    ER motor_STATUS(UB pm, ST_MOTOR_STATUS *status)
    00000ADA              _motor_STATUS:                   ; function: motor_STATUS
                                                           ; frame size=40
    00000ADA 4CF0                   MOVMU.L     R12,@-R15
    00000ADC 7FE8                   ADD         #-24,R15
               mnet.c       1108    {
               mnet.c       1109      INT pos  = 0;
               mnet.c       1110      INT enc  = 0;
               mnet.c       1111      INT dev  = 0;
               mnet.c       1112      INT rsts = 0;
               mnet.c       1113      INT rest = 0;
               mnet.c       1114      INT rcnt1= 0;
               mnet.c       1115      UB mnet_drv_typ;
               mnet.c       1116      MNETSubStatus substs;
               mnet.c       1117      
               mnet.c       1118      // モータ番号範囲外
               mnet.c       1119      if (pm < DVMIN || DVMAX < pm)                           return(( E_PAR_OUTRNG + PARAM1 ));
    00000ADE 6D4C                   EXTU.B      R4,R13
    00000AE0 E601                   MOV         #1,R6      ; H'00000001
    00000AE2 E200                   MOV         #0,R2      ; H'00000000
    00000AE4 3D63                   CMP/GE      R6,R13
    00000AE6 6C53                   MOV         R5,R12
    00000AE8 1F22                   MOV.L       R2,@(8,R15); pos
    00000AEA 6E43                   MOV         R4,R14
    00000AEC 1F23                   MOV.L       R2,@(12,R15); enc
    00000AEE 1F24                   MOV.L       R2,@(16,R15); dev
    00000AF0 1F21                   MOV.L       R2,@(4,R15); rsts
    00000AF2 8D02                   BT/S        L632
    00000AF4 2F22                   MOV.L       R2,@R15    ; rest
    00000AF6 A0AA                   BRA         L261
    00000AF8 0009                   NOP
    00000AFA              L632:
    00000AFA E207                   MOV         #7,R2      ; H'00000007
    00000AFC 3D27                   CMP/GT      R2,R13
    00000AFE 8B01                   BF          L633
    00000B00 A0A5                   BRA         L261
    00000B02 0009                   NOP
    00000B04              L633:
               mnet.c       1120    
               mnet.c       1121    // シュミレーションモード
               mnet.c       1122    #if DEBUG_SIM_MODE != 0
               mnet.c       1123      // ステータスセット
               mnet.c       1124      status->busy      = 0;
               mnet.c       1125      status->cw_limit  = 0;
               mnet.c       1126      status->ccw_limit = 0;
               mnet.c       1127      status->enc       = 0;
               mnet.c       1128      status->dev       = 0;
               mnet.c       1129      status->pos       = _pmInfo[pm].pos = (INT)pos;
               mnet.c       1130      return (E_SUCCESS );
               mnet.c       1131    #endif
               mnet.c       1132    
               mnet.c       1133      if (!IsExist( pm ))                                     return(( E_CON_ERR + pm ));             // デバイス接続異常
    00000B04 B334                   BSR         _IsExist
    00000B06 64D3                   MOV         R13,R4
    00000B08 2008                   TST         R0,R0
    00000B0A 8B04                   BF          L264
    00000B0C E604                   MOV         #4,R6      ; H'00000004
    00000B0E 60EC                   EXTU.B      R14,R0
    00000B10 4618                   SHLL8       R6
    00000B12 A09E                   BRA         L265
    00000B14 306C                   ADD         R6,R0
    00000B16              L264:
               mnet.c       1134    
               mnet.c       1135      mnet_drv_typ = MNET_DRV_TYPE[pm];                       // デバイス情報取得
    00000B16 D661                   MOV.L       L622,R6    ; _MNET_DRV_TYPE
    00000B18 6EEC                   EXTU.B      R14,R14
    00000B1A 60E3                   MOV         R14,R0
    00000B1C 026C                   MOV.B       @(R0,R6),R2; MNET_DRV_TYPE[]
    00000B1E 602C                   EXTU.B      R2,R0
               mnet.c       1136    
               mnet.c       1137      if( mnet_drv_typ == PCD4611 )                           // PCD4611通信接続時
    00000B20 8809                   CMP/EQ      #9,R0
    00000B22 8B28                   BF          L267
               mnet.c       1138      {
               mnet.c       1139          WriteMemoryPCD4611(RRG_REST);
    00000B24 B1D7                   BSR         __$WriteMemoryPCD4611
    00000B26 E4F2                   MOV         #-14,R4    ; H'FFFFFFF2
               mnet.c       1140          rest = ReadMemoryPCD4611();
    00000B28 B1FB                   BSR         __$ReadMemoryPCD4611
    00000B2A 0009                   NOP
               mnet.c       1141    
               mnet.c       1142          status->cw_limit  = (rest & 0x00000001) ? 1 : 0;
    00000B2C 8708                   BLD         #0,R0
    00000B2E 2F02                   MOV.L       R0,@R15    ; rest
    00000B30 0129                   MOVT        R1
               mnet.c       1143          status->ccw_limit = (rest & 0x00000002) ? 1 : 0;
    00000B32 84F3                   MOV.B       @(3,R15),R0; (part of)rest
    00000B34 1C14                   MOV.L       R1,@(16,R12); (status)->cw_limit
    00000B36 C802                   TST         #2,R0
    00000B38 0539                   MOVRT       R5
               mnet.c       1144          if((rest & 0x00000004))     return( E_CON_HEAD_Y0 );
    00000B3A 3F293003               BLD.B       #2,@(3,R15); (part of)rest
    00000B3E 8F04                   BF/S        L269
    00000B40 1C55                   MOV.L       R5,@(20,R12); (status)->ccw_limit
    00000B42 00000401               MOVI20      #1025,R0   ; H'00000401
    00000B46 A084                   BRA         L265
    00000B48 0009                   NOP
    00000B4A              L269:
               mnet.c       1145          
               mnet.c       1146    //        WriteMemoryPCD4611(RRG_RSTS);
               mnet.c       1147    //        pcd_rsts = ReadMemoryPCD4611();
               mnet.c       1148          
               mnet.c       1149          WriteMemoryPCD4611(RRG_RCUN1);
    00000B4A B1C4                   BSR         __$WriteMemoryPCD4611
    00000B4C E4E3                   MOV         #-29,R4    ; H'FFFFFFE3
               mnet.c       1150          rcnt1 = ReadMemoryPCD4611();
    00000B4E B1E8                   BSR         __$ReadMemoryPCD4611
    00000B50 0009                   NOP
    00000B52 1F05                   MOV.L       R0,@(20,R15)
               mnet.c       1151          
               mnet.c       1152          // ステータスセット
               mnet.c       1153          status->busy      = motor_IsBusy(pm);
    00000B54 B347                   BSR         _motor_IsBusy
    00000B56 64D3                   MOV         R13,R4
    00000B58 1C03                   MOV.L       R0,@(12,R12); (status)->busy
               mnet.c       1154          status->cw_limit  = motor_IsLimit(pm , CW );
    00000B5A E501                   MOV         #1,R5      ; H'00000001
    00000B5C B384                   BSR         _motor_IsLimit
    00000B5E 64D3                   MOV         R13,R4
    00000B60 1C04                   MOV.L       R0,@(16,R12); (status)->cw_limit
               mnet.c       1155          status->ccw_limit = motor_IsLimit(pm , CCW);
    00000B62 E502                   MOV         #2,R5      ; H'00000002
    00000B64 B380                   BSR         _motor_IsLimit
    00000B66 64D3                   MOV         R13,R4
               mnet.c       1156          status->enc       = 0;
               mnet.c       1157          status->dev       = 0;
               mnet.c       1158          status->pos       = rcnt1;
    00000B68 56F5                   MOV.L       @(20,R15),R6
    00000B6A E200                   MOV         #0,R2      ; H'00000000
    00000B6C 1C05                   MOV.L       R0,@(20,R12); (status)->ccw_limit
    00000B6E 1C21                   MOV.L       R2,@(4,R12); (status)->enc
    00000B70 1C22                   MOV.L       R2,@(8,R12); (status)->dev
    00000B72 A05E                   BRA         L270
    00000B74 2C62                   MOV.L       R6,@R12    ; (status)->pos
    00000B76              L267:
               mnet.c       1159      }
               mnet.c       1160      else
               mnet.c       1161      {
               mnet.c       1162    #ifdef DEBUG_INFO
               mnet.c       1163          DebugMnetInfo( pm );
    00000B76 B7C5                   BSR         __$DebugMnetInfo
    00000B78 64D3                   MOV         R13,R4
    00000B7A E5F2                   MOV         #-14,R5    ; H'FFFFFFF2
               mnet.c       1164    #endif
               mnet.c       1165    
               mnet.c       1166          // エラー割込要因取得
               mnet.c       1167          if (!GetMotorRegister(pm, RRG_REST, &rest))             return(( E_MNT_ACCESS + RRG_REST ));    // レジスタアクセス異常
    00000B7C 66F3                   MOV         R15,R6
    00000B7E 655C                   EXTU.B      R5,R5
    00000B80 B252                   BSR         _GetMotorRegister
    00000B82 64D3                   MOV         R13,R4
    00000B84 2008                   TST         R0,R0
    00000B86 000005F2               MOVI20      #1522,R0   ; H'000005F2
    00000B8A 8962                   BT          L265
    00000B8C E5F1                   MOV         #-15,R5    ; H'FFFFFFF1
               mnet.c       1168    
               mnet.c       1169          if (!GetMotorRegister(pm, RRG_RSTS, &rsts)) // 状態取得
    00000B8E 66F3                   MOV         R15,R6
    00000B90 7604                   ADD         #4,R6
    00000B92 655C                   EXTU.B      R5,R5
    00000B94 B248                   BSR         _GetMotorRegister
    00000B96 64D3                   MOV         R13,R4
    00000B98 2008                   TST         R0,R0
    00000B9A 000005F1               MOVI20      #1521,R0   ; H'000005F1
    00000B9E 8958                   BT          L265
    00000BA0 E5E3                   MOV         #-29,R5    ; H'FFFFFFE3
               mnet.c       1170          {
               mnet.c       1171              return(( E_MNT_ACCESS + RRG_RSTS ));    // レジスタアクセス異常
               mnet.c       1172          }
               mnet.c       1173          
               mnet.c       1174          if (!GetMotorRegister(pm, RRG_RCUN1, &pos)) // 移動量取得
    00000BA2 66F3                   MOV         R15,R6
    00000BA4 7608                   ADD         #8,R6
    00000BA6 655C                   EXTU.B      R5,R5
    00000BA8 B23E                   BSR         _GetMotorRegister
    00000BAA 64D3                   MOV         R13,R4
    00000BAC 2008                   TST         R0,R0
    00000BAE 000005E3               MOVI20      #1507,R0   ; H'000005E3
    00000BB2 894E                   BT          L265
               mnet.c       1175          {
               mnet.c       1176              return(( E_MNT_ACCESS + RRG_RCUN1 ));   // レジスタアクセス異常
               mnet.c       1177          }
               mnet.c       1178          
               mnet.c       1179          if( IsEncoderExist(pm) == TRUE )            // エンンコーダ付き
    00000BB4 B3A6                   BSR         _IsEncoderExist
    00000BB6 64D3                   MOV         R13,R4
    00000BB8 8801                   CMP/EQ      #1,R0
    00000BBA 8B18                   BF          L275
    00000BBC E5E4                   MOV         #-28,R5    ; H'FFFFFFE4
               mnet.c       1180          {
               mnet.c       1181              // エンコーダ値取得
               mnet.c       1182              if (!GetMotorRegister(pm, RRG_RCUN2, &enc))         return(( E_MNT_ACCESS + RRG_RCUN2 ));   // レジスタアクセス異常
    00000BBE 66F3                   MOV         R15,R6
    00000BC0 760C                   ADD         #12,R6
    00000BC2 655C                   EXTU.B      R5,R5
    00000BC4 B230                   BSR         _GetMotorRegister
    00000BC6 64D3                   MOV         R13,R4
    00000BC8 2008                   TST         R0,R0
    00000BCA 000005E4               MOVI20      #1508,R0   ; H'000005E4
    00000BCE 8940                   BT          L265
    00000BD0 E5E5                   MOV         #-27,R5    ; H'FFFFFFE5
               mnet.c       1183    
               mnet.c       1184              // 偏差値取得
               mnet.c       1185              if (!GetMotorRegister(pm, RRG_RCUN3, &dev))         return(( E_MNT_ACCESS + RRG_RCUN3 ));   // レジスタアクセス異常
    00000BD2 66F3                   MOV         R15,R6
    00000BD4 7610                   ADD         #16,R6
    00000BD6 655C                   EXTU.B      R5,R5
    00000BD8 B226                   BSR         _GetMotorRegister
    00000BDA 64D3                   MOV         R13,R4
    00000BDC 2008                   TST         R0,R0
    00000BDE 8B03                   BF          L278
    00000BE0 000005E5               MOVI20      #1509,R0   ; H'000005E5
    00000BE4 A035                   BRA         L265
    00000BE6 0009                   NOP
    00000BE8              L278:
               mnet.c       1186    
               mnet.c       1187              // 脱調検知
               mnet.c       1188              if(( rest & 0x00000004))                            return(( E_DTY_ERR | pm ));             // REST bit2(ESC3)
    00000BE8 3F293003               BLD.B       #2,@(3,R15); (part of)rest
    00000BEC 892A                   BT          L279
    00000BEE              L275:
               mnet.c       1189    
               mnet.c       1190              // 脱調検知
               mnet.c       1191              if(( rsts & 0xf0000000) == 0)       // 固定値０エリアに書き込まれている場合は、FIFOの読込が出来なかったと判断し監視しない
               mnet.c       1192              {
               mnet.c       1193                  if( (rsts & 0x00400000) )                           
               mnet.c       1194                  {
               mnet.c       1195    //                return(( E_DTY_ERR | pm ));             // RSTS bit22(SCP3)
               mnet.c       1196                  }
               mnet.c       1197              }
               mnet.c       1198          }
               mnet.c       1199    
               mnet.c       1200          // 通信エラー
               mnet.c       1201          if( (rest & 0x00000400) )                               return(( E_CON_ERR | pm ));             // REST bit10(ESNT)
    00000BEE E604                   MOV         #4,R6      ; H'00000004
    00000BF0 62F2                   MOV.L       @R15,R2    ; rest
    00000BF2 4618                   SHLL8       R6
    00000BF4 2268                   TST         R6,R2
    00000BF6 8902                   BT          L281
    00000BF8 2D6B                   OR          R6,R13
    00000BFA A02A                   BRA         L265
    00000BFC 60D3                   MOV         R13,R0
    00000BFE              L281:
               mnet.c       1202    
               mnet.c       1203          // 脱調検知(オーバーライド失敗のため脱調と判断)
               mnet.c       1204          if( (rest & 0x00001000) )                               return(( E_DTY_ERR | pm ));             // REST bit12(ESOR)
    00000BFE E610                   MOV         #16,R6     ; H'00000010
    00000C00 4618                   SHLL8       R6
    00000C02 2268                   TST         R6,R2
    00000C04 8B1E                   BF          L279
               mnet.c       1205    
               mnet.c       1206          // ステータスセット
               mnet.c       1207          status->busy      = motor_IsBusy(pm);
    00000C06 B2EE                   BSR         _motor_IsBusy
    00000C08 64D3                   MOV         R13,R4
    00000C0A 1C03                   MOV.L       R0,@(12,R12); (status)->busy
               mnet.c       1208          status->cw_limit  = (rsts & 0x00000040) ? 1 : 0;
    00000C0C 84F7                   MOV.B       @(7,R15),R0; (part of)rsts
    00000C0E C840                   TST         #64,R0
    00000C10 0639                   MOVRT       R6
               mnet.c       1209          status->ccw_limit = (rsts & 0x00000080) ? 1 : 0;
    00000C12 C880                   TST         #128,R0
    00000C14 1C64                   MOV.L       R6,@(16,R12); (status)->cw_limit
    00000C16 0739                   MOVRT       R7
    00000C18 1C75                   MOV.L       R7,@(20,R12); (status)->ccw_limit
    00000C1A E064                   MOV         #100,R0    ; H'00000064
    00000C1C 64E3                   MOV         R14,R4
               mnet.c       1210          status->enc       = enc;
    00000C1E 5DF3                   MOV.L       @(12,R15),R13; enc
    00000C20 4480                   MULR        R0,R4
    00000C22 1CD1                   MOV.L       R13,@(4,R12); (status)->enc
               mnet.c       1211          status->dev       = dev;
               mnet.c       1212          status->pos       = _pmInfo[pm].pos = (INT)pos;
    00000C24 D21F                   MOV.L       L622+8,R2  ; H'00000050+__$_pmInfo
    00000C26 51F4                   MOV.L       @(16,R15),R1; dev
    00000C28 6043                   MOV         R4,R0
    00000C2A 1C12                   MOV.L       R1,@(8,R12); (status)->dev
    00000C2C 55F2                   MOV.L       @(8,R15),R5; pos
    00000C2E 0256                   MOV.L       R5,@(R0,R2); _pmInfo[].pos
    00000C30 2C52                   MOV.L       R5,@R12    ; (status)->pos
    00000C32              L270:
               mnet.c       1213          
               mnet.c       1214      }
               mnet.c       1215    
               mnet.c       1216      if( status->busy == TRUE )                                  return(( E_BUSY + pm ));                // デバイスビジー
    00000C32 50C3                   MOV.L       @(12,R12),R0; (status)->busy
    00000C34 8801                   CMP/EQ      #1,R0
    00000C36 8F0C                   BF/S        L265
    00000C38 E000                   MOV         #0,R0      ; H'00000000
    00000C3A E601                   MOV         #1,R6      ; H'00000001
    00000C3C 4618                   SHLL8       R6
    00000C3E 3E6C                   ADD         R6,R14
    00000C40 A007                   BRA         L265
    00000C42 60E3                   MOV         R14,R0
    00000C44              L279:
    00000C44 E203                   MOV         #3,R2      ; H'00000003
    00000C46 4218                   SHLL8       R2
    00000C48 2D2B                   OR          R2,R13
    00000C4A A002                   BRA         L265
    00000C4C 60D3                   MOV         R13,R0
    00000C4E              L261:
    00000C4E 00000801               MOVI20      #2049,R0   ; H'00000801
    00000C52              L265:
    00000C52 7F18                   ADD         #24,R15
    00000C54 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1217    
               mnet.c       1218      return ( E_SUCCESS );
               mnet.c       1219    }
    00000C56 006B                   RTS/N
               mnet.c       1220    /******************************************************************************
               mnet.c       1221    * 
               mnet.c       1222    * [概要]  エンコーダ設定
               mnet.c       1223    * [引数]  mm:モータ番号、ec:逓倍設定値、dtyp:未使用、dv:未使用、so:脱腸検出ﾊﾟﾙｽ
               mnet.c       1224    * [戻値]  エラーコード
               mnet.c       1225    * 
               mnet.c       1226    ******************************************************************************/
               mnet.c       1227    ER motor_ENCODER(UB mm, UB ec, UB dtyp, UB dv, INT so)
    00000C58              _motor_ENCODER:                  ; function: motor_ENCODER
                                                           ; frame size=36
    00000C58 4CF0                   MOVMU.L     R12,@-R15
    00000C5A 7FEC                   ADD         #-20,R15
               mnet.c       1228    {
               mnet.c       1229      RENV2       renv2;
               mnet.c       1230      RENV4       renv4;
               mnet.c       1231      RENV2PCD    renv2pcd;
               mnet.c       1232      INT         pos = 0;
               mnet.c       1233      UB          mnet_drv_typ;
               mnet.c       1234    
               mnet.c       1235      // モータ番号範囲外
               mnet.c       1236      if (mm < DVMIN || DVMAX < mm)                                   return(( E_PAR_OUTRNG + PARAM1 ));
    00000C5C 6C4C                   EXTU.B      R4,R12
    00000C5E E601                   MOV         #1,R6      ; H'00000001
    00000C60 E200                   MOV         #0,R2      ; H'00000000
    00000C62 3C63                   CMP/GE      R6,R12
    00000C64 6E53                   MOV         R5,R14
    00000C66 8D02                   BT/S        L634
    00000C68 1F22                   MOV.L       R2,@(8,R15); pos
    00000C6A A09D                   BRA         L291
    00000C6C 0009                   NOP
    00000C6E              L634:
    00000C6E E207                   MOV         #7,R2      ; H'00000007
    00000C70 3C27                   CMP/GT      R2,R12
    00000C72 8B01                   BF          L635
    00000C74 A098                   BRA         L291
    00000C76 0009                   NOP
    00000C78              L635:
               mnet.c       1237    
               mnet.c       1238    // シュミレーションモード
               mnet.c       1239    #if DEBUG_SIM_MODE != 0
               mnet.c       1240      return (E_SUCCESS );
               mnet.c       1241    #endif
               mnet.c       1242    
               mnet.c       1243      if( MNET_DRV_TYPE[mm] == NCPRSUNIT )// 圧力ユニット
    00000C78 D608                   MOV.L       L622,R6    ; _MNET_DRV_TYPE
    00000C7A 6D4C                   EXTU.B      R4,R13
    00000C7C 36DC                   ADD         R13,R6
    00000C7E 6060                   MOV.B       @R6,R0     ; MNET_DRV_TYPE[]
    00000C80 880A                   CMP/EQ      #10,R0
    00000C82 8F02                   BF/S        L636
    00000C84 1F63                   MOV.L       R6,@(12,R15)
    00000C86 A08D                   BRA         L294
    00000C88 0009                   NOP
    00000C8A              L636:
               mnet.c       1244      {
               mnet.c       1245          return( E_SUCCESS );
               mnet.c       1246      }
               mnet.c       1247      
               mnet.c       1248      if (!IsExist( mm ))                                             return(( E_CON_ERR + mm ));
    00000C8A B271                   BSR         _IsExist
    00000C8C 64C3                   MOV         R12,R4
    00000C8E 2008                   TST         R0,R0
    00000C90 8B0A                   BF          L296
    00000C92 E604                   MOV         #4,R6      ; H'00000004
    00000C94 4618                   SHLL8       R6
    00000C96 3D6C                   ADD         R6,R13
    00000C98 A088                   BRA         L297
    00000C9A 60D3                   MOV         R13,R0
    00000C9C              L622:
    00000C9C <00000000>             .DATA.L     _MNET_DRV_TYPE
    00000CA0 <00000054>             .DATA.L     H'00000054+__$_pmInfo
    00000CA4 <00000050>             .DATA.L     H'00000050+__$_pmInfo
    00000CA8              L296:
               mnet.c       1249      if (motor_IsBusy(mm))                                           return(( E_BUSY + mm ));
    00000CA8 B29D                   BSR         _motor_IsBusy
    00000CAA 64C3                   MOV         R12,R4
    00000CAC 2008                   TST         R0,R0
    00000CAE 8B74                   BF          L299
               mnet.c       1250    
               mnet.c       1251      mnet_drv_typ = MNET_DRV_TYPE[mm];   // デバイス情報取得
    00000CB0 56F3                   MOV.L       @(12,R15),R6
    00000CB2 30618000               MOVU.B      @(0,R6),R0 ; MNET_DRV_TYPE[]
               mnet.c       1252    
               mnet.c       1253      if(
    00000CB6 8801                   CMP/EQ      #1,R0
    00000CB8 8901                   BT          L301
    00000CBA 2008                   TST         R0,R0
    00000CBC 8B72                   BF          L294
    00000CBE              L301:
    00000CBE E5DD                   MOV         #-35,R5    ; H'FFFFFFDD
               mnet.c       1254          ( mnet_drv_typ == BCD4020FUA )||
               mnet.c       1255          ( mnet_drv_typ == BCD4020FU )
               mnet.c       1256      )
               mnet.c       1257      {
               mnet.c       1258          if (!GetMotorRegister(mm, RRG_RENV2, &renv2.UNID.data))     return(( E_MNT_ACCESS + RRG_RENV2 ));// RENV2読込
    00000CC0 66F3                   MOV         R15,R6
    00000CC2 655C                   EXTU.B      R5,R5
    00000CC4 B1B0                   BSR         _GetMotorRegister
    00000CC6 64C3                   MOV         R12,R4
    00000CC8 2008                   TST         R0,R0
    00000CCA 000005DD               MOVI20      #1501,R0   ; H'000005DD
    00000CCE 896D                   BT          L297
    00000CD0 E5DF                   MOV         #-33,R5    ; H'FFFFFFDF
               mnet.c       1259          if (!GetMotorRegister(mm, RRG_RENV4, &renv4.UNID.data))     return(( E_MNT_ACCESS + RRG_RENV4 ));// RENV4読込
    00000CD2 66F3                   MOV         R15,R6
    00000CD4 7604                   ADD         #4,R6
    00000CD6 655C                   EXTU.B      R5,R5
    00000CD8 B1A6                   BSR         _GetMotorRegister
    00000CDA 64C3                   MOV         R12,R4
    00000CDC 2008                   TST         R0,R0
    00000CDE 000005DF               MOVI20      #1503,R0   ; H'000005DF
    00000CE2 8963                   BT          L297
               mnet.c       1260          
               mnet.c       1261          // Encoder 逓倍設定
               mnet.c       1262          switch( ec )
    00000CE4 60EC                   EXTU.B      R14,R0
    00000CE6 8802                   CMP/EQ      #2,R0
    00000CE8 8F06                   BF/S        L304
    00000CEA 1F04                   MOV.L       R0,@(16,R15)
               mnet.c       1263          {
               mnet.c       1264              case EC_1:// １逓倍
               mnet.c       1265              default:
               mnet.c       1266                  renv2.UNID.BIT.EIM1 = 0;
               mnet.c       1267                  renv2.UNID.BIT.EIM0 = 0;
               mnet.c       1268                  break;
               mnet.c       1269              case EC_2:// ２逓倍
               mnet.c       1270                  renv2.UNID.BIT.EIM1 = 0;
    00000CEC 3F290002               BCLR.B      #2,@(2,R15); (part of)renv2
               mnet.c       1271                  renv2.UNID.BIT.EIM0 = 1;
    00000CF0 3F191002               BSET.B      #1,@(2,R15); (part of)renv2
    00000CF4 A005                   BRA         L306
    00000CF6 0009                   NOP
    00000CF8              L304:
    00000CF8 8803                   CMP/EQ      #3,R0
    00000CFA 3F292002               BST.B       #2,@(2,R15); (part of)renv2
    00000CFE 3F190002               BCLR.B      #1,@(2,R15); (part of)renv2
    00000D02              L306:
               mnet.c       1272                  break;
               mnet.c       1273              case EC_3:// ４逓倍
               mnet.c       1274                  renv2.UNID.BIT.EIM1 = 1;
               mnet.c       1275                  renv2.UNID.BIT.EIM0 = 0;
               mnet.c       1276                  break;
               mnet.c       1277          }
               mnet.c       1278          if (!SetMotorRegisterInt(mm, WRG_RENV2, renv2.UNID.data))   return(( E_MNT_ACCESS + WRG_RENV2 ));
    00000D02 66F2                   MOV.L       @R15,R6    ; renv2.UNID.data
    00000D04 E59D                   MOV         #-99,R5    ; H'FFFFFF9D
    00000D06 655C                   EXTU.B      R5,R5
    00000D08 B149                   BSR         _SetMotorRegisterInt
    00000D0A 64C3                   MOV         R12,R4
    00000D0C 2008                   TST         R0,R0
    00000D0E 0000059D               MOVI20      #1437,R0   ; H'0000059D
    00000D12 894B                   BT          L297
    00000D14 E5E3                   MOV         #-29,R5    ; H'FFFFFFE3
               mnet.c       1279    
               mnet.c       1280          // 脱腸検出設定
               mnet.c       1281          if (!GetMotorRegister(mm, RRG_RCUN1, &pos))                 return(( E_MNT_ACCESS + RRG_RCUN1 ));       // カウンタ合わせ
    00000D16 66F3                   MOV         R15,R6
    00000D18 7608                   ADD         #8,R6
    00000D1A 655C                   EXTU.B      R5,R5
    00000D1C B184                   BSR         _GetMotorRegister
    00000D1E 64C3                   MOV         R12,R4
    00000D20 2008                   TST         R0,R0
    00000D22 000005E3               MOVI20      #1507,R0   ; H'000005E3
    00000D26 8941                   BT          L297
               mnet.c       1282          if (!SetMotorRegisterInt(mm, WRG_RCUN2, pos))               return(( E_MNT_ACCESS + WRG_RCUN2 ));
    00000D28 E5A4                   MOV         #-92,R5    ; H'FFFFFFA4
    00000D2A 56F2                   MOV.L       @(8,R15),R6; pos
    00000D2C 655C                   EXTU.B      R5,R5
    00000D2E B136                   BSR         _SetMotorRegisterInt
    00000D30 64C3                   MOV         R12,R4
    00000D32 2008                   TST         R0,R0
    00000D34 000005A4               MOVI20      #1444,R0   ; H'000005A4
    00000D38 8938                   BT          L297
               mnet.c       1283          if( !SetMotorCommand(mm, CMD_CUN3R) )                       return(( E_BUSY + mm ));                    // COUNTER3リセット
    00000D3A E522                   MOV         #34,R5     ; H'00000022
    00000D3C B111                   BSR         __$SetMotorCommand
    00000D3E 64C3                   MOV         R12,R4
    00000D40 2008                   TST         R0,R0
    00000D42 892A                   BT          L299
               mnet.c       1284          if (!SetMotorRegisterInt(mm, WRG_RCMP3, so))                return(( E_MNT_ACCESS + WRG_RCMP3 ));       // RCMP3データ
    00000D44 56F9                   MOV.L       @(36,R15),R6
    00000D46 E5A9                   MOV         #-87,R5    ; H'FFFFFFA9
    00000D48 655C                   EXTU.B      R5,R5
    00000D4A B128                   BSR         _SetMotorRegisterInt
    00000D4C 64C3                   MOV         R12,R4
    00000D4E 6203                   MOV         R0,R2
    00000D50 2228                   TST         R2,R2
    00000D52 8B03                   BF          L312
    00000D54 000005A9               MOVI20      #1449,R0   ; H'000005A9
    00000D58 A028                   BRA         L297
    00000D5A 0009                   NOP
    00000D5C              L312:
               mnet.c       1285          if(( so )&&(ec != EC_N))    // 脱調パルス有かつエンコーダ無効以外
    00000D5C 56F9                   MOV.L       @(36,R15),R6
    00000D5E 2668                   TST         R6,R6
    00000D60 890C                   BT          L314
    00000D62 51F4                   MOV.L       @(16,R15),R1
    00000D64 2118                   TST         R1,R1
    00000D66 8909                   BT          L314
               mnet.c       1286          {
               mnet.c       1287              // 脱腸検出ﾊﾟﾙｽ≠0の場合、RCMP3 ＜ 比較カウンタで条件成立
               mnet.c       1288              renv4.UNID.BIT.C3S0 = 1;
    00000D68 3F291005               BSET.B      #2,@(5,R15); (part of)renv4
               mnet.c       1289              renv4.UNID.BIT.C3S1 = 0;
    00000D6C 3F390005               BCLR.B      #3,@(5,R15); (part of)renv4
               mnet.c       1290              renv4.UNID.BIT.C3S2 = 1;
    00000D70 3F491005               BSET.B      #4,@(5,R15); (part of)renv4
               mnet.c       1291              renv4.UNID.BIT.C3S3 = 0;
    00000D74 3F590005               BCLR.B      #5,@(5,R15); (part of)renv4
    00000D78 A004                   BRA         L316
    00000D7A 0009                   NOP
    00000D7C              L314:
               mnet.c       1292          }
               mnet.c       1293          else
               mnet.c       1294          {
               mnet.c       1295              // 脱腸検出ﾊﾟﾙｽ＝0の場合、常に比較条件不成立にしておく
               mnet.c       1296              renv4.UNID.BIT.C3S0 = 0;
    00000D7C 84F5                   MOV.B       @(5,R15),R0; (part of)renv4
    00000D7E E6C3                   MOV         #-61,R6    ; H'FFFFFFC3
    00000D80 2069                   AND         R6,R0
    00000D82 80F5                   MOV.B       R0,@(5,R15); (part of)renv4
    00000D84              L316:
               mnet.c       1297              renv4.UNID.BIT.C3S1 = 0;
               mnet.c       1298              renv4.UNID.BIT.C3S2 = 0;
               mnet.c       1299              renv4.UNID.BIT.C3S3 = 0;
               mnet.c       1300          }
               mnet.c       1301          if (!SetMotorRegisterInt(mm,WRG_RENV4,renv4.UNID.data))     return(( E_MNT_ACCESS + WRG_RENV4 ));       // 設定
    00000D84 56F1                   MOV.L       @(4,R15),R6; renv4.UNID.data
    00000D86 E59F                   MOV         #-97,R5    ; H'FFFFFF9F
    00000D88 655C                   EXTU.B      R5,R5
    00000D8A B108                   BSR         _SetMotorRegisterInt
    00000D8C 64C3                   MOV         R12,R4
    00000D8E 2008                   TST         R0,R0
    00000D90 8B08                   BF          L294
    00000D92 0000059F               MOVI20      #1439,R0   ; H'0000059F
    00000D96 A009                   BRA         L297
    00000D98 0009                   NOP
    00000D9A              L299:
    00000D9A E601                   MOV         #1,R6      ; H'00000001
    00000D9C 4618                   SHLL8       R6
    00000D9E 3D6C                   ADD         R6,R13
    00000DA0 A004                   BRA         L297
    00000DA2 60D3                   MOV         R13,R0
    00000DA4              L294:
    00000DA4 A002                   BRA         L297
    00000DA6 E000                   MOV         #0,R0      ; H'00000000
    00000DA8              L291:
    00000DA8 00000801               MOVI20      #2049,R0   ; H'00000801
    00000DAC              L297:
    00000DAC 7F14                   ADD         #20,R15
    00000DAE 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1302      }
               mnet.c       1303      // PCD4611通信接続時
               mnet.c       1304      else if( MNET_DRV_TYPE[mm] == PCD4611 )
               mnet.c       1305      {
               mnet.c       1306          // 本案件は、エンコードないため処理不要
               mnet.c       1307      }
               mnet.c       1308    
               mnet.c       1309      return( E_SUCCESS );
               mnet.c       1310    }
    00000DB0 006B                   RTS/N
               mnet.c       1311    
               mnet.c       1312    
               mnet.c       1313    
               mnet.c       1314    /******************************************************************************
               mnet.c       1315    * 
               mnet.c       1316    * [概要]  モータ速度倍率取得
               mnet.c       1317    * [引数]  速度番号
               mnet.c       1318    * [戻値]  倍率値
               mnet.c       1319    * 
               mnet.c       1320    ******************************************************************************/
               mnet.c       1321    INT GetFactor( UB factor )
    00000DB2              _GetFactor:                      ; function: GetFactor
                                                           ; frame size=0
               mnet.c       1322    {
               mnet.c       1323      INT Result = 0;
               mnet.c       1324    
               mnet.c       1325      if( ( factor >= 0)&&( factor <= 10 ))
    00000DB2 624C                   EXTU.B      R4,R2
    00000DB4 E10A                   MOV         #10,R1     ; H'0000000A
    00000DB6 3217                   CMP/GT      R1,R2
    00000DB8 8D04                   BT/S        L320
    00000DBA E500                   MOV         #0,R5      ; H'00000000
    00000DBC 604C                   EXTU.B      R4,R0
               mnet.c       1326      {
               mnet.c       1327          Result = MOTORSPD_TBL[factor];
    00000DBE D248                   MOV.L       L623,R2    ; __$MOTORSPD_TBL
    00000DC0 4008                   SHLL2       R0
    00000DC2 052E                   MOV.L       @(R0,R2),R5; MOTORSPD_TBL[]
    00000DC4              L320:
               mnet.c       1328      }
               mnet.c       1329      return( Result );
               mnet.c       1330    }
    00000DC4 057B                   RTV/N       R5
               mnet.c       1331    /******************************************************************************
               mnet.c       1332    * 
               mnet.c       1333    * [概要]  モータ速度倍率取得
               mnet.c       1334    * [引数]  速度番号
               mnet.c       1335    * [戻値]  倍率値
               mnet.c       1336    * 
               mnet.c       1337    ******************************************************************************/
               mnet.c       1338    INT GetFactorPCD4611( UB factor )
    00000DC6              _GetFactorPCD4611:               ; function: GetFactorPCD4611
                                                           ; frame size=0
               mnet.c       1339    {
               mnet.c       1340      INT Result = 0;
               mnet.c       1341    
               mnet.c       1342      if( ( factor >= 0)&&( factor <= 10 ))
    00000DC6 624C                   EXTU.B      R4,R2
    00000DC8 E10A                   MOV         #10,R1     ; H'0000000A
    00000DCA 3217                   CMP/GT      R1,R2
    00000DCC 8D04                   BT/S        L323
    00000DCE E500                   MOV         #0,R5      ; H'00000000
    00000DD0 604C                   EXTU.B      R4,R0
               mnet.c       1343      {
               mnet.c       1344          Result = MOTORSPD_TBL_PCD4611[factor];
    00000DD2 D244                   MOV.L       L623+4,R2  ; __$MOTORSPD_TBL_PCD4611
    00000DD4 4008                   SHLL2       R0
    00000DD6 052E                   MOV.L       @(R0,R2),R5; MOTORSPD_TBL_PCD4611[]
    00000DD8              L323:
               mnet.c       1345      }
               mnet.c       1346      return( Result );
               mnet.c       1347    }
    00000DD8 057B                   RTV/N       R5
               mnet.c       1348    
               mnet.c       1349    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c       1350    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c       1351    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
               mnet.c       1352    
               mnet.c       1353    
               mnet.c       1354    /***********************************************************************
               mnet.c       1355    *
               mnet.c       1356    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1357    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1358    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1359    * 
               mnet.c       1360    ***********************************************************************/
               mnet.c       1361    static BOOL WriteMemory(INT addr, UH data)
    00000DDA              __$WriteMemory:                  ; function: __$WriteMemory
                                                           ; frame size=12
    00000DDA 4DF0                   MOVMU.L     R13,@-R15
    00000DDC D142                   MOV.L       L623+8,R1  ; H'0C008000
               mnet.c       1362    {
               mnet.c       1363      volatile UB *p = (UB *)(MNET_BASE_ADDRESS + addr);
    00000DDE 6D53                   MOV         R5,R13
    00000DE0 E5FF                   MOV         #-1,R5     ; H'FFFFFFFF
    00000DE2 341C                   ADD         R1,R4
    00000DE4 6E43                   MOV         R4,R14
               mnet.c       1364      ER  result = E_SUCCESS;
               mnet.c       1365    
               mnet.c       1366      // バス経由によるデータ通知のためアクセス頻度がある
               mnet.c       1367      // 場合、データ競合の可能性もでてくるため排他制御追加
               mnet.c       1368      MAC_WAI_SEM( ID_SEM_MEMRW );
    00000DE6 D741                   MOV.L       L623+12,R7 ; _v4_twai_sem
    00000DE8 470B                   JSR         @R7
    00000DEA E414                   MOV         #20,R4     ; H'00000014
    00000DEC 2008                   TST         R0,R0
    00000DEE 8F14                   BF/S        L326
    00000DF0 6603                   MOV         R0,R6
               mnet.c       1369    
               mnet.c       1370      *p++ = (UB)(data >> 0);
    00000DF2 60DD                   EXTU.W      R13,R0
               mnet.c       1371      *p   = (UB)(data >> 8);
    00000DF4 E6F8                   MOV         #-8,R6     ; H'FFFFFFF8
    00000DF6 2E00                   MOV.B       R0,@R14
    00000DF8 406C                   SHAD        R6,R0
               mnet.c       1372    
               mnet.c       1373    #ifdef WAIT_TYPE_IFB
               mnet.c       1374      // TRUE:ビジー  
               mnet.c       1375      if( IfbIdleWait() == TRUE )
    00000DFA B538                   BSR         __$IfbIdleWait
    00000DFC 80E1                   MOV.B       R0,@(1,R14); *(p)
    00000DFE 8801                   CMP/EQ      #1,R0
    00000E00 8B01                   BF          L328
               mnet.c       1376      {
               mnet.c       1377          return FALSE;
    00000E02 A00D                   BRA         L329
    00000E04 0039                   MOVRT       R0
    00000E06              L328:
               mnet.c       1378      }
               mnet.c       1379    #endif
               mnet.c       1380    
               mnet.c       1381    #ifdef WAIT_TYPE_RW
               mnet.c       1382      g_Sleep(50);
    00000E06 B52B                   BSR         _g_Sleep
    00000E08 E432                   MOV         #50,R4     ; H'00000032
               mnet.c       1383    #endif
               mnet.c       1384    
               mnet.c       1385      MAC_SIG_SEM( ID_SEM_MEMRW );
    00000E0A D239                   MOV.L       L623+16,R2 ; _v4_sig_sem
    00000E0C 420B                   JSR         @R2
    00000E0E E414                   MOV         #20,R4     ; H'00000014
    00000E10 2008                   TST         R0,R0
    00000E12 8F02                   BF/S        L326
    00000E14 6603                   MOV         R0,R6
               mnet.c       1386    
               mnet.c       1387      return TRUE;
    00000E16 A003                   BRA         L329
    00000E18 0029                   MOVT        R0
    00000E1A              L326:
    00000E1A E005                   MOV         #5,R0      ; H'00000005
    00000E1C 4018                   SHLL8       R0
    00000E1E 3068                   SUB         R6,R0
    00000E20              L329:
    00000E20 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1388    }
    00000E22 006B                   RTS/N
               mnet.c       1389    /***********************************************************************
               mnet.c       1390    *
               mnet.c       1391    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1392    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1393    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1394    * 
               mnet.c       1395    ***********************************************************************/
               mnet.c       1396    static BOOL WriteMemoryInt(INT addr, INT data)
    00000E24              __$WriteMemoryInt:               ; function: __$WriteMemoryInt
                                                           ; frame size=12
    00000E24 4DF0                   MOVMU.L     R13,@-R15
    00000E26 D130                   MOV.L       L623+8,R1  ; H'0C008000
               mnet.c       1397    { 
               mnet.c       1398      volatile UB *p = (UB *)(MNET_BASE_ADDRESS + addr);
    00000E28 6D53                   MOV         R5,R13
    00000E2A E5FF                   MOV         #-1,R5     ; H'FFFFFFFF
    00000E2C 341C                   ADD         R1,R4
    00000E2E 6E43                   MOV         R4,R14
               mnet.c       1399      ER  result = E_SUCCESS;
               mnet.c       1400    
               mnet.c       1401      // バス経由によるデータ通知のためアクセス頻度がある
               mnet.c       1402      // 場合、データ競合の可能性もでてくるため排他制御追加
               mnet.c       1403      MAC_WAI_SEM( ID_SEM_MEMRW );
    00000E30 D72E                   MOV.L       L623+12,R7 ; _v4_twai_sem
    00000E32 470B                   JSR         @R7
    00000E34 E414                   MOV         #20,R4     ; H'00000014
    00000E36 2008                   TST         R0,R0
    00000E38 8F1B                   BF/S        L333
    00000E3A 6603                   MOV         R0,R6
    00000E3C E1F8                   MOV         #-8,R1     ; H'FFFFFFF8
               mnet.c       1404    
               mnet.c       1405      *(p+0) = (UB)(data >> 0);
               mnet.c       1406      *(p+1) = (UB)(data >> 8);
               mnet.c       1407      *(p+0) = (UB)(data >> 16);
               mnet.c       1408      *(p+1) = (UB)(data >> 24);
    00000E3E E4E8                   MOV         #-24,R4    ; H'FFFFFFE8
    00000E40 2ED0                   MOV.B       R13,@R14   ; p[]
    00000E42 60D3                   MOV         R13,R0
    00000E44 401C                   SHAD        R1,R0
    00000E46 62D3                   MOV         R13,R2
    00000E48 80E1                   MOV.B       R0,@(1,R14); p[]
    00000E4A 4229                   SHLR16      R2
    00000E4C 4D4C                   SHAD        R4,R13
    00000E4E 2E20                   MOV.B       R2,@R14    ; p[]
    00000E50 60D3                   MOV         R13,R0
               mnet.c       1409    
               mnet.c       1410      // TRUE:ビジー  
               mnet.c       1411      if( IfbIdleWait() == TRUE )
    00000E52 B50C                   BSR         __$IfbIdleWait
    00000E54 80E1                   MOV.B       R0,@(1,R14); p[]
    00000E56 8801                   CMP/EQ      #1,R0
    00000E58 8B01                   BF          L335
               mnet.c       1412      {
               mnet.c       1413          return FALSE;
    00000E5A A00D                   BRA         L336
    00000E5C 0039                   MOVRT       R0
    00000E5E              L335:
               mnet.c       1414      }
               mnet.c       1415    
               mnet.c       1416    #ifdef WAIT_TYPE_RW
               mnet.c       1417      g_Sleep(50);
    00000E5E B4FF                   BSR         _g_Sleep
    00000E60 E432                   MOV         #50,R4     ; H'00000032
               mnet.c       1418    #endif
               mnet.c       1419      MAC_SIG_SEM( ID_SEM_MEMRW );
    00000E62 D223                   MOV.L       L623+16,R2 ; _v4_sig_sem
    00000E64 420B                   JSR         @R2
    00000E66 E414                   MOV         #20,R4     ; H'00000014
    00000E68 2008                   TST         R0,R0
    00000E6A 8F02                   BF/S        L333
    00000E6C 6603                   MOV         R0,R6
               mnet.c       1420    
               mnet.c       1421      return TRUE;
    00000E6E A003                   BRA         L336
    00000E70 0029                   MOVT        R0
    00000E72              L333:
    00000E72 E005                   MOV         #5,R0      ; H'00000005
    00000E74 4018                   SHLL8       R0
    00000E76 3068                   SUB         R6,R0
    00000E78              L336:
    00000E78 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1422    }
    00000E7A 006B                   RTS/N
               mnet.c       1423    /***********************************************************************
               mnet.c       1424    *
               mnet.c       1425    * [概要]  センターデバイスのメモリーからデータを読み出します
               mnet.c       1426    * [引数]  addr：読み出しアドレス、data：読み出しデータ
               mnet.c       1427    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1428    * 
               mnet.c       1429    ***********************************************************************/
               mnet.c       1430    static BOOL ReadMemory(INT addr,  UH *data)
    00000E7C              __$ReadMemory:                   ; function: __$ReadMemory
                                                           ; frame size=12
    00000E7C 4DF0                   MOVMU.L     R13,@-R15
    00000E7E D11A                   MOV.L       L623+8,R1  ; H'0C008000
               mnet.c       1431    {
               mnet.c       1432      UB  b0;
               mnet.c       1433      UB  b1;
               mnet.c       1434      ER  result = E_SUCCESS;
               mnet.c       1435    
               mnet.c       1436      volatile UB *p = (UB *)(MNET_BASE_ADDRESS + addr);
    00000E80 6D53                   MOV         R5,R13
    00000E82 E5FF                   MOV         #-1,R5     ; H'FFFFFFFF
    00000E84 341C                   ADD         R1,R4
    00000E86 6E43                   MOV         R4,R14
               mnet.c       1437    
               mnet.c       1438      // バス経由によるデータ通知のためアクセス頻度がある
               mnet.c       1439      // 場合、データ競合の可能性もでてくるため排他制御追加
               mnet.c       1440      MAC_WAI_SEM( ID_SEM_MEMRW );
    00000E88 D718                   MOV.L       L623+12,R7 ; _v4_twai_sem
    00000E8A 470B                   JSR         @R7
    00000E8C E414                   MOV         #20,R4     ; H'00000014
    00000E8E 2008                   TST         R0,R0
    00000E90 8F16                   BF/S        L340
    00000E92 6603                   MOV         R0,R6
               mnet.c       1441    
               mnet.c       1442      b0 = (UB)*p++;
    00000E94 35E18000               MOVU.B      @(0,R14),R5
               mnet.c       1443      b1 = (UB)*p;
    00000E98 30E18001               MOVU.B      @(1,R14),R0; *(p)
               mnet.c       1444      *data      = (b1 << 8) | b0;
    00000E9C 4018                   SHLL8       R0
    00000E9E 205B                   OR          R5,R0
               mnet.c       1445    
               mnet.c       1446    #ifdef WAIT_TYPE_IFB
               mnet.c       1447      // TRUE:ビジー  
               mnet.c       1448      if( IfbIdleWait() == TRUE )
    00000EA0 B4E5                   BSR         __$IfbIdleWait
    00000EA2 2D01                   MOV.W       R0,@R13    ; *(data)
    00000EA4 8801                   CMP/EQ      #1,R0
    00000EA6 8B01                   BF          L342
               mnet.c       1449      {
               mnet.c       1450          return FALSE;
    00000EA8 A00D                   BRA         L343
    00000EAA 0039                   MOVRT       R0
    00000EAC              L342:
               mnet.c       1451      }
               mnet.c       1452    #endif
               mnet.c       1453    #ifdef WAIT_TYPE_RW
               mnet.c       1454      g_Sleep(50);
    00000EAC B4D8                   BSR         _g_Sleep
    00000EAE E432                   MOV         #50,R4     ; H'00000032
               mnet.c       1455    #endif
               mnet.c       1456      MAC_SIG_SEM( ID_SEM_MEMRW );
    00000EB0 D20F                   MOV.L       L623+16,R2 ; _v4_sig_sem
    00000EB2 420B                   JSR         @R2
    00000EB4 E414                   MOV         #20,R4     ; H'00000014
    00000EB6 2008                   TST         R0,R0
    00000EB8 8F02                   BF/S        L340
    00000EBA 6603                   MOV         R0,R6
               mnet.c       1457    
               mnet.c       1458      return TRUE;
    00000EBC A003                   BRA         L343
    00000EBE 0029                   MOVT        R0
    00000EC0              L340:
    00000EC0 E005                   MOV         #5,R0      ; H'00000005
    00000EC2 4018                   SHLL8       R0
    00000EC4 3068                   SUB         R6,R0
    00000EC6              L343:
    00000EC6 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1459    }
    00000EC8 006B                   RTS/N
               mnet.c       1460    /***********************************************************************
               mnet.c       1461    *
               mnet.c       1462    * [概要]  センターデバイスにコマンドを書き込みます
               mnet.c       1463    * [引数]  command：コマンド
               mnet.c       1464    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1465    * 
               mnet.c       1466    ***********************************************************************/
               mnet.c       1467    static BOOL  SetMainCommand(UH command)
    00000ECA              __$SetMainCommand:               ; function: __$SetMainCommand
                                                           ; frame size=0
               mnet.c       1468    {
               mnet.c       1469      return WriteMemory(MNET_COMMAND, command);
    00000ECA 654D                   EXTU.W      R4,R5
    00000ECC AF85                   BRA         __$WriteMemory
    00000ECE E400                   MOV         #0,R4      ; H'00000000
               mnet.c       1470    }
               mnet.c       1471    /***********************************************************************
               mnet.c       1472    *
               mnet.c       1473    * [概要]  センターデバイスのステータスを取得します
               mnet.c       1474    * [引数]  status：MNET状態格納先
               mnet.c       1475    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1476    * 
               mnet.c       1477    ***********************************************************************/
               mnet.c       1478    static BOOL GetMainStatus(MNETStatus* status)
    00000ED0              __$GetMainStatus:                ; function: __$GetMainStatus
                                                           ; frame size=0
               mnet.c       1479    {
               mnet.c       1480      return ReadMemory(MNET_STATUS, &status->UNID.data);
    00000ED0 6543                   MOV         R4,R5
    00000ED2 AFD3                   BRA         __$ReadMemory
    00000ED4 E400                   MOV         #0,R4      ; H'00000000
               mnet.c       1481    }
               mnet.c       1482    
               mnet.c       1483    
               mnet.c       1484    
               mnet.c       1485    // --- PCD4611 ---------------------------------------------------------------------------------------------
               mnet.c       1486    
               mnet.c       1487    /***********************************************************************
               mnet.c       1488    *
               mnet.c       1489    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1490    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1491    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1492    * 
               mnet.c       1493    ***********************************************************************/
               mnet.c       1494    static void WriteMemoryPCD4611(UB data)
    00000ED6              __$WriteMemoryPCD4611:           ; function: __$WriteMemoryPCD4611
                                                           ; frame size=0
               mnet.c       1495    {
               mnet.c       1496      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000ED6 D207                   MOV.L       L623+20,R2 ; H'0C009000
    00000ED8 D507                   MOV.L       L623+24,R5 ; _pPulseMotor
    00000EDA 2522                   MOV.L       R2,@R5     ; pPulseMotor
               mnet.c       1497    
               mnet.c       1498      pPulseMotor->unCmdSts.stWrite.COMB0 = (unsigned char)data;
               mnet.c       1499    }
    00000EDC 000B                   RTS
    00000EDE 2240                   MOV.B       R4,@R2     ; (pPulseMotor)->COMB0
    00000EE0              L623:
    00000EE0 <00000000>             .DATA.L     __$MOTORSPD_TBL
    00000EE4 <00000000>             .DATA.L     __$MOTORSPD_TBL_PCD4611
    00000EE8 0C008000               .DATA.L     H'0C008000
    00000EEC <00000000>             .DATA.L     _v4_twai_sem
    00000EF0 <00000000>             .DATA.L     _v4_sig_sem
    00000EF4 0C009000               .DATA.L     H'0C009000
    00000EF8 <00000000>             .DATA.L     _pPulseMotor
               mnet.c       1500    /***********************************************************************
               mnet.c       1501    *
               mnet.c       1502    * [概要]  センターデバイスのメモリーにデータを書き込みます
               mnet.c       1503    * [引数]  addr：書込みアドレス、data：書込みデータ
               mnet.c       1504    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1505    * 
               mnet.c       1506    ***********************************************************************/
               mnet.c       1507    static void WriteMemoryIntPCD4611(INT data)
    00000EFC              __$WriteMemoryIntPCD4611:        ; function: __$WriteMemoryIntPCD4611
                                                           ; frame size=0
               mnet.c       1508    { 
               mnet.c       1509      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000EFC D179                   MOV.L       L624,R1    ; H'0C009000
               mnet.c       1510    
               mnet.c       1511      pPulseMotor->BUFB0 = (unsigned char)( data >> 0 );
    00000EFE 6043                   MOV         R4,R0
    00000F00 D579                   MOV.L       L624+4,R5  ; _pPulseMotor
    00000F02 2512                   MOV.L       R1,@R5     ; pPulseMotor
               mnet.c       1512      pPulseMotor->BUFB1 = (unsigned char)( data >> 8 );
               mnet.c       1513      pPulseMotor->BUFB2 = (unsigned char)( data >> 16 );
               mnet.c       1514      pPulseMotor->BUFB3 = (unsigned char)( data >> 24 );
    00000F04 E7E8                   MOV         #-24,R7    ; H'FFFFFFE8
    00000F06 8014                   MOV.B       R0,@(4,R1) ; (pPulseMotor)->BUFB0
    00000F08 E1F8                   MOV         #-8,R1     ; H'FFFFFFF8
    00000F0A 401C                   SHAD        R1,R0
    00000F0C 6252                   MOV.L       @R5,R2     ; pPulseMotor
    00000F0E 8025                   MOV.B       R0,@(5,R2) ; (pPulseMotor)->BUFB1
    00000F10 6043                   MOV         R4,R0
    00000F12 4029                   SHLR16      R0
    00000F14 6652                   MOV.L       @R5,R6     ; pPulseMotor
    00000F16 447C                   SHAD        R7,R4
    00000F18 8066                   MOV.B       R0,@(6,R6) ; (pPulseMotor)->BUFB2
    00000F1A 6043                   MOV         R4,R0
    00000F1C 6252                   MOV.L       @R5,R2     ; pPulseMotor
               mnet.c       1515    }
    00000F1E 000B                   RTS
    00000F20 8027                   MOV.B       R0,@(7,R2) ; (pPulseMotor)->BUFB3
               mnet.c       1516    
               mnet.c       1517    /***********************************************************************
               mnet.c       1518    *
               mnet.c       1519    * [概要]  センターデバイスのメモリーからデータを読み出します
               mnet.c       1520    * [引数]  addr：読み出しアドレス、data：読み出しデータ
               mnet.c       1521    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1522    * 
               mnet.c       1523    ***********************************************************************/
               mnet.c       1524    static INT ReadMemoryPCD4611()
    00000F22              __$ReadMemoryPCD4611:            ; function: __$ReadMemoryPCD4611
                                                           ; frame size=0
               mnet.c       1525    {
               mnet.c       1526      INT result = 0x00;
               mnet.c       1527      pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
    00000F22 D570                   MOV.L       L624,R5    ; H'0C009000
    00000F24 D170                   MOV.L       L624+4,R1  ; _pPulseMotor
    00000F26 2152                   MOV.L       R5,@R1     ; pPulseMotor
               mnet.c       1528    
               mnet.c       1529      result |=   ( (INT)( pPulseMotor->BUFB0 ) << 0 );
    00000F28 32518004               MOVU.B      @(4,R5),R2 ; (pPulseMotor)->BUFB0
               mnet.c       1530      result |=   ( (INT)( pPulseMotor->BUFB1 ) << 8 );
    00000F2C 30518005               MOVU.B      @(5,R5),R0 ; (pPulseMotor)->BUFB1
    00000F30 4018                   SHLL8       R0
    00000F32 220B                   OR          R0,R2
               mnet.c       1531      result |=   ( (INT)( pPulseMotor->BUFB2 ) << 16 );
    00000F34 30518006               MOVU.B      @(6,R5),R0 ; (pPulseMotor)->BUFB2
    00000F38 4028                   SHLL16      R0
    00000F3A 220B                   OR          R0,R2
               mnet.c       1532      result |=   ( (INT)( pPulseMotor->BUFB3 ) << 24 );
    00000F3C 8457                   MOV.B       @(7,R5),R0 ; (pPulseMotor)->BUFB3
               mnet.c       1533      
               mnet.c       1534      return result;
    00000F3E 4028                   SHLL16      R0
    00000F40 4018                   SHLL8       R0
               mnet.c       1535    }
    00000F42 000B                   RTS
    00000F44 202B                   OR          R2,R0
               mnet.c       1536    // --- PCD4611 ---------------------------------------------------------------------------------------------
               mnet.c       1537    
               mnet.c       1538    
               mnet.c       1539    
               mnet.c       1540    ///<summary>
               mnet.c       1541    /// メインデバイスのレジスターにデータを書き込みます
               mnet.c       1542    ///</summary>
               mnet.c       1543    static BOOL  SetMainRegister(UH reg, UH data)
    00000F46              __$SetMainRegister:              ; function: __$SetMainRegister
                                                           ; frame size=8
    00000F46 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       1544    {
               mnet.c       1545      // FALSE:書込み失敗?
               mnet.c       1546      if( WriteMemory(MNET_IO_BUFFER, data) == FALSE )
    00000F48 6E43                   MOV         R4,R14
    00000F4A E404                   MOV         #4,R4      ; H'00000004
    00000F4C BF45                   BSR         __$WriteMemory
    00000F4E 655D                   EXTU.W      R5,R5
    00000F50 2008                   TST         R0,R0
    00000F52 8D04                   BT/S        L352
    00000F54 E000                   MOV         #0,R0      ; H'00000000
               mnet.c       1547      {
               mnet.c       1548          return FALSE;
               mnet.c       1549      }
               mnet.c       1550      return SetMainCommand(reg);
    00000F56 64ED                   EXTU.W      R14,R4
    00000F58 4EF4                   MOVMU.L     @R15+,R14
    00000F5A AFB6                   BRA         __$SetMainCommand
    00000F5C 0009                   NOP
    00000F5E              L352:
    00000F5E 4EF4                   MOVMU.L     @R15+,R14
    00000F60 006B                   RTS/N
               mnet.c       1551    }
               mnet.c       1552    
               mnet.c       1553    
               mnet.c       1554    ///<summary>
               mnet.c       1555    /// 指定モーターデバイスにコマンドを書き込みます
               mnet.c       1556    ///</summary>
               mnet.c       1557    static BOOL   SetMotorCommand(UB dev_no, UH command)
    00000F62              __$SetMotorCommand:              ; function: __$SetMotorCommand
                                                           ; frame size=8
    00000F62 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       1558    {
               mnet.c       1559      if( MNET_DRV_TYPE[dev_no] == PCD4611 )
    00000F64 D661                   MOV.L       L624+8,R6  ; _MNET_DRV_TYPE
    00000F66 6E4C                   EXTU.B      R4,R14
    00000F68 60E3                   MOV         R14,R0
    00000F6A 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00000F6C 8809                   CMP/EQ      #9,R0
    00000F6E 8B03                   BF          L355
               mnet.c       1560      {
               mnet.c       1561          WriteMemoryPCD4611( (UB)command );
    00000F70 BFB1                   BSR         __$WriteMemoryPCD4611
    00000F72 6453                   MOV         R5,R4
    00000F74 A00E                   BRA         L356
    00000F76 0009                   NOP
    00000F78              L355:
               mnet.c       1562      }
               mnet.c       1563      else
               mnet.c       1564      {
               mnet.c       1565          WriteMemory(MNET_FIFO, command);                                // レジスタ書き込み
    00000F78 655D                   EXTU.W      R5,R5
    00000F7A BF2E                   BSR         __$WriteMemory
    00000F7C E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1566    
               mnet.c       1567          if( !SetMainCommand((MNET_DATA_COMMUNICATION_BASE + dev_no)) )  // FALSE:コマンドセット失敗?
    00000F7E E240                   MOV         #64,R2     ; H'00000040
    00000F80 4218                   SHLL8       R2
    00000F82 3E2C                   ADD         R2,R14
    00000F84 BFA1                   BSR         __$SetMainCommand
    00000F86 64E3                   MOV         R14,R4
    00000F88 2008                   TST         R0,R0
    00000F8A 8905                   BT          L358
               mnet.c       1568          {
               mnet.c       1569              return FALSE;
               mnet.c       1570          }
               mnet.c       1571    
               mnet.c       1572    #ifdef WAIT_END_CHK
               mnet.c       1573          
               mnet.c       1574          if( EndIdleWait()  == TRUE )                                    // TRUE:ビジー  
    00000F8C B484                   BSR         __$EndIdleWait
    00000F8E 0009                   NOP
    00000F90 8801                   CMP/EQ      #1,R0
    00000F92 8901                   BT          L358
    00000F94              L356:
               mnet.c       1575          {
               mnet.c       1576              return FALSE;
               mnet.c       1577          }
               mnet.c       1578    #endif
               mnet.c       1579      }
               mnet.c       1580      return TRUE;
    00000F94 A001                   BRA         L359
    00000F96 E001                   MOV         #1,R0      ; H'00000001
    00000F98              L358:
    00000F98 0039                   MOVRT       R0
    00000F9A              L359:
    00000F9A 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       1581    }
    00000F9C 006B                   RTS/N
               mnet.c       1582    
               mnet.c       1583    ///<summary>
               mnet.c       1584    /// 指定モーターデバイスのレジスターにデータを書き込みます
               mnet.c       1585    ///</summary>
               mnet.c       1586    static BOOL   SetMotorRegisterInt(UB dev_no, UH reg, INT value)
    00000F9E              _SetMotorRegisterInt:            ; function: SetMotorRegisterInt
                                                           ; frame size=12
    00000F9E 4DF0                   MOVMU.L     R13,@-R15
    00000FA0 D152                   MOV.L       L624+8,R1  ; _MNET_DRV_TYPE
    00000FA2 604C                   EXTU.B      R4,R0
    00000FA4 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
               mnet.c       1587    {
               mnet.c       1588      if( MNET_DRV_TYPE[dev_no] == PCD4611 )
    00000FA6 6D63                   MOV         R6,R13
    00000FA8 8809                   CMP/EQ      #9,R0
    00000FAA 8F06                   BF/S        L362
    00000FAC 6E53                   MOV         R5,R14
               mnet.c       1589      {
               mnet.c       1590          WriteMemoryIntPCD4611(value);
    00000FAE BFA5                   BSR         __$WriteMemoryIntPCD4611
    00000FB0 64D3                   MOV         R13,R4
               mnet.c       1591          WriteMemoryPCD4611((UB)reg);
    00000FB2 BF90                   BSR         __$WriteMemoryPCD4611
    00000FB4 64E3                   MOV         R14,R4
    00000FB6 A00C                   BRA         L363
    00000FB8 0009                   NOP
    00000FBA              L362:
               mnet.c       1592      }
               mnet.c       1593      else
               mnet.c       1594      {
               mnet.c       1595          WriteMemory   (MNET_FIFO, reg);     // レジスタ書き込み
    00000FBA 65ED                   EXTU.W      R14,R5
    00000FBC BF0D                   BSR         __$WriteMemory
    00000FBE E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1596          WriteMemoryInt(MNET_FIFO, value);   // データ書き込み
    00000FC0 E406                   MOV         #6,R4      ; H'00000006
    00000FC2 BF2F                   BSR         __$WriteMemoryInt
    00000FC4 65D3                   MOV         R13,R5
               mnet.c       1597          
               mnet.c       1598          if( EndIdleWait()  == TRUE )        // TRUE:ビジーのまま
    00000FC6 B467                   BSR         __$EndIdleWait
    00000FC8 0009                   NOP
    00000FCA 8801                   CMP/EQ      #1,R0
    00000FCC 8B01                   BF          L363
               mnet.c       1599          {
               mnet.c       1600              return ( FALSE );
    00000FCE A001                   BRA         L365
    00000FD0 0039                   MOVRT       R0
    00000FD2              L363:
               mnet.c       1601          }
               mnet.c       1602      }
               mnet.c       1603      
               mnet.c       1604      return TRUE;
    00000FD2 E001                   MOV         #1,R0      ; H'00000001
    00000FD4              L365:
    00000FD4 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1605    }
    00000FD6 006B                   RTS/N
               mnet.c       1606    
               mnet.c       1607    ///<summary>
               mnet.c       1608    /// 指定モーターデバイスのレジスターにデータを書き込みます
               mnet.c       1609    ///</summary>
               mnet.c       1610    static BOOL   SetMotorRegister(UB dev_no, UH reg, UH value)
    00000FD8              __$SetMotorRegister:             ; function: __$SetMotorRegister
                                                           ; frame size=16
    00000FD8 4CF0                   MOVMU.L     R12,@-R15
    00000FDA D145                   MOV.L       L624+12,R1 ; _MNET_NO
    00000FDC 604C                   EXTU.B      R4,R0
    00000FDE 021C                   MOV.B       @(R0,R1),R2; MNET_NO[]
               mnet.c       1611    {
               mnet.c       1612      UB mnetno;
               mnet.c       1613    
               mnet.c       1614      mnetno = MNET_NO[dev_no];
    00000FE0 6C53                   MOV         R5,R12
    00000FE2 6E2C                   EXTU.B      R2,R14
               mnet.c       1615    
               mnet.c       1616      if( MNET_DRV_TYPE[mnetno] == PCD4611 )
    00000FE4 D241                   MOV.L       L624+8,R2  ; _MNET_DRV_TYPE
    00000FE6 60E3                   MOV         R14,R0
    00000FE8 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    00000FEA 8809                   CMP/EQ      #9,R0
    00000FEC 8F06                   BF/S        L368
    00000FEE 6D63                   MOV         R6,R13
               mnet.c       1617      {
               mnet.c       1618          WriteMemoryPCD4611(value);
    00000FF0 BF71                   BSR         __$WriteMemoryPCD4611
    00000FF2 64D3                   MOV         R13,R4
               mnet.c       1619          WriteMemoryPCD4611(reg);
    00000FF4 BF6F                   BSR         __$WriteMemoryPCD4611
    00000FF6 64C3                   MOV         R12,R4
    00000FF8 A011                   BRA         L369
    00000FFA 0009                   NOP
    00000FFC              L368:
               mnet.c       1620      }
               mnet.c       1621      else
               mnet.c       1622      {
               mnet.c       1623          WriteMemory   (MNET_FIFO, reg);     // レジスタ書き込み
    00000FFC 65CD                   EXTU.W      R12,R5
    00000FFE BEEC                   BSR         __$WriteMemory
    00001000 E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1624          WriteMemoryInt(MNET_FIFO, value);   // データ書き込み
    00001002 65DD                   EXTU.W      R13,R5
    00001004 BF0E                   BSR         __$WriteMemoryInt
    00001006 E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1625    
               mnet.c       1626          if( !SetMainCommand((MNET_DATA_COMMUNICATION_BASE + mnetno)) )// FALSE:コマンドセット失敗?
    00001008 E240                   MOV         #64,R2     ; H'00000040
    0000100A 4218                   SHLL8       R2
    0000100C 3E2C                   ADD         R2,R14
    0000100E BF5C                   BSR         __$SetMainCommand
    00001010 64E3                   MOV         R14,R4
    00001012 2008                   TST         R0,R0
    00001014 8905                   BT          L371
               mnet.c       1627          {
               mnet.c       1628              return ( FALSE );
               mnet.c       1629          }
               mnet.c       1630          
               mnet.c       1631          if( EndIdleWait()  == TRUE )        // TRUE:ビジー  
    00001016 B43F                   BSR         __$EndIdleWait
    00001018 0009                   NOP
    0000101A 8801                   CMP/EQ      #1,R0
    0000101C 8901                   BT          L371
    0000101E              L369:
               mnet.c       1632          {
               mnet.c       1633              return ( FALSE );
               mnet.c       1634          }
               mnet.c       1635      }
               mnet.c       1636    
               mnet.c       1637    
               mnet.c       1638      return TRUE;
    0000101E A001                   BRA         L372
    00001020 E001                   MOV         #1,R0      ; H'00000001
    00001022              L371:
    00001022 0039                   MOVRT       R0
    00001024              L372:
    00001024 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1639    }
    00001026 006B                   RTS/N
               mnet.c       1640    ///<summary>
               mnet.c       1641    /// 指定モーターデバイスのレジスターからデータを読み込みます
               mnet.c       1642    ///</summary>
               mnet.c       1643    // FALSE:異常、TRUE:成功
               mnet.c       1644    BOOL  GetMotorRegister(UB dev_no, UH reg, INT* value)
    00001028              _GetMotorRegister:               ; function: GetMotorRegister
                                                           ; frame size=24
    00001028 4CF0                   MOVMU.L     R12,@-R15
    0000102A 7FF8                   ADD         #-8,R15
    0000102C D130                   MOV.L       L624+12,R1 ; _MNET_NO
    0000102E 604C                   EXTU.B      R4,R0
    00001030 021C                   MOV.B       @(R0,R1),R2; MNET_NO[]
               mnet.c       1645    {
               mnet.c       1646      INT fifo_dat;
               mnet.c       1647      UB mnetno;
               mnet.c       1648      MNETStatus status;
               mnet.c       1649    
               mnet.c       1650      mnetno = MNET_NO[dev_no];
    00001032 6C63                   MOV         R6,R12
    00001034 6E2C                   EXTU.B      R2,R14
               mnet.c       1651    
               mnet.c       1652      if( MNET_DRV_TYPE[mnetno] == PCD4611 )
    00001036 D22D                   MOV.L       L624+8,R2  ; _MNET_DRV_TYPE
    00001038 60E3                   MOV         R14,R0
    0000103A 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    0000103C 8809                   CMP/EQ      #9,R0
    0000103E 8F06                   BF/S        L375
    00001040 6D53                   MOV         R5,R13
               mnet.c       1653      {
               mnet.c       1654          WriteMemoryPCD4611((UB)reg);
    00001042 BF48                   BSR         __$WriteMemoryPCD4611
    00001044 64D3                   MOV         R13,R4
               mnet.c       1655          *value  =  ReadMemoryPCD4611();
    00001046 BF6C                   BSR         __$ReadMemoryPCD4611
    00001048 0009                   NOP
    0000104A A045                   BRA         L376
    0000104C 2C02                   MOV.L       R0,@R12    ; *(value)
    0000104E              L375:
               mnet.c       1656      }
               mnet.c       1657      else
               mnet.c       1658      {
               mnet.c       1659          if (!SetMainCommand(MNET_CMD_CLEAR_RECV_FIFO))      return FALSE;
    0000104E E403                   MOV         #3,R4      ; H'00000003
    00001050 BF3B                   BSR         __$SetMainCommand
    00001052 4418                   SHLL8       R4
    00001054 2008                   TST         R0,R0
    00001056 8941                   BT          L378
               mnet.c       1660    
               mnet.c       1661          // リードコマンドをＦＩＦＯへ書き込む
               mnet.c       1662          WriteMemory(MNET_FIFO, reg);
    00001058 65DD                   EXTU.W      R13,R5
    0000105A BEBE                   BSR         __$WriteMemory
    0000105C E406                   MOV         #6,R4      ; H'00000006
               mnet.c       1663          // リードコマンドをＦＩＦＯへ書き込む
               mnet.c       1664          if( !SetMainCommand((MNET_DATA_COMMUNICATION_BASE + mnetno)) )
    0000105E E640                   MOV         #64,R6     ; H'00000040
    00001060 4618                   SHLL8       R6
    00001062 3E6C                   ADD         R6,R14
    00001064 BF31                   BSR         __$SetMainCommand
    00001066 64E3                   MOV         R14,R4
    00001068 2008                   TST         R0,R0
    0000106A 8937                   BT          L378
    0000106C              L379:
               mnet.c       1665          {
               mnet.c       1666              return ( FALSE );
               mnet.c       1667          }
               mnet.c       1668          // ステータスリード処理
               mnet.c       1669          while (TRUE)
               mnet.c       1670          {
               mnet.c       1671              // ステータスリード
               mnet.c       1672              GetMainStatus(&status);
    0000106C BF30                   BSR         __$GetMainStatus
    0000106E 64F3                   MOV         R15,R4
               mnet.c       1673    
               mnet.c       1674              // CEND = 1?
               mnet.c       1675              if( status.UNID.BIT.CEND == 1 )
    00001070 84F1                   MOV.B       @(1,R15),R0; (part of)status
    00001072 8708                   BLD         #0,R0
    00001074 8FFA                   BF/S        L379
    00001076 6603                   MOV         R0,R6
               mnet.c       1676              {
               mnet.c       1677                  // EDTE = 0?
               mnet.c       1678                  if(status.UNID.BIT.EDTE == 0 )
    00001078 876C                   BLD         #4,R6
    0000107A 892F                   BT          L378
               mnet.c       1679                  {
               mnet.c       1680                      // 正常
               mnet.c       1681                      break;
               mnet.c       1682                  }
               mnet.c       1683                  else
               mnet.c       1684                  {
               mnet.c       1685                      // 異常
               mnet.c       1686                      return FALSE;
               mnet.c       1687                  }
               mnet.c       1688              }
               mnet.c       1689          }
               mnet.c       1690          *value  = ((INT)(pMotionnet->fifo0) <<  0);
    0000107C D11D                   MOV.L       L624+16,R1 ; _pMotionnet
    0000107E 6212                   MOV.L       @R1,R2     ; pMotionnet
    00001080 8426                   MOV.B       @(6,R2),R0 ; (pMotionnet)->fifo0
    00001082 2C02                   MOV.L       R0,@R12    ; *(value)
    00001084 6603                   MOV         R0,R6
               mnet.c       1691          *value |= ((INT)(pMotionnet->fifo1) <<  8);
    00001086 6512                   MOV.L       @R1,R5     ; pMotionnet
    00001088 8457                   MOV.B       @(7,R5),R0 ; (pMotionnet)->fifo1
    0000108A 4018                   SHLL8       R0
    0000108C 260B                   OR          R0,R6
               mnet.c       1692    #ifdef WAIT_TYPE_IFB
               mnet.c       1693          // TRUE:ビジー  
               mnet.c       1694          if( IfbIdleWait() == TRUE )
    0000108E B3EE                   BSR         __$IfbIdleWait
    00001090 2C62                   MOV.L       R6,@R12    ; *(value)
    00001092 8801                   CMP/EQ      #1,R0
    00001094 8922                   BT          L378
               mnet.c       1695          {
               mnet.c       1696              return FALSE;
               mnet.c       1697          }
               mnet.c       1698    #endif
               mnet.c       1699    
               mnet.c       1700          fifo_dat  =  (pMotionnet->fifo0 & 0x000000ff);
    00001096 D717                   MOV.L       L624+16,R7 ; _pMotionnet
    00001098 6272                   MOV.L       @R7,R2     ; pMotionnet
               mnet.c       1701          fifo_dat |= ((pMotionnet->fifo1 <<  8) & 0x0000ff00);
               mnet.c       1702          g_Sleep(30);
    0000109A E41E                   MOV         #30,R4     ; H'0000001E
    0000109C 0E00FF00               MOVI20      #65280,R14 ; H'0000FF00
    000010A0 35218006               MOVU.B      @(6,R2),R5 ; (pMotionnet)->fifo0
    000010A4 8427                   MOV.B       @(7,R2),R0 ; (pMotionnet)->fifo1
               mnet.c       1703          fifo_dat |= ((pMotionnet->fifo0 << 16) & 0x00ff0000);
    000010A6 DD13                   MOV.L       L624+16,R13; _pMotionnet
    000010A8 4018                   SHLL8       R0
    000010AA 20E9                   AND         R14,R0
    000010AC 250B                   OR          R0,R5
    000010AE B3D7                   BSR         _g_Sleep
    000010B0 1F51                   MOV.L       R5,@(4,R15); fifo_dat
    000010B2 64D2                   MOV.L       @R13,R4    ; pMotionnet
    000010B4 0101FF00               MOVI20S     #16711680,R1; H'00FF0000
    000010B8 8446                   MOV.B       @(6,R4),R0 ; (pMotionnet)->fifo0
    000010BA 56F1                   MOV.L       @(4,R15),R6; fifo_dat
    000010BC 4028                   SHLL16      R0
               mnet.c       1704          fifo_dat |= ((pMotionnet->fifo1 << 24) & 0xff000000);
               mnet.c       1705          *value  =  fifo_dat;
    000010BE 05F10000               MOVI20S     #-16777216,R5; H'FF000000
    000010C2 2019                   AND         R1,R0
    000010C4 260B                   OR          R0,R6
    000010C6 8447                   MOV.B       @(7,R4),R0 ; (pMotionnet)->fifo1
    000010C8 4028                   SHLL16      R0
    000010CA 4018                   SHLL8       R0
    000010CC 2059                   AND         R5,R0
    000010CE 260B                   OR          R0,R6
               mnet.c       1706    #ifdef WAIT_END_CHK
               mnet.c       1707          // TRUE:ビジー  
               mnet.c       1708          if( EndIdleWait()  == TRUE )
    000010D0 B3E2                   BSR         __$EndIdleWait
    000010D2 2C62                   MOV.L       R6,@R12    ; *(value)
    000010D4 8801                   CMP/EQ      #1,R0
    000010D6 8901                   BT          L378
    000010D8              L376:
               mnet.c       1709          {
               mnet.c       1710              return FALSE;
               mnet.c       1711          }
               mnet.c       1712    #endif
               mnet.c       1713      }
               mnet.c       1714    
               mnet.c       1715      
               mnet.c       1716      return( TRUE );
    000010D8 A001                   BRA         L383
    000010DA E001                   MOV         #1,R0      ; H'00000001
    000010DC              L378:
    000010DC 0039                   MOVRT       R0
    000010DE              L383:
    000010DE 7F08                   ADD         #8,R15
    000010E0 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       1717    }
    000010E2 006B                   RTS/N
    000010E4              L624:
    000010E4 0C009000               .DATA.L     H'0C009000
    000010E8 <00000000>             .DATA.L     _pPulseMotor
    000010EC <00000000>             .DATA.L     _MNET_DRV_TYPE
    000010F0 <00000000>             .DATA.L     _MNET_NO
    000010F4 <00000000>             .DATA.L     _pMotionnet
               mnet.c       1718    
               mnet.c       1719    
               mnet.c       1720    ///<summary>
               mnet.c       1721    /// 指定モーターデバイスのステータスを読み込みます( PCD4611以外 )
               mnet.c       1722    ///</summary>
               mnet.c       1723    BOOL GetMotorStatus(UB dev_no, MotorStatus* status)
    000010F8              _GetMotorStatus:                 ; function: GetMotorStatus
                                                           ; frame size=24
    000010F8 4AF0                   MOVMU.L     R10,@-R15
    000010FA 6E43                   MOV         R4,R14
    000010FC 644C                   EXTU.B      R4,R4
               mnet.c       1724    {
               mnet.c       1725      UB Data_H = 0;
               mnet.c       1726      UB Data_L = 0;
               mnet.c       1727      UH Data_HL;
               mnet.c       1728    
               mnet.c       1729      if (!IsExist( dev_no ))
    000010FE B037                   BSR         _IsExist
    00001100 6B53                   MOV         R5,R11
    00001102 2008                   TST         R0,R0
    00001104 8D32                   BT/S        L386
    00001106 E000                   MOV         #0,R0      ; H'00000000
    00001108 D27A                   MOV.L       L625+2,R2  ; _pMotionnet
               mnet.c       1730      {
               mnet.c       1731          return FALSE;
               mnet.c       1732      }
               mnet.c       1733      
               mnet.c       1734      //  struct
               mnet.c       1735      //  {
               mnet.c       1736      //      UH  reserve2: 7;    // 常に0になります。
               mnet.c       1737      //      UH  SBSY    : 1;    // パルス出力開始で１になります。動作停止で０になります。（＝ＢＳＹ）
               mnet.c       1738      //      UH  reserve1: 4;    // 常に0になります。
               mnet.c       1739      //      UH  SEVT    : 1;    // イベント割り込み発生により１になり、ＲＩＳＴ読み出しで０になります。
               mnet.c       1740      //      UH  SERR    : 1;    // エラー割り込み発生により１になり、ＲＥＳＴ読み出しで０になります。
               mnet.c       1741      //      UH  SEND    : 1;    // 動作停止により割り込みを発生し、１になります。割り込みリセットコマンド(0008h)で０になります。
               mnet.c       1742      //      UH  SINT    : 1;    // 割り込み発生により１になります。(ビット１,２,３のいずれかが１)
               mnet.c       1743      //  }BIT;
               mnet.c       1744      MAC_READ( pMotionnet->portData[dev_no][0], Data_L )
    0000110A 6DEC                   EXTU.B      R14,R13
    0000110C 6A22                   MOV.L       @R2,R10    ; pMotionnet
    0000110E 4D08                   SHLL2       R13
    00001110 E601                   MOV         #1,R6      ; H'00000001
    00001112 67A3                   MOV         R10,R7
    00001114 37DC                   ADD         R13,R7
    00001116 3E718100               MOVU.B      @(256,R7),R14; pMotionnet->portData[]
    0000111A 4618                   SHLL8       R6
    0000111C E500                   MOV         #0,R5      ; H'00000000
    0000111E 61A3                   MOV         R10,R1
    00001120 316C                   ADD         R6,R1
    00001122 64E3                   MOV         R14,R4
    00001124 EC05                   MOV         #5,R12     ; H'00000005
    00001126 60D3                   MOV         R13,R0
    00001128              L387:
    00001128 021C                   MOV.B       @(R0,R1),R2; pMotionnet->portData[]
    0000112A 662C                   EXTU.B      R2,R6
    0000112C 3640                   CMP/EQ      R4,R6
    0000112E 8902                   BT          L389
    00001130 E500                   MOV         #0,R5      ; H'00000000
    00001132 6E63                   MOV         R6,R14
    00001134 6463                   MOV         R6,R4
    00001136              L389:
    00001136 7501                   ADD         #1,R5
    00001138 35C3                   CMP/GE      R12,R5
    0000113A 8BF5                   BF          L387
               mnet.c       1745      MAC_READ( pMotionnet->portData[dev_no][1], Data_H )
    0000113C 31718101               MOVU.B      @(257,R7),R1; pMotionnet->portData[]
    00001140 06000101               MOVI20      #257,R6    ; H'00000101
    00001144 6413                   MOV         R1,R4
    00001146 3A6C                   ADD         R6,R10
    00001148 E500                   MOV         #0,R5      ; H'00000000
    0000114A 60D3                   MOV         R13,R0
    0000114C              L392:
    0000114C 02AC                   MOV.B       @(R0,R10),R2; pMotionnet->portData[]
    0000114E 622C                   EXTU.B      R2,R2
    00001150 3240                   CMP/EQ      R4,R2
    00001152 8902                   BT          L394
    00001154 E500                   MOV         #0,R5      ; H'00000000
    00001156 6123                   MOV         R2,R1
    00001158 6423                   MOV         R2,R4
    0000115A              L394:
    0000115A 7501                   ADD         #1,R5
    0000115C 35C3                   CMP/GE      R12,R5
    0000115E 8BF5                   BF          L392
               mnet.c       1746    
               mnet.c       1747      status->UNID.data = ( ( Data_H * 0x100 ) + Data_L ) ;
    00001160 611C                   EXTU.B      R1,R1
               mnet.c       1748    
               mnet.c       1749      return TRUE;
    00001162 E001                   MOV         #1,R0      ; H'00000001
    00001164 4118                   SHLL8       R1
    00001166 6EEC                   EXTU.B      R14,R14
    00001168 31EC                   ADD         R14,R1
    0000116A 2B11                   MOV.W       R1,@R11    ; (status)->data
    0000116C              L386:
    0000116C 4AF4                   MOVMU.L     @R15+,R10
               mnet.c       1750    }
    0000116E 006B                   RTS/N
               mnet.c       1751    /******************************************************************************
               mnet.c       1752    * 
               mnet.c       1753    * [概要]  指定デバイスが存在するかチェックします
               mnet.c       1754    * [引数]  モーター番号
               mnet.c       1755    * [戻値]  TRUE:デバイス有、FALSE:デバイス無
               mnet.c       1756    * 
               mnet.c       1757    ******************************************************************************/
               mnet.c       1758    BOOL IsExist(UB dev_no)
    00001170              _IsExist:                        ; function: IsExist
                                                           ; frame size=4
    00001170 2FE6                   MOV.L       R14,@-R15
               mnet.c       1759    {
               mnet.c       1760      UB result = 0;
               mnet.c       1761      UB mnetno ;
               mnet.c       1762    
               mnet.c       1763      // 接続上限を超えている？
               mnet.c       1764      if( ( dev_no > DVMAX )||( ( dev_no < DVMIN ) ))
    00001172 644C                   EXTU.B      R4,R4
    00001174 E607                   MOV         #7,R6      ; H'00000007
    00001176 3467                   CMP/GT      R6,R4
    00001178 8932                   BT          L406
    0000117A E601                   MOV         #1,R6      ; H'00000001
    0000117C 3463                   CMP/GE      R6,R4
    0000117E 8B2F                   BF          L406
               mnet.c       1765      {
               mnet.c       1766          return( FALSE );
               mnet.c       1767      }
               mnet.c       1768    
               mnet.c       1769      switch( MNET_DRV_TYPE[dev_no] )
    00001180 D65D                   MOV.L       L625+6,R6  ; _MNET_DRV_TYPE
    00001182 6043                   MOV         R4,R0
    00001184 026C                   MOV.B       @(R0,R6),R2; MNET_DRV_TYPE[]
    00001186 2228                   TST         R2,R2
    00001188 8902                   BT          L409
    0000118A 6023                   MOV         R2,R0
    0000118C 8801                   CMP/EQ      #1,R0
    0000118E 8B01                   BF          L410
    00001190              L409:
               mnet.c       1770      {
               mnet.c       1771      case BCD4020FU:
               mnet.c       1772      case BCD4020FUA:
               mnet.c       1773          mnetno = dev_no;
    00001190 A00E                   BRA         L411
    00001192 6243                   MOV         R4,R2
    00001194              L410:
    00001194 8809                   CMP/EQ      #9,R0
    00001196 8909                   BT          L413
    00001198 8808                   CMP/EQ      #8,R0
    0000119A 8903                   BT          L415
    0000119C 880A                   CMP/EQ      #10,R0
    0000119E 8905                   BT          L413
    000011A0 A006                   BRA         L411
    000011A2 0009                   NOP
    000011A4              L415:
               mnet.c       1774          break;
               mnet.c       1775    
               mnet.c       1776      case PCD4611:
               mnet.c       1777          return TRUE;
               mnet.c       1778          break;
               mnet.c       1779    
               mnet.c       1780      case M204DUM:
               mnet.c       1781          mnetno = MNET_NO[dev_no]; 
    000011A4 D655                   MOV.L       L625+10,R6 ; _MNET_NO
    000011A6 6043                   MOV         R4,R0
    000011A8 A002                   BRA         L411
    000011AA 026C                   MOV.B       @(R0,R6),R2; MNET_NO[]
    000011AC              L413:
    000011AC A019                   BRA         L416
    000011AE 0029                   MOVT        R0
    000011B0              L411:
               mnet.c       1782          break;
               mnet.c       1783      case NCPRSUNIT:
               mnet.c       1784          return TRUE;
               mnet.c       1785          break;
               mnet.c       1786      }
               mnet.c       1787    
               mnet.c       1788    // シュミレーションモード
               mnet.c       1789    #if DEBUG_SIM_MODE != 0
               mnet.c       1790      return( TRUE ) ;
               mnet.c       1791    #endif
               mnet.c       1792      
               mnet.c       1793      MAC_READ( pMotionnet->deviceInformation[mnetno], result );
    000011B0 D150                   MOV.L       L625+2,R1  ; _pMotionnet
    000011B2 6612                   MOV.L       @R1,R6     ; pMotionnet
    000011B4 672C                   EXTU.B      R2,R7
    000011B6 E500                   MOV         #0,R5      ; H'00000000
    000011B8 EE05                   MOV         #5,R14     ; H'00000005
    000011BA 376C                   ADD         R6,R7
    000011BC 31718078               MOVU.B      @(120,R7),R1; pMotionnet->deviceInformation[]
    000011C0 A008                   BRA         L417
    000011C2 6413                   MOV         R1,R4
    000011C4              L418:
    000011C4 32718078               MOVU.B      @(120,R7),R2; pMotionnet->deviceInformation[]
    000011C8 3240                   CMP/EQ      R4,R2
    000011CA 8902                   BT          L420
    000011CC E500                   MOV         #0,R5      ; H'00000000
    000011CE 6123                   MOV         R2,R1
    000011D0 6423                   MOV         R2,R4
    000011D2              L420:
    000011D2 7501                   ADD         #1,R5
    000011D4              L417:
    000011D4 35E3                   CMP/GE      R14,R5
    000011D6 8BF5                   BF          L418
               mnet.c       1794    
               mnet.c       1795      return result != 0;
    000011D8 611C                   EXTU.B      R1,R1
    000011DA 2118                   TST         R1,R1
    000011DC A001                   BRA         L416
    000011DE 0039                   MOVRT       R0
    000011E0              L406:
    000011E0 E000                   MOV         #0,R0      ; H'00000000
    000011E2              L416:
               mnet.c       1796    }
    000011E2 000B                   RTS
    000011E4 6EF6                   MOV.L       @R15+,R14
               mnet.c       1797    
               mnet.c       1798    static    INT pcd_rsts;
               mnet.c       1799    
               mnet.c       1800    /******************************************************************************
               mnet.c       1801    * 
               mnet.c       1802    * [概要]  パルスモータが実行状態を返す
               mnet.c       1803    * [引数]  モーター番号
               mnet.c       1804    * [戻値]  TRUE:実行中、FALSE:アイドリング
               mnet.c       1805    * 
               mnet.c       1806    ******************************************************************************/
               mnet.c       1807    BOOL motor_IsBusy(UB pm)
    000011E6              _motor_IsBusy:                   ; function: motor_IsBusy
                                                           ; frame size=28
    000011E6 4AF0                   MOVMU.L     R10,@-R15
    000011E8 7FFC                   ADD         #-4,R15
               mnet.c       1808    {
               mnet.c       1809      INT Loop;
               mnet.c       1810      UH  wk = 0;
               mnet.c       1811      MotorStatus mstatus;
               mnet.c       1812    
               mnet.c       1813      if (!IsExist( pm ))
    000011EA 6E4C                   EXTU.B      R4,R14
    000011EC EA00                   MOV         #0,R10     ; H'00000000
    000011EE 6D43                   MOV         R4,R13
    000011F0 BFBE                   BSR         _IsExist
    000011F2 64E3                   MOV         R14,R4
    000011F4 2008                   TST         R0,R0
    000011F6 8933                   BT          L424
               mnet.c       1814      {
               mnet.c       1815          return FALSE;
               mnet.c       1816      }
               mnet.c       1817      
               mnet.c       1818      if( MNET_DRV_TYPE[pm] == PCD4611 )
    000011F8 D63F                   MOV.L       L625+6,R6  ; _MNET_DRV_TYPE
    000011FA 60DC                   EXTU.B      R13,R0
    000011FC 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    000011FE 8809                   CMP/EQ      #9,R0
    00001200 8B17                   BF          L426
               mnet.c       1819      {
               mnet.c       1820          WriteMemoryPCD4611(RRG_RSTS);
    00001202 BE68                   BSR         __$WriteMemoryPCD4611
    00001204 E4F1                   MOV         #-15,R4    ; H'FFFFFFF1
               mnet.c       1821          pcd_rsts = ReadMemoryPCD4611();
    00001206 BE8C                   BSR         __$ReadMemoryPCD4611
    00001208 0009                   NOP
    0000120A D53D                   MOV.L       L625+14,R5 ; __$pcd_rsts
    0000120C 6603                   MOV         R0,R6
    0000120E 2502                   MOV.L       R0,@R5     ; pcd_rsts
               mnet.c       1822          
               mnet.c       1823          if(
    00001210 C90A                   AND         #10,R0
    00001212 880A                   CMP/EQ      #10,R0
    00001214 8922                   BT          L428
    00001216 6063                   MOV         R6,R0
    00001218 C90B                   AND         #11,R0
    0000121A 880B                   CMP/EQ      #11,R0
    0000121C 891E                   BT          L428
    0000121E 6063                   MOV         R6,R0
    00001220 C90C                   AND         #12,R0
    00001222 880C                   CMP/EQ      #12,R0
    00001224 891A                   BT          L428
    00001226 6063                   MOV         R6,R0
    00001228 C90D                   AND         #13,R0
    0000122A 880D                   CMP/EQ      #13,R0
    0000122C 8916                   BT          L428
    0000122E A017                   BRA         L424
    00001230 0009                   NOP
    00001232              L426:
               mnet.c       1824              ( (pcd_rsts & 0x0000000A) == 0x0000000A )||
               mnet.c       1825              ( (pcd_rsts & 0x0000000B) == 0x0000000B )||
               mnet.c       1826              ( (pcd_rsts & 0x0000000C) == 0x0000000C )||
               mnet.c       1827              ( (pcd_rsts & 0x0000000D) == 0x0000000D )
               mnet.c       1828          )
               mnet.c       1829          {
               mnet.c       1830              return TRUE;
               mnet.c       1831          }
               mnet.c       1832          else
               mnet.c       1833          {
               mnet.c       1834              return FALSE;
               mnet.c       1835          }
               mnet.c       1836      }
               mnet.c       1837      else
               mnet.c       1838      {
               mnet.c       1839          for( Loop = 0; Loop <= 3; Loop++ )
    00001232 ED00                   MOV         #0,R13     ; H'00000000
    00001234 EC03                   MOV         #3,R12     ; H'00000003
    00001236 6BD3                   MOV         R13,R11
    00001238              L431:
               mnet.c       1840          {
               mnet.c       1841              GetMotorStatus(pm, (MotorStatus* )&mstatus);
    00001238 64E3                   MOV         R14,R4
    0000123A BF5D                   BSR         _GetMotorStatus
    0000123C 65F3                   MOV         R15,R5
               mnet.c       1842    
               mnet.c       1843              if ( wk != mstatus.UNID.BIT.SBSY )
    0000123E 66F0                   MOV.B       @R15,R6    ; (part of)mstatus
    00001240 8768                   BLD         #0,R6
    00001242 0229                   MOVT        R2
    00001244 3B20                   CMP/EQ      R2,R11
    00001246 8903                   BT          L433
               mnet.c       1844              {
               mnet.c       1845                  wk = mstatus.UNID.BIT.SBSY;
    00001248 8768                   BLD         #0,R6
    0000124A 0B29                   MOVT        R11
               mnet.c       1846                  Loop = 0;
    0000124C ED00                   MOV         #0,R13     ; H'00000000
    0000124E 6AB3                   MOV         R11,R10
    00001250              L433:
    00001250 7D01                   ADD         #1,R13
    00001252 3DC7                   CMP/GT      R12,R13
    00001254 8BF0                   BF          L431
               mnet.c       1847              }
               mnet.c       1848          }
               mnet.c       1849          
               mnet.c       1850          if( wk == 0)
    00001256 6AAD                   EXTU.W      R10,R10
    00001258 2AA8                   TST         R10,R10
    0000125A 8901                   BT          L424
    0000125C              L428:
    0000125C A001                   BRA         L436
    0000125E E001                   MOV         #1,R0      ; H'00000001
    00001260              L424:
    00001260 E000                   MOV         #0,R0      ; H'00000000
    00001262              L436:
    00001262 7F04                   ADD         #4,R15
    00001264 4AF4                   MOVMU.L     @R15+,R10
               mnet.c       1851          {
               mnet.c       1852              return FALSE;
               mnet.c       1853          }
               mnet.c       1854      }
               mnet.c       1855      return TRUE;
               mnet.c       1856    }
    00001266 006B                   RTS/N
               mnet.c       1857    
               mnet.c       1858    /******************************************************************************
               mnet.c       1859    * 
               mnet.c       1860    * [概要]  パルスモータが指定方向のリミット位置の場合TRUEを返す関数
               mnet.c       1861    * [引数]  モーター番号、方向
               mnet.c       1862    * [戻値]  TRUE:リミット、FALSE:リミット以外
               mnet.c       1863    * 
               mnet.c       1864    ******************************************************************************/
               mnet.c       1865    BOOL motor_IsLimit(UB pm, UH dir)
    00001268              _motor_IsLimit:                  ; function: motor_IsLimit
                                                           ; frame size=16
    00001268 4DF0                   MOVMU.L     R13,@-R15
    0000126A 7FFC                   ADD         #-4,R15
               mnet.c       1866    {
               mnet.c       1867      BOOL result = FALSE;
               mnet.c       1868      RSTS rsts;
               mnet.c       1869      INT  rest= 0;
               mnet.c       1870    
               mnet.c       1871      if( MNET_DRV_TYPE[pm] == PCD4611 )
    0000126C D622                   MOV.L       L625+6,R6  ; _MNET_DRV_TYPE
    0000126E 644C                   EXTU.B      R4,R4
    00001270 ED00                   MOV         #0,R13     ; H'00000000
    00001272 6043                   MOV         R4,R0
    00001274 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00001276 8809                   CMP/EQ      #9,R0
    00001278 8F12                   BF/S        L439
    0000127A 6E53                   MOV         R5,R14
               mnet.c       1872      {
               mnet.c       1873          WriteMemoryPCD4611(RRG_REST);
    0000127C BE2B                   BSR         __$WriteMemoryPCD4611
    0000127E E4F2                   MOV         #-14,R4    ; H'FFFFFFF2
               mnet.c       1874          rest = ReadMemoryPCD4611();
    00001280 BE4F                   BSR         __$ReadMemoryPCD4611
    00001282 0009                   NOP
               mnet.c       1875          
               mnet.c       1876          if( dir == CW )
    00001284 62ED                   EXTU.W      R14,R2
    00001286 6603                   MOV         R0,R6
    00001288 6023                   MOV         R2,R0
    0000128A 8801                   CMP/EQ      #1,R0
    0000128C 8B01                   BF          L441
               mnet.c       1877          {
               mnet.c       1878              if((rest & 0x00000001))     return( TRUE );
    0000128E 8768                   BLD         #0,R6
    00001290 8904                   BT          L442
    00001292              L441:
               mnet.c       1879          }
               mnet.c       1880          if( dir == CCW )
    00001292 6023                   MOV         R2,R0
    00001294 8802                   CMP/EQ      #2,R0
    00001296 8B1A                   BF          L444
               mnet.c       1881          {
               mnet.c       1882              if((rest & 0x00000002))     return( TRUE );
    00001298 8769                   BLD         #1,R6
    0000129A 8B18                   BF          L444
    0000129C              L442:
    0000129C A018                   BRA         L445
    0000129E 0029                   MOVT        R0
    000012A0              L439:
    000012A0 E5F1                   MOV         #-15,R5    ; H'FFFFFFF1
               mnet.c       1883          }
               mnet.c       1884      }
               mnet.c       1885      else
               mnet.c       1886      {
               mnet.c       1887          if (!GetMotorRegister(pm, RRG_RSTS, &rsts.UNID.data))
    000012A2 66F3                   MOV         R15,R6
    000012A4 BEC0                   BSR         _GetMotorRegister
    000012A6 655C                   EXTU.B      R5,R5
    000012A8 2008                   TST         R0,R0
    000012AA 8B01                   BF          L447
               mnet.c       1888          {
               mnet.c       1889              return( result );
    000012AC A010                   BRA         L445
    000012AE 0039                   MOVRT       R0
    000012B0              L447:
               mnet.c       1890          }
               mnet.c       1891    
               mnet.c       1892          if( dir == CW )
    000012B0 62ED                   EXTU.W      R14,R2
    000012B2 6023                   MOV         R2,R0
    000012B4 8801                   CMP/EQ      #1,R0
    000012B6 8B03                   BF          L449
               mnet.c       1893          {
               mnet.c       1894              if( rsts.UNID.BIT.SPEL )
    000012B8 3F693003               BLD.B       #6,@(3,R15); (part of)rsts
    000012BC 8B00                   BF          L449
               mnet.c       1895              {
               mnet.c       1896                  result = TRUE;
    000012BE ED01                   MOV         #1,R13     ; H'00000001
    000012C0              L449:
               mnet.c       1897              }
               mnet.c       1898          }
               mnet.c       1899          if( dir == CCW )
    000012C0 6023                   MOV         R2,R0
    000012C2 8802                   CMP/EQ      #2,R0
    000012C4 8B03                   BF          L444
               mnet.c       1900          {
               mnet.c       1901              if( rsts.UNID.BIT.SMEL )
    000012C6 3F793003               BLD.B       #7,@(3,R15); (part of)rsts
    000012CA 8B00                   BF          L444
               mnet.c       1902              {
               mnet.c       1903                  result = TRUE;
    000012CC ED01                   MOV         #1,R13     ; H'00000001
    000012CE              L444:
               mnet.c       1904              }
               mnet.c       1905          }
               mnet.c       1906      }
               mnet.c       1907      return( result );
    000012CE 60D3                   MOV         R13,R0
    000012D0              L445:
    000012D0 7F04                   ADD         #4,R15
    000012D2 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       1908    }
    000012D4 006B                   RTS/N
               mnet.c       1909    /******************************************************************************
               mnet.c       1910    * 
               mnet.c       1911    * [概要]  指定パルスモータがリミット位置の場合TRUEを返す関数
               mnet.c       1912    * [引数]  モーター番号
               mnet.c       1913    * [戻値]  TRUE:リミット、FALSE:リミット以外
               mnet.c       1914    * 
               mnet.c       1915    ******************************************************************************/
               mnet.c       1916    BOOL motor_IsLimitW(UB pm)
    000012D6              _motor_IsLimitW:                 ; function: motor_IsLimitW
                                                           ; frame size=8
    000012D6 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       1917    {
               mnet.c       1918      if( motor_IsLimit(pm,CW) == TRUE )  return( TRUE );
    000012D8 644C                   EXTU.B      R4,R4
    000012DA E501                   MOV         #1,R5      ; H'00000001
    000012DC BFC4                   BSR         _motor_IsLimit
    000012DE 6E43                   MOV         R4,R14
    000012E0 8801                   CMP/EQ      #1,R0
    000012E2 8903                   BT          L455
               mnet.c       1919      if( motor_IsLimit(pm,CCW) == TRUE ) return( TRUE );
    000012E4 E502                   MOV         #2,R5      ; H'00000002
    000012E6 BFBF                   BSR         _motor_IsLimit
    000012E8 64E3                   MOV         R14,R4
    000012EA 8801                   CMP/EQ      #1,R0
    000012EC              L455:
               mnet.c       1920    
               mnet.c       1921      return( FALSE );
    000012EC 0029                   MOVT        R0
    000012EE 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       1922    }
    000012F0 006B                   RTS/N
    000012F2              L625:
    000012F2 00000002               .RES.W      1
    000012F4 <00000000>             .DATA.L     _pMotionnet
    000012F8 <00000000>             .DATA.L     _MNET_DRV_TYPE
    000012FC <00000000>             .DATA.L     _MNET_NO
    00001300 <00000000>             .DATA.L     __$pcd_rsts
               mnet.c       1923    /******************************************************************************
               mnet.c       1924    * 
               mnet.c       1925    * [概要]  エンコーダ有無を取得
               mnet.c       1926    * [引数]  モーター番号
               mnet.c       1927    * [戻値]  TRUE:有、FALSE:無
               mnet.c       1928    * 
               mnet.c       1929    ******************************************************************************/
               mnet.c       1930    BOOL IsEncoderExist(UB pm)
    00001304              _IsEncoderExist:                 ; function: IsEncoderExist
                                                           ; frame size=0
               mnet.c       1931    {
               mnet.c       1932      BOOL    result = FALSE;
               mnet.c       1933      UB      index;
               mnet.c       1934      UB      bitsfh = 0x00;
               mnet.c       1935      UB      bitdat = 0x01;
               mnet.c       1936      UB      pmwk;
               mnet.c       1937    
               mnet.c       1938      // モータ範囲外
               mnet.c       1939      if( pm > DVMAX )    return( result );
    00001304 664C                   EXTU.B      R4,R6
    00001306 E107                   MOV         #7,R1      ; H'00000007
    00001308 3617                   CMP/GT      R1,R6
    0000130A 6243                   MOV         R4,R2
    0000130C 8D14                   BT/S        L458
    0000130E E500                   MOV         #0,R5      ; H'00000000
               mnet.c       1940      
               mnet.c       1941      // bit0    チャネル1
               mnet.c       1942      // bit1    チャネル2
               mnet.c       1943      // ・
               mnet.c       1944      // bit63   チャネル64
               mnet.c       1945      if( pm == 0 )       return( result );
    00001310 2668                   TST         R6,R6
    00001312 8911                   BT          L458
               mnet.c       1946      pmwk = pm - 1;
               mnet.c       1947    
               mnet.c       1948      index  = ( pmwk / 8 );
               mnet.c       1949      bitsfh = ( pmwk % 8 );
               mnet.c       1950      bitdat = (bitdat << bitsfh);
               mnet.c       1951      
               mnet.c       1952      // エンコーダ付き
               mnet.c       1953      if( (ENCODER_EXIST[index] & bitdat) )
    00001314 72FF                   ADD         #-1,R2
    00001316 E7FD                   MOV         #-3,R7     ; H'FFFFFFFD
    00001318 642C                   EXTU.B      R2,R4
    0000131A E601                   MOV         #1,R6      ; H'00000001
    0000131C 6143                   MOV         R4,R1
    0000131E 417C                   SHAD        R7,R1
    00001320 D260                   MOV.L       L626+2,R2  ; _ENCODER_EXIST
    00001322 601C                   EXTU.B      R1,R0
    00001324 012C                   MOV.B       @(R0,R2),R1; ENCODER_EXIST[]
    00001326 6043                   MOV         R4,R0
    00001328 C907                   AND         #7,R0
    0000132A 460C                   SHAD        R0,R6
    0000132C 646C                   EXTU.B      R6,R4
    0000132E 2148                   TST         R4,R1
    00001330 8900                   BT          L461
               mnet.c       1954      {
               mnet.c       1955          result = TRUE;
    00001332 E501                   MOV         #1,R5      ; H'00000001
    00001334              L461:
    00001334 000B                   RTS
    00001336 6053                   MOV         R5,R0
    00001338              L458:
    00001338 000B                   RTS
    0000133A E000                   MOV         #0,R0      ; H'00000000
               mnet.c       1956      }
               mnet.c       1957      
               mnet.c       1958      return( result );
               mnet.c       1959    }
               mnet.c       1960    /******************************************************************************
               mnet.c       1961    * 
               mnet.c       1962    * [概要]  パルスモータを励磁
               mnet.c       1963    * [引数]  モーター番号、励磁動作指示
               mnet.c       1964    * [戻値]  TRUE:成功、FALSE:失敗
               mnet.c       1965    * 
               mnet.c       1966    ******************************************************************************/
               mnet.c       1967    BOOL motor_PowerUp(UB pm, UB sw)
    0000133C              _motor_PowerUp:                  ; function: motor_PowerUp
                                                           ; frame size=32
    0000133C 48F0                   MOVMU.L     R8,@-R15
               mnet.c       1968    {
               mnet.c       1969      INT cnt;
               mnet.c       1970      INT rcnt;
               mnet.c       1971      UB DataCmp;
               mnet.c       1972      UB DataSet;
               mnet.c       1973      UB mnet_drv_typ;
               mnet.c       1974    
               mnet.c       1975      mnet_drv_typ = MNET_DRV_TYPE[pm];
    0000133E 664C                   EXTU.B      R4,R6
    00001340 D159                   MOV.L       L626+6,R1  ; _MNET_DRV_TYPE
    00001342 6063                   MOV         R6,R0
    00001344 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    00001346 6E5C                   EXTU.B      R5,R14
               mnet.c       1976    
               mnet.c       1977      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00001348 880A                   CMP/EQ      #10,R0
    0000134A 8D58                   BT/S        L469
    0000134C 6C0C                   EXTU.B      R0,R12
               mnet.c       1978      {
               mnet.c       1979          return( TRUE );
               mnet.c       1980      }
               mnet.c       1981    
               mnet.c       1982      if(
    0000134E 60C3                   MOV         R12,R0
    00001350 8801                   CMP/EQ      #1,R0
    00001352 8901                   BT          L471
    00001354 2CC8                   TST         R12,R12
    00001356 8B50                   BF          L472
    00001358              L471:
    00001358 D554                   MOV.L       L626+10,R5 ; _pMotionnet
    0000135A 6452                   MOV.L       @R5,R4     ; pMotionnet
               mnet.c       1983          ( mnet_drv_typ != BCD4020FUA )&&
               mnet.c       1984          ( mnet_drv_typ != BCD4020FU )
               mnet.c       1985      )
               mnet.c       1986      {
               mnet.c       1987          return FALSE;
               mnet.c       1988      }
               mnet.c       1989      
               mnet.c       1990      MAC_READ( pMotionnet->portData[pm][2], DataSet );
    0000135C 4608                   SHLL2       R6
    0000135E 02000102               MOVI20      #258,R2    ; H'00000102
    00001362 6743                   MOV         R4,R7
    00001364 372C                   ADD         R2,R7
    00001366 6A63                   MOV         R6,R10
    00001368 E500                   MOV         #0,R5      ; H'00000000
    0000136A 6063                   MOV         R6,R0
    0000136C 027C                   MOV.B       @(R0,R7),R2; pMotionnet->portData[]
    0000136E 6063                   MOV         R6,R0
    00001370 ED05                   MOV         #5,R13     ; H'00000005
    00001372 612C                   EXTU.B      R2,R1
    00001374 6B13                   MOV         R1,R11
    00001376              L473:
    00001376 027C                   MOV.B       @(R0,R7),R2; pMotionnet->portData[]
    00001378 662C                   EXTU.B      R2,R6
    0000137A 3610                   CMP/EQ      R1,R6
    0000137C 8902                   BT          L475
    0000137E E500                   MOV         #0,R5      ; H'00000000
    00001380 6B63                   MOV         R6,R11
    00001382 6163                   MOV         R6,R1
    00001384              L475:
    00001384 7501                   ADD         #1,R5
    00001386 35D3                   CMP/GE      R13,R5
    00001388 8BF5                   BF          L473
               mnet.c       1991    
               mnet.c       1992      switch( mnet_drv_typ )
    0000138A 60C3                   MOV         R12,R0
    0000138C 8801                   CMP/EQ      #1,R0
    0000138E 8903                   BT          L479
    00001390 2CC8                   TST         R12,R12
    00001392 8904                   BT          L480
    00001394 A006                   BRA         L481
    00001396 0009                   NOP
    00001398              L479:
               mnet.c       1993      {
               mnet.c       1994      case BCD4020FUA:
               mnet.c       1995          if (sw)
    00001398 2EE8                   TST         R14,R14
    0000139A A003                   BRA         L481
    0000139C 87B0                   BST         #0,R11
    0000139E              L480:
               mnet.c       1996          {
               mnet.c       1997              DataSet &= (~0x01); // 励磁ON
               mnet.c       1998          }
               mnet.c       1999          else
               mnet.c       2000          {
               mnet.c       2001              DataSet |= 0x01;    // 励磁OFF
               mnet.c       2002          }
               mnet.c       2003          break;
               mnet.c       2004      case BCD4020FU:
               mnet.c       2005          if (sw)
    0000139E 2EE8                   TST         R14,R14
    000013A0 0068                   NOTT
    000013A2 87B6                   BST         #6,R11
    000013A4              L481:
    000013A4 34AC                   ADD         R10,R4
               mnet.c       2006          {
               mnet.c       2007              DataSet |= 0x40;    // 励磁ON
               mnet.c       2008          }
               mnet.c       2009          else
               mnet.c       2010          {
               mnet.c       2011              DataSet &= (~0x40); // 励磁OFF
               mnet.c       2012          }
               mnet.c       2013          break;
               mnet.c       2014      }
               mnet.c       2015    
               mnet.c       2016    //x       g_Sleep(20);
               mnet.c       2017    //x       g_Sleep(40);
               mnet.c       2018    //o       g_Sleep(50);
               mnet.c       2019    //o       g_Sleep(60);
               mnet.c       2020    //o       g_Sleep(500);
               mnet.c       2021    //o       g_Sleep(250);
               mnet.c       2022    //o       g_Sleep(120);
               mnet.c       2023      for( cnt = 0; cnt < READ_RTY_MAX; cnt++ )
    000013A6 69BC                   EXTU.B      R11,R9
    000013A8 6743                   MOV         R4,R7
    000013AA E803                   MOV         #3,R8      ; H'00000003
    000013AC 0C000103               MOVI20      #259,R12   ; H'00000103
    000013B0              L482:
               mnet.c       2024      {
               mnet.c       2025          MAC_WRIT( pMotionnet->portData[pm][3], DataSet  );
    000013B0 37B10103               MOV.B       R11,@(259:12,R7); pMotionnet->portData[]
    000013B4 E605                   MOV         #5,R6      ; H'00000005
    000013B6 60A3                   MOV         R10,R0
    000013B8 D23C                   MOV.L       L626+10,R2 ; _pMotionnet
    000013BA              L484:
    000013BA 6422                   MOV.L       @R2,R4     ; pMotionnet
    000013BC 4610                   DT          R6
    000013BE 34CC                   ADD         R12,R4
    000013C0 8FFB                   BF/S        L484
    000013C2 04B4                   MOV.B       R11,@(R0,R4); pMotionnet->portData[]
               mnet.c       2026    
               mnet.c       2027          for( rcnt = 0; rcnt < READ_RTY_MAX; rcnt++ )
    000013C4 EE03                   MOV         #3,R14     ; H'00000003
    000013C6              L486:
               mnet.c       2028          {
               mnet.c       2029              g_Sleep(WAITTIM);
    000013C6 B24B                   BSR         _g_Sleep
    000013C8 E43C                   MOV         #60,R4     ; H'0000003C
               mnet.c       2030              MAC_READ( pMotionnet->portData[pm][2], DataCmp );
    000013CA D238                   MOV.L       L626+10,R2 ; _pMotionnet
    000013CC 6722                   MOV.L       @R2,R7     ; pMotionnet
    000013CE E500                   MOV         #0,R5      ; H'00000000
    000013D0 37AC                   ADD         R10,R7
    000013D2 31714102               MOV.B       @(258:12,R7),R1; pMotionnet->portData[]
    000013D6 641C                   EXTU.B      R1,R4
    000013D8              L488:
    000013D8 32718102               MOVU.B      @(258,R7),R2; pMotionnet->portData[]
    000013DC 3240                   CMP/EQ      R4,R2
    000013DE 8902                   BT          L490
    000013E0 E500                   MOV         #0,R5      ; H'00000000
    000013E2 6123                   MOV         R2,R1
    000013E4 6423                   MOV         R2,R4
    000013E6              L490:
    000013E6 7501                   ADD         #1,R5
    000013E8 35D3                   CMP/GE      R13,R5
    000013EA 8BF5                   BF          L488
               mnet.c       2031              if( DataSet == DataCmp )
    000013EC 621C                   EXTU.B      R1,R2
    000013EE 3920                   CMP/EQ      R2,R9
    000013F0 8905                   BT          L469
    000013F2 4E10                   DT          R14
    000013F4 8BE7                   BF          L486
    000013F6 4810                   DT          R8
    000013F8 8BDA                   BF          L482
    000013FA              L472:
    000013FA A001                   BRA         L495
    000013FC E000                   MOV         #0,R0      ; H'00000000
    000013FE              L469:
    000013FE E001                   MOV         #1,R0      ; H'00000001
    00001400              L495:
    00001400 48F4                   MOVMU.L     @R15+,R8
               mnet.c       2032              {
               mnet.c       2033                  return TRUE;
               mnet.c       2034              }
               mnet.c       2035              else
               mnet.c       2036              {
               mnet.c       2037              }
               mnet.c       2038          }
               mnet.c       2039      }
               mnet.c       2040      
               mnet.c       2041      
               mnet.c       2042      return FALSE;
               mnet.c       2043    }
    00001402 006B                   RTS/N
               mnet.c       2044    ///<summary>
               mnet.c       2045    /// 全てのレジスタに値を書き込む関数
               mnet.c       2046    ///</summary>
               mnet.c       2047    ER motor_SetAllRegister(UB pm)
    00001404              __$motor_SetAllRegister:         ; function: __$motor_SetAllRegister
                                                           ; frame size=48
    00001404 4DF0                   MOVMU.L     R13,@-R15
    00001406 7FDC                   ADD         #-36,R15
               mnet.c       2048    {
               mnet.c       2049      RMD     rmd;
               mnet.c       2050    
               mnet.c       2051      if( MNET_DRV_TYPE[pm] == NCPRSUNIT )// 圧力ユニット
    00001408 6D4C                   EXTU.B      R4,R13
    0000140A D227                   MOV.L       L626+6,R2  ; _MNET_DRV_TYPE
    0000140C 60D3                   MOV         R13,R0
    0000140E 002C                   MOV.B       @(R0,R2),R0; MNET_DRV_TYPE[]
    00001410 880A                   CMP/EQ      #10,R0
    00001412 8B01                   BF          L637
    00001414 A0CB                   BRA         L498
    00001416 0009                   NOP
    00001418              L637:
               mnet.c       2052      {
               mnet.c       2053          return( E_SUCCESS );
               mnet.c       2054      }
               mnet.c       2055    
               mnet.c       2056      // デバイス:PCD4611
               mnet.c       2057      if( MNET_DRV_TYPE[pm] == PCD4611 )
    00001418 8809                   CMP/EQ      #9,R0
    0000141A 8B4F                   BF          L500
               mnet.c       2058      {
               mnet.c       2059          pPulseMotor = (struct StPulseMotor *)PULSEMOTOR_ADDR;
               mnet.c       2060    
               mnet.c       2061    //        WriteMemoryPCD4611( CMD_CUN1R );        // CUN1R : 
               mnet.c       2062    //        if( !SetMotorRegisterInt(pm, WRG_RFA, 1                  ) )    return(( E_MNT_ACCESS + WRG_RFA ));// 9Bh
               mnet.c       2063          SetMotorRegisterInt( pm, WRG_PRFL, _pmInfo[pm].reg[R1] );   // RFL
    0000141C E064                   MOV         #100,R0    ; H'00000064
    0000141E 6ED3                   MOV         R13,R14
    00001420 4E80                   MULR        R0,R14
    00001422 D223                   MOV.L       L626+14,R2 ; H'0C009000
    00001424 E581                   MOV         #-127,R5   ; H'FFFFFF81
    00001426 D123                   MOV.L       L626+18,R1 ; _pPulseMotor
    00001428 2122                   MOV.L       R2,@R1     ; pPulseMotor
    0000142A 655C                   EXTU.B      R5,R5
    0000142C D222                   MOV.L       L626+22,R2 ; __$_pmInfo
    0000142E 3E2C                   ADD         R2,R14
    00001430 6053                   MOV         R5,R0
    00001432 56EA                   MOV.L       @(40,R14),R6; _pmInfo[].reg[]
    00001434 64D3                   MOV         R13,R4
    00001436 BDB2                   BSR         _SetMotorRegisterInt
    00001438 81F2                   MOV.W       R0,@(4,R15)
    0000143A 85F2                   MOV.W       @(4,R15),R0
    0000143C 64D3                   MOV         R13,R4
               mnet.c       2064          SetMotorRegisterInt( pm, WRG_PRFH, _pmInfo[pm].reg[R2] );   // RFH
    0000143E 56EB                   MOV.L       @(44,R14),R6; _pmInfo[].reg[]
    00001440 7001                   ADD         #1,R0
    00001442 81F4                   MOV.W       R0,@(8,R15)
    00001444 BDAB                   BSR         _SetMotorRegisterInt
    00001446 6503                   MOV         R0,R5
    00001448 85F4                   MOV.W       @(8,R15),R0
    0000144A 64D3                   MOV         R13,R4
               mnet.c       2065          SetMotorRegisterInt( pm, WRG_PRUR, _pmInfo[pm].reg[R3] );   // RUR
    0000144C 56EC                   MOV.L       @(48,R14),R6; _pmInfo[].reg[]
    0000144E 7001                   ADD         #1,R0
    00001450 81F6                   MOV.W       R0,@(12,R15)
    00001452 BDA4                   BSR         _SetMotorRegisterInt
    00001454 6503                   MOV         R0,R5
               mnet.c       2066          SetMotorRegisterInt( pm, WRG_PRDR, 0                   );   // RDR
    00001456 85F6                   MOV.W       @(12,R15),R0
    00001458 E600                   MOV         #0,R6      ; H'00000000
    0000145A 64D3                   MOV         R13,R4
    0000145C 7001                   ADD         #1,R0
    0000145E 81F8                   MOV.W       R0,@(16,R15)
    00001460 BD9D                   BSR         _SetMotorRegisterInt
    00001462 6503                   MOV         R0,R5
    00001464 85F8                   MOV.W       @(16,R15),R0
    00001466 64D3                   MOV         R13,R4
               mnet.c       2067          SetMotorRegisterInt( pm, WRG_PRMG, _pmInfo[pm].reg[R4] );   // RMG
    00001468 56ED                   MOV.L       @(52,R14),R6; _pmInfo[].reg[]
    0000146A 7001                   ADD         #1,R0
    0000146C 81FA                   MOV.W       R0,@(20,R15)
    0000146E BD96                   BSR         _SetMotorRegisterInt
    00001470 6503                   MOV         R0,R5
               mnet.c       2068          SetMotorRegisterInt( pm, WRG_PRDP, 0                   );   // RDP
    00001472 85FA                   MOV.W       @(20,R15),R0
    00001474 E600                   MOV         #0,R6      ; H'00000000
    00001476 64D3                   MOV         R13,R4
    00001478 7001                   ADD         #1,R0
    0000147A 81FC                   MOV.W       R0,@(24,R15)
    0000147C BD8F                   BSR         _SetMotorRegisterInt
    0000147E 6503                   MOV         R0,R5
    00001480 85FC                   MOV.W       @(24,R15),R0
    00001482 64D3                   MOV         R13,R4
               mnet.c       2069          SetMotorRegisterInt( pm, WRG_PRDS, _pmInfo[pm].reg[R9] );   // RDS
    00001484 36E16012               MOV.L       @(72:12,R14),R6; _pmInfo[].reg[]
    00001488 7004                   ADD         #4,R0
    0000148A 81FE                   MOV.W       R0,@(28,R15)
    0000148C BD87                   BSR         _SetMotorRegisterInt
    0000148E 6503                   MOV         R0,R5
               mnet.c       2070          SetMotorRegisterInt( pm, WRG_PRMG, 1199                );   // RMG
    00001490 85FE                   MOV.W       @(28,R15),R0
    00001492 64D3                   MOV         R13,R4
    00001494 060004AF               MOVI20      #1199,R6   ; H'000004AF
    00001498 70FB                   ADD         #-5,R0
    0000149A BD80                   BSR         _SetMotorRegisterInt
    0000149C 6503                   MOV         R0,R5
    0000149E A086                   BRA         L498
    000014A0 0009                   NOP
    000014A2              L626:
    000014A2 00000002               .RES.W      1
    000014A4 <00000000>             .DATA.L     _ENCODER_EXIST
    000014A8 <00000000>             .DATA.L     _MNET_DRV_TYPE
    000014AC <00000000>             .DATA.L     _pMotionnet
    000014B0 0C009000               .DATA.L     H'0C009000
    000014B4 <00000000>             .DATA.L     _pPulseMotor
    000014B8 <00000000>             .DATA.L     __$_pmInfo
    000014BC              L500:
    000014BC E5D7                   MOV         #-41,R5    ; H'FFFFFFD7
               mnet.c       2071    
               mnet.c       2072      }
               mnet.c       2073      // デバイス:FU,FU-A
               mnet.c       2074      else
               mnet.c       2075      {
               mnet.c       2076          if( !GetMotorRegister(pm, RRG_RMD, &rmd.UNID.data))             return(( E_MNT_ACCESS + RRG_RMD ));
    000014BE 66F3                   MOV         R15,R6
    000014C0 655C                   EXTU.B      R5,R5
    000014C2 BDB1                   BSR         _GetMotorRegister
    000014C4 64D3                   MOV         R13,R4
    000014C6 2008                   TST         R0,R0
    000014C8 000005D7               MOVI20      #1495,R0   ; H'000005D7
    000014CC 8970                   BT          L502
               mnet.c       2077    
               mnet.c       2078          rmd.UNID.BIT.MSMD = (_pmInfo[pm].param.accel_type == ACCEL_STYPE ? 1 : 0);
    000014CE E064                   MOV         #100,R0    ; H'00000064
    000014D0 6ED3                   MOV         R13,R14
    000014D2 4E80                   MULR        R0,R14
    000014D4 D494                   MOV.L       L627+2,R4  ; __$_pmInfo
               mnet.c       2079          rmd.UNID.BIT.MINT = 1;
    000014D6 3F391001               BSET.B      #3,@(1,R15); (part of)rmd
    000014DA 3E4C                   ADD         R4,R14
    000014DC 85E4                   MOV.W       @(8,R14),R0; _pmInfo[].accel_type
               mnet.c       2080          if( !SetMotorRegisterInt(pm, WRG_RMD, rmd.UNID.data) )          return(( E_MNT_ACCESS + WRG_RMD ));// 97h
    000014DE E597                   MOV         #-105,R5   ; H'FFFFFF97
    000014E0 655C                   EXTU.B      R5,R5
    000014E2 1FE8                   MOV.L       R14,@(32,R15)
    000014E4 8801                   CMP/EQ      #1,R0
    000014E6 64D3                   MOV         R13,R4
    000014E8 3F292002               BST.B       #2,@(2,R15); (part of)rmd
    000014EC BD57                   BSR         _SetMotorRegisterInt
    000014EE 66F2                   MOV.L       @R15,R6    ; rmd.UNID.data
    000014F0 2008                   TST         R0,R0
    000014F2 00000597               MOVI20      #1431,R0   ; H'00000597
    000014F6 895B                   BT          L502
               mnet.c       2081          if( !SetMotorRegisterInt(pm, WRG_RFL, _pmInfo[pm].reg[R1]) )    return(( E_MNT_ACCESS + WRG_RFL ));// 91h
    000014F8 51F8                   MOV.L       @(32,R15),R1
    000014FA E591                   MOV         #-111,R5   ; H'FFFFFF91
    000014FC 655C                   EXTU.B      R5,R5
    000014FE 561A                   MOV.L       @(40,R1),R6; _pmInfo[].reg[]
    00001500 BD4D                   BSR         _SetMotorRegisterInt
    00001502 64D3                   MOV         R13,R4
    00001504 2008                   TST         R0,R0
    00001506 00000591               MOVI20      #1425,R0   ; H'00000591
    0000150A 8951                   BT          L502
               mnet.c       2082          if( !SetMotorRegisterInt(pm, WRG_RFH, _pmInfo[pm].reg[R2]) )    return(( E_MNT_ACCESS + WRG_RFH ));// 92h
    0000150C 51F8                   MOV.L       @(32,R15),R1
    0000150E E592                   MOV         #-110,R5   ; H'FFFFFF92
    00001510 655C                   EXTU.B      R5,R5
    00001512 561B                   MOV.L       @(44,R1),R6; _pmInfo[].reg[]
    00001514 BD43                   BSR         _SetMotorRegisterInt
    00001516 64D3                   MOV         R13,R4
    00001518 2008                   TST         R0,R0
    0000151A 00000592               MOVI20      #1426,R0   ; H'00000592
    0000151E 8947                   BT          L502
               mnet.c       2083          if( !SetMotorRegister(pm,   WRG_RUR, _pmInfo[pm].reg[R3]) )     return(( E_MNT_ACCESS + WRG_RUR ));// 93h
    00001520 51F8                   MOV.L       @(32,R15),R1
    00001522 E593                   MOV         #-109,R5   ; H'FFFFFF93
    00001524 655C                   EXTU.B      R5,R5
    00001526 561C                   MOV.L       @(48,R1),R6; _pmInfo[].reg[]
    00001528 BD56                   BSR         __$SetMotorRegister
    0000152A 64D3                   MOV         R13,R4
    0000152C 2008                   TST         R0,R0
    0000152E 00000593               MOVI20      #1427,R0   ; H'00000593
    00001532 893D                   BT          L502
               mnet.c       2084          if( !SetMotorRegister(pm,   WRG_RDR, 0) )                       return(( E_MNT_ACCESS + WRG_RDR ));// 94h
    00001534 E594                   MOV         #-108,R5   ; H'FFFFFF94
    00001536 E600                   MOV         #0,R6      ; H'00000000
    00001538 655C                   EXTU.B      R5,R5
    0000153A BD4D                   BSR         __$SetMotorRegister
    0000153C 64D3                   MOV         R13,R4
    0000153E 2008                   TST         R0,R0
    00001540 00000594               MOVI20      #1428,R0   ; H'00000594
    00001544 8934                   BT          L502
               mnet.c       2085          if( !SetMotorRegisterInt(pm, WRG_RMG, _pmInfo[pm].reg[R4]) )    return(( E_MNT_ACCESS + WRG_RMG ));// 95h
    00001546 51F8                   MOV.L       @(32,R15),R1
    00001548 E595                   MOV         #-107,R5   ; H'FFFFFF95
    0000154A 655C                   EXTU.B      R5,R5
    0000154C 561D                   MOV.L       @(52,R1),R6; _pmInfo[].reg[]
    0000154E BD26                   BSR         _SetMotorRegisterInt
    00001550 64D3                   MOV         R13,R4
    00001552 2008                   TST         R0,R0
    00001554 00000595               MOVI20      #1429,R0   ; H'00000595
    00001558 892A                   BT          L502
    0000155A E596                   MOV         #-106,R5   ; H'FFFFFF96
               mnet.c       2086          if( !SetMotorRegisterInt(pm, WRG_RDP, 0) )                      return(( E_MNT_ACCESS + WRG_RDP ));// 96h
    0000155C E600                   MOV         #0,R6      ; H'00000000
    0000155E 655C                   EXTU.B      R5,R5
    00001560 BD1D                   BSR         _SetMotorRegisterInt
    00001562 64D3                   MOV         R13,R4
    00001564 2008                   TST         R0,R0
    00001566 00000596               MOVI20      #1430,R0   ; H'00000596
    0000156A 8921                   BT          L502
    0000156C E59B                   MOV         #-101,R5   ; H'FFFFFF9B
               mnet.c       2087          if( !SetMotorRegisterInt(pm, WRG_RFA, 1) )                      return(( E_MNT_ACCESS + WRG_RFA ));// 9Bh
    0000156E E601                   MOV         #1,R6      ; H'00000001
    00001570 655C                   EXTU.B      R5,R5
    00001572 BD14                   BSR         _SetMotorRegisterInt
    00001574 64D3                   MOV         R13,R4
    00001576 2008                   TST         R0,R0
    00001578 0000059B               MOVI20      #1435,R0   ; H'0000059B
    0000157C 8918                   BT          L502
               mnet.c       2088          if( !SetMotorRegisterInt(pm, WRG_RUS, _pmInfo[pm].reg[R8]) )    return(( E_MNT_ACCESS + WRG_RUS ));// 99h
    0000157E 51F8                   MOV.L       @(32,R15),R1
    00001580 E599                   MOV         #-103,R5   ; H'FFFFFF99
    00001582 655C                   EXTU.B      R5,R5
    00001584 36116011               MOV.L       @(68:12,R1),R6; _pmInfo[].reg[]
    00001588 BD09                   BSR         _SetMotorRegisterInt
    0000158A 64D3                   MOV         R13,R4
    0000158C 2008                   TST         R0,R0
    0000158E 00000599               MOVI20      #1433,R0   ; H'00000599
    00001592 890D                   BT          L502
               mnet.c       2089          if( !SetMotorRegisterInt(pm, WRG_RDS, _pmInfo[pm].reg[R9]) )    return(( E_MNT_ACCESS + WRG_RDS ));// 9Ah
    00001594 51F8                   MOV.L       @(32,R15),R1
    00001596 E59A                   MOV         #-102,R5   ; H'FFFFFF9A
    00001598 655C                   EXTU.B      R5,R5
    0000159A 36116012               MOV.L       @(72:12,R1),R6; _pmInfo[].reg[]
    0000159E BCFE                   BSR         _SetMotorRegisterInt
    000015A0 64D3                   MOV         R13,R4
    000015A2 2008                   TST         R0,R0
    000015A4 8B03                   BF          L498
    000015A6 0000059A               MOVI20      #1434,R0   ; H'0000059A
    000015AA A001                   BRA         L502
    000015AC 0009                   NOP
    000015AE              L498:
    000015AE E000                   MOV         #0,R0      ; H'00000000
    000015B0              L502:
    000015B0 7F24                   ADD         #36,R15
    000015B2 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       2090      }
               mnet.c       2091    
               mnet.c       2092      return( E_SUCCESS );
               mnet.c       2093    }
    000015B4 006B                   RTS/N
               mnet.c       2094    ///<summary>
               mnet.c       2095    /// モータ動作パラメータから各レジスタの値を計算する関数
               mnet.c       2096    ///</summary>
               mnet.c       2097    static ER motor_CalcMotorReg(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg)
    000015B6              __$motor_CalcMotorReg:           ; function: __$motor_CalcMotorReg
                                                           ; frame size=28
    000015B6 2FE6                   MOV.L       R14,@-R15
    000015B8 4F12                   STS.L       MACL,@-R15
    000015BA 4F02                   STS.L       MACH,@-R15
    000015BC 7FF0                   ADD         #-16,R15
    000015BE 32419002               MOVU.W      @(4,R4),R2 ; (mp)->accel_type
    000015C2 E601                   MOV         #1,R6      ; H'00000001
               mnet.c       2098    {
               mnet.c       2099      if( mp->accel_type > 1 )        return(( E_PAR_OUTRNG + PARAM1 ));
    000015C4 3267                   CMP/GT      R6,R2
    000015C6 8F04                   BF/S        L515
    000015C8 6153                   MOV         R5,R1
    000015CA 00000801               MOVI20      #2049,R0   ; H'00000801
    000015CE A080                   BRA         L516
    000015D0 0009                   NOP
    000015D2              L515:
               mnet.c       2100      if( mp->FH == 0 )               return(( E_PAR_OUTRNG + PARAM2 ));
    000015D2 5543                   MOV.L       @(12,R4),R5; (mp)->FH
    000015D4 2558                   TST         R5,R5
    000015D6 8B03                   BF          L518
    000015D8 00000802               MOVI20      #2050,R0   ; H'00000802
    000015DC A079                   BRA         L516
    000015DE 0009                   NOP
    000015E0              L518:
               mnet.c       2101      if( mp->FL == 0 )               return(( E_PAR_OUTRNG + PARAM3 ));
    000015E0 5642                   MOV.L       @(8,R4),R6 ; (mp)->FL
    000015E2 2668                   TST         R6,R6
    000015E4 8973                   BT          L520
               mnet.c       2102      if( mp->FH <= mp->FL )          return(( E_PAR_OUTRNG + PARAM3 ));
    000015E6 3567                   CMP/GT      R6,R5
    000015E8 8B71                   BF          L520
               mnet.c       2103      if( mp->utime <= 0)             return(( E_PAR_OUTRNG + PARAM4 ));
    000015EA 5744                   MOV.L       @(16,R4),R7; (mp)->utime
    000015EC 4715                   CMP/PL      R7
    000015EE 8D04                   BT/S        L523
    000015F0 2F72                   MOV.L       R7,@R15
    000015F2 00000804               MOVI20      #2052,R0   ; H'00000804
    000015F6 A06C                   BRA         L516
    000015F8 0009                   NOP
    000015FA              L523:
               mnet.c       2104    
               mnet.c       2105      factor  = mp->factor;
    000015FA 6742                   MOV.L       @R4,R7     ; (mp)->factor
               mnet.c       2106      param   = (mp->accel_type == ACCEL_LINEAR ? 5000 : 2500);
    000015FC 2228                   TST         R2,R2
    000015FE DE4B                   MOV.L       L627+6,R14 ; __$factor
    00001600 2E72                   MOV.L       R7,@R14    ; factor
    00001602 0E0009C4               MOVI20      #2500,R14  ; H'000009C4
    00001606 8B01                   BF          L525
    00001608 0E001388               MOVI20      #5000,R14  ; H'00001388
    0000160C              L525:
    0000160C 1FE1                   MOV.L       R14,@(4,R15)
    0000160E 62E3                   MOV         R14,R2
    00001610 DE47                   MOV.L       L627+10,R14; __$param
    00001612 2E22                   MOV.L       R2,@R14    ; param
               mnet.c       2107      RMG     = factor;
    00001614 DE47                   MOV.L       L627+14,R14; __$RMG
    00001616 2E72                   MOV.L       R7,@R14    ; RMG
               mnet.c       2108      RFL     = (mp->FL * (RMG + 1)) / 200;
    00001618 7701                   ADD         #1,R7
    0000161A 6073                   MOV         R7,R0
    0000161C D246                   MOV.L       L627+18,R2 ; H'51EB851F
    0000161E 4680                   MULR        R0,R6
    00001620 1F22                   MOV.L       R2,@(8,R15)
    00001622 326D                   DMULS.L     R6,R2
    00001624 EEFA                   MOV         #-6,R14    ; H'FFFFFFFA
    00001626 020A                   STS         MACH,R2
    00001628 42EC                   SHAD        R14,R2
    0000162A 6023                   MOV         R2,R0
    0000162C 4004                   ROTL        R0
    0000162E C901                   AND         #1,R0
    00001630 320C                   ADD         R0,R2
               mnet.c       2109      RFH     = (mp->FH * (RMG + 1)) / 200;
    00001632 6073                   MOV         R7,R0
    00001634 4580                   MULR        R0,R5
    00001636 1F23                   MOV.L       R2,@(12,R15)
    00001638 6E23                   MOV         R2,R14
    0000163A D240                   MOV.L       L627+22,R2 ; __$RFL
    0000163C 22E2                   MOV.L       R14,@R2    ; RFL
    0000163E 52F2                   MOV.L       @(8,R15),R2
    00001640 325D                   DMULS.L     R5,R2
    00001642 E5FA                   MOV         #-6,R5     ; H'FFFFFFFA
               mnet.c       2110      RUR     = ((mp->utime * param) / (RFH - RFL)) - 1;
    00001644 62F2                   MOV.L       @R15,R2
    00001646 060A                   STS         MACH,R6
    00001648 465C                   SHAD        R5,R6
    0000164A 6063                   MOV         R6,R0
    0000164C 4004                   ROTL        R0
    0000164E C901                   AND         #1,R0
    00001650 360C                   ADD         R0,R6
    00001652 50F1                   MOV.L       @(4,R15),R0
    00001654 D53A                   MOV.L       L627+26,R5 ; __$RFH
    00001656 4280                   MULR        R0,R2
    00001658 2562                   MOV.L       R6,@R5     ; RFH
    0000165A 55F3                   MOV.L       @(12,R15),R5
    0000165C 3658                   SUB         R5,R6
    0000165E 55F2                   MOV.L       @(8,R15),R5
    00001660 6063                   MOV         R6,R0
    00001662 4294                   DIVS        R0,R2
    00001664 D637                   MOV.L       L627+30,R6 ; __$RUR
    00001666 6073                   MOV         R7,R0
    00001668 72FF                   ADD         #-1,R2
    0000166A 2622                   MOV.L       R2,@R6     ; RUR
    0000166C D236                   MOV.L       L627+34,R2 ; __$RUS
               mnet.c       2111      RUS     = (mp->us * (RMG + 1)) / 200;
    0000166E 5E46                   MOV.L       @(24,R4),R14; (mp)->us
    00001670 4E80                   MULR        R0,R14
    00001672 35ED                   DMULS.L     R14,R5
    00001674 E5FA                   MOV         #-6,R5     ; H'FFFFFFFA
    00001676 060A                   STS         MACH,R6
    00001678 465C                   SHAD        R5,R6
    0000167A 6063                   MOV         R6,R0
    0000167C 4004                   ROTL        R0
    0000167E C901                   AND         #1,R0
    00001680 360C                   ADD         R0,R6
    00001682 6073                   MOV         R7,R0
    00001684 2262                   MOV.L       R6,@R2     ; RUS
    00001686 57F2                   MOV.L       @(8,R15),R7
               mnet.c       2112      RDS     = (mp->ds * (RMG + 1)) / 200;
    00001688 5547                   MOV.L       @(28,R4),R5; (mp)->ds
               mnet.c       2113      
               mnet.c       2114      pm_reg->reg[R1] = RFL;
               mnet.c       2115      pm_reg->reg[R2] = RFH;
               mnet.c       2116      pm_reg->reg[R3] = RUR;
    0000168A D62E                   MOV.L       L627+30,R6 ; __$RUR
    0000168C 4580                   MULR        R0,R5
    0000168E 375D                   DMULS.L     R5,R7
    00001690 E7FA                   MOV         #-6,R7     ; H'FFFFFFFA
    00001692 D52E                   MOV.L       L627+38,R5 ; __$RDS
    00001694 040A                   STS         MACH,R4
    00001696 447C                   SHAD        R7,R4
    00001698 6043                   MOV         R4,R0
    0000169A 4004                   ROTL        R0
    0000169C C901                   AND         #1,R0
    0000169E 340C                   ADD         R0,R4
               mnet.c       2117      pm_reg->reg[R4] = RMG;
               mnet.c       2118      pm_reg->reg[R5] = 0;
               mnet.c       2119      pm_reg->reg[R6] = 2;
               mnet.c       2120      pm_reg->reg[R7] = 0;
               mnet.c       2121      pm_reg->reg[R8] = RUS;
               mnet.c       2122      pm_reg->reg[R9] = RDS;
               mnet.c       2123    
               mnet.c       2124      return ( E_SUCCESS );
    000016A0 E000                   MOV         #0,R0      ; H'00000000
    000016A2 2542                   MOV.L       R4,@R5     ; RDS
    000016A4 54F3                   MOV.L       @(12,R15),R4
    000016A6 1141                   MOV.L       R4,@(4,R1) ; pm_reg->reg[]
    000016A8 D425                   MOV.L       L627+26,R4 ; __$RFH
    000016AA 6742                   MOV.L       @R4,R7     ; RFH
    000016AC 1172                   MOV.L       R7,@(8,R1) ; pm_reg->reg[]
    000016AE 6462                   MOV.L       @R6,R4     ; RUR
    000016B0 D620                   MOV.L       L627+14,R6 ; __$RMG
    000016B2 1143                   MOV.L       R4,@(12,R1); pm_reg->reg[]
    000016B4 E400                   MOV         #0,R4      ; H'00000000
    000016B6 6762                   MOV.L       @R6,R7     ; RMG
    000016B8 E602                   MOV         #2,R6      ; H'00000002
    000016BA 1174                   MOV.L       R7,@(16,R1); pm_reg->reg[]
    000016BC 1145                   MOV.L       R4,@(20,R1); pm_reg->reg[]
    000016BE 1166                   MOV.L       R6,@(24,R1); pm_reg->reg[]
    000016C0 1147                   MOV.L       R4,@(28,R1); pm_reg->reg[]
    000016C2 D721                   MOV.L       L627+34,R7 ; __$RUS
    000016C4 6272                   MOV.L       @R7,R2     ; RUS
    000016C6 1128                   MOV.L       R2,@(32,R1); pm_reg->reg[]
    000016C8 6252                   MOV.L       @R5,R2     ; RDS
    000016CA A002                   BRA         L516
    000016CC 1129                   MOV.L       R2,@(36,R1); pm_reg->reg[]
    000016CE              L520:
    000016CE 00000803               MOVI20      #2051,R0   ; H'00000803
    000016D2              L516:
    000016D2 7F10                   ADD         #16,R15
    000016D4 4F06                   LDS.L       @R15+,MACH
    000016D6 4F16                   LDS.L       @R15+,MACL
               mnet.c       2125    }
    000016D8 000B                   RTS
    000016DA 6EF6                   MOV.L       @R15+,R14
               mnet.c       2126    ///<summary>
               mnet.c       2127    /// モータ動作パラメータから各レジスタの値を計算する関数
               mnet.c       2128    ///</summary>
               mnet.c       2129    static ER motor_CalcMotorRegPCD4611(const ST_MOTOR_PARAM* mp, PM_REG* pm_reg)
    000016DC              __$motor_CalcMotorRegPCD4611:    ; function: __$motor_CalcMotorRegPCD4611
                                                           ; frame size=24
    000016DC 4F12                   STS.L       MACL,@-R15
    000016DE 4F02                   STS.L       MACH,@-R15
    000016E0 7FF0                   ADD         #-16,R15
    000016E2 32419002               MOVU.W      @(4,R4),R2 ; (mp)->accel_type
    000016E6 E601                   MOV         #1,R6      ; H'00000001
               mnet.c       2130    {
               mnet.c       2131      if( mp->accel_type > 1 )        return(( E_PAR_OUTRNG + PARAM1 ));
    000016E8 3267                   CMP/GT      R6,R2
    000016EA 8F04                   BF/S        L528
    000016EC 6153                   MOV         R5,R1
    000016EE 00000801               MOVI20      #2049,R0   ; H'00000801
    000016F2 A09C                   BRA         L529
    000016F4 0009                   NOP
    000016F6              L528:
               mnet.c       2132      if( mp->FH == 0 )               return(( E_PAR_OUTRNG + PARAM2 ));
    000016F6 5543                   MOV.L       @(12,R4),R5; (mp)->FH
    000016F8 2558                   TST         R5,R5
    000016FA 8B03                   BF          L531
    000016FC 00000802               MOVI20      #2050,R0   ; H'00000802
    00001700 A095                   BRA         L529
    00001702 0009                   NOP
    00001704              L531:
               mnet.c       2133      if( mp->FL == 0 )               return(( E_PAR_OUTRNG + PARAM3 ));
    00001704 5642                   MOV.L       @(8,R4),R6 ; (mp)->FL
    00001706 2668                   TST         R6,R6
    00001708 8B01                   BF          L638
    0000170A A08E                   BRA         L533
    0000170C 0009                   NOP
    0000170E              L638:
               mnet.c       2134      if( mp->FH <= mp->FL )          return(( E_PAR_OUTRNG + PARAM3 ));
    0000170E 3567                   CMP/GT      R6,R5
    00001710 8901                   BT          L639
    00001712 A08A                   BRA         L533
    00001714 0009                   NOP
    00001716              L639:
               mnet.c       2135      if( mp->utime <= 0)             return(( E_PAR_OUTRNG + PARAM4 ));
    00001716 5744                   MOV.L       @(16,R4),R7; (mp)->utime
    00001718 4715                   CMP/PL      R7
    0000171A 8D19                   BT/S        L536
    0000171C 2F72                   MOV.L       R7,@R15
    0000171E 00000804               MOVI20      #2052,R0   ; H'00000804
    00001722 A084                   BRA         L529
    00001724 0009                   NOP
    00001726              L627:
    00001726 00000002               .RES.W      1
    00001728 <00000000>             .DATA.L     __$_pmInfo
    0000172C <00000000>             .DATA.L     __$factor
    00001730 <00000000>             .DATA.L     __$param
    00001734 <00000000>             .DATA.L     __$RMG
    00001738 51EB851F               .DATA.L     H'51EB851F
    0000173C <00000000>             .DATA.L     __$RFL
    00001740 <00000000>             .DATA.L     __$RFH
    00001744 <00000000>             .DATA.L     __$RUR
    00001748 <00000000>             .DATA.L     __$RUS
    0000174C <00000000>             .DATA.L     __$RDS
    00001750              L536:
               mnet.c       2136    
               mnet.c       2137      factor  = MOTORSPD_TBL_PCD4611[2];
    00001750 D79D                   MOV.L       L628,R7    ; H'00000008+__$MOTORSPD_TBL_PCD4611
    00001752 6372                   MOV.L       @R7,R3     ; MOTORSPD_TBL_PCD4611[]
               mnet.c       2138      param   = (mp->accel_type == ACCEL_LINEAR ? 5000 : 2500);
    00001754 2228                   TST         R2,R2
    00001756 D79D                   MOV.L       L628+4,R7  ; __$factor
    00001758 2732                   MOV.L       R3,@R7     ; factor
    0000175A 070009C4               MOVI20      #2500,R7   ; H'000009C4
    0000175E 8B01                   BF          L538
    00001760 07001388               MOVI20      #5000,R7   ; H'00001388
    00001764              L538:
    00001764 1F71                   MOV.L       R7,@(4,R15)
    00001766 6373                   MOV         R7,R3
    00001768 D799                   MOV.L       L628+8,R7  ; __$param
    0000176A 2732                   MOV.L       R3,@R7     ; param
               mnet.c       2139      RMG     = factor;
    0000176C D797                   MOV.L       L628+4,R7  ; __$factor
    0000176E 6072                   MOV.L       @R7,R0     ; factor
    00001770 D798                   MOV.L       L628+12,R7 ; __$RMG
    00001772 2702                   MOV.L       R0,@R7     ; RMG
               mnet.c       2140      RFL     = (mp->FL * (RMG + 1)) / 2441;                      // 40,000,000/ 16384 = 2441
    00001774 7001                   ADD         #1,R0
    00001776 4680                   MULR        R0,R6
    00001778 D297                   MOV.L       L628+16,R2 ; H'6B645D8D
    0000177A 6703                   MOV         R0,R7
    0000177C 1F22                   MOV.L       R2,@(8,R15)
    0000177E 326D                   DMULS.L     R6,R2
    00001780 E3F6                   MOV         #-10,R3    ; H'FFFFFFF6
    00001782 020A                   STS         MACH,R2
    00001784 423C                   SHAD        R3,R2
    00001786 6023                   MOV         R2,R0
    00001788 4004                   ROTL        R0
    0000178A C901                   AND         #1,R0
    0000178C 320C                   ADD         R0,R2
               mnet.c       2141      RFH     = (mp->FH * (RMG + 1)) / 2441;                      // 40,000,000/ 16384
    0000178E 6073                   MOV         R7,R0
    00001790 4580                   MULR        R0,R5
    00001792 1F23                   MOV.L       R2,@(12,R15)
    00001794 6323                   MOV         R2,R3
    00001796 D291                   MOV.L       L628+20,R2 ; __$RFL
    00001798 2232                   MOV.L       R3,@R2     ; RFL
    0000179A 52F2                   MOV.L       @(8,R15),R2
    0000179C 325D                   DMULS.L     R5,R2
    0000179E E5F6                   MOV         #-10,R5    ; H'FFFFFFF6
    000017A0 D28F                   MOV.L       L628+24,R2 ; __$RFH
    000017A2 060A                   STS         MACH,R6
    000017A4 465C                   SHAD        R5,R6
    000017A6 55F3                   MOV.L       @(12,R15),R5
    000017A8 6063                   MOV         R6,R0
    000017AA 4004                   ROTL        R0
    000017AC C901                   AND         #1,R0
    000017AE 360C                   ADD         R0,R6
               mnet.c       2142      RUR     = ((mp->utime * param) / (RFH - RFL)) - 1;
    000017B0 50F1                   MOV.L       @(4,R15),R0
    000017B2 2262                   MOV.L       R6,@R2     ; RFH
    000017B4 3658                   SUB         R5,R6
    000017B6 62F2                   MOV.L       @R15,R2
    000017B8 D58A                   MOV.L       L628+28,R5 ; __$RUR
    000017BA 4280                   MULR        R0,R2
    000017BC 6063                   MOV         R6,R0
    000017BE 4294                   DIVS        R0,R2
    000017C0 6073                   MOV         R7,R0
    000017C2 72FF                   ADD         #-1,R2
    000017C4 2522                   MOV.L       R2,@R5     ; RUR
               mnet.c       2143      RUS     = (mp->us * (RMG + 1)) / 2441;                      // 40,000,000/ 16384
               mnet.c       2144      RDS     = (mp->ds * (RMG + 1)) / 2441;                      // 40,000,000/ 16384
               mnet.c       2145      
               mnet.c       2146      pm_reg->reg[R1] = RFL;
               mnet.c       2147      pm_reg->reg[R2] = RFH;
               mnet.c       2148      pm_reg->reg[R3] = RUR;
               mnet.c       2149      pm_reg->reg[R4] = RMG;
               mnet.c       2150      pm_reg->reg[R5] = 0;
    000017C6 E200                   MOV         #0,R2      ; H'00000000
    000017C8 55F2                   MOV.L       @(8,R15),R5
    000017CA 5346                   MOV.L       @(24,R4),R3; (mp)->us
    000017CC 4380                   MULR        R0,R3
    000017CE 353D                   DMULS.L     R3,R5
    000017D0 E5F6                   MOV         #-10,R5    ; H'FFFFFFF6
    000017D2 060A                   STS         MACH,R6
    000017D4 465C                   SHAD        R5,R6
    000017D6 6063                   MOV         R6,R0
    000017D8 4004                   ROTL        R0
    000017DA C901                   AND         #1,R0
    000017DC 360C                   ADD         R0,R6
    000017DE 6073                   MOV         R7,R0
    000017E0 D581                   MOV.L       L628+32,R5 ; __$RUS
    000017E2 2562                   MOV.L       R6,@R5     ; RUS
    000017E4 57F2                   MOV.L       @(8,R15),R7
    000017E6 5547                   MOV.L       @(28,R4),R5; (mp)->ds
    000017E8 D67D                   MOV.L       L628+24,R6 ; __$RFH
    000017EA 4580                   MULR        R0,R5
    000017EC 375D                   DMULS.L     R5,R7
    000017EE E7F6                   MOV         #-10,R7    ; H'FFFFFFF6
    000017F0 D57E                   MOV.L       L628+36,R5 ; __$RDS
    000017F2 040A                   STS         MACH,R4
    000017F4 447C                   SHAD        R7,R4
    000017F6 6043                   MOV         R4,R0
    000017F8 4004                   ROTL        R0
    000017FA C901                   AND         #1,R0
    000017FC 340C                   ADD         R0,R4
               mnet.c       2151      pm_reg->reg[R6] = 2;
               mnet.c       2152      pm_reg->reg[R7] = 0;
               mnet.c       2153      pm_reg->reg[R8] = RUS;
               mnet.c       2154      pm_reg->reg[R9] = RDS;
               mnet.c       2155    
               mnet.c       2156      return ( E_SUCCESS );
    000017FE E000                   MOV         #0,R0      ; H'00000000
    00001800 2542                   MOV.L       R4,@R5     ; RDS
    00001802 54F3                   MOV.L       @(12,R15),R4
    00001804 1141                   MOV.L       R4,@(4,R1) ; pm_reg->reg[]
    00001806 6762                   MOV.L       @R6,R7     ; RFH
    00001808 D676                   MOV.L       L628+28,R6 ; __$RUR
    0000180A 1172                   MOV.L       R7,@(8,R1) ; pm_reg->reg[]
    0000180C 6462                   MOV.L       @R6,R4     ; RUR
    0000180E D671                   MOV.L       L628+12,R6 ; __$RMG
    00001810 1143                   MOV.L       R4,@(12,R1); pm_reg->reg[]
    00001812 6462                   MOV.L       @R6,R4     ; RMG
    00001814 E602                   MOV         #2,R6      ; H'00000002
    00001816 1144                   MOV.L       R4,@(16,R1); pm_reg->reg[]
    00001818 1125                   MOV.L       R2,@(20,R1); pm_reg->reg[]
    0000181A 1166                   MOV.L       R6,@(24,R1); pm_reg->reg[]
    0000181C 1127                   MOV.L       R2,@(28,R1); pm_reg->reg[]
    0000181E D472                   MOV.L       L628+32,R4 ; __$RUS
    00001820 6242                   MOV.L       @R4,R2     ; RUS
    00001822 1128                   MOV.L       R2,@(32,R1); pm_reg->reg[]
    00001824 6252                   MOV.L       @R5,R2     ; RDS
    00001826 A002                   BRA         L529
    00001828 1129                   MOV.L       R2,@(36,R1); pm_reg->reg[]
    0000182A              L533:
    0000182A 00000803               MOVI20      #2051,R0   ; H'00000803
    0000182E              L529:
    0000182E 7F10                   ADD         #16,R15
    00001830 4F06                   LDS.L       @R15+,MACH
               mnet.c       2157    }
    00001832 000B                   RTS
    00001834 4F16                   LDS.L       @R15+,MACL
               mnet.c       2158    /////<summary>
               mnet.c       2159    /// コマンドをセットする関数
               mnet.c       2160    ///</summary>
               mnet.c       2161    static void motor_RegistCommand(UB pm, UH cmd)
    00001836              __$motor_RegistCommand:          ; function: __$motor_RegistCommand
                                                           ; frame size=0
               mnet.c       2162    {
               mnet.c       2163      _pmInfo[pm].command.code     = cmd;
    00001836 644C                   EXTU.B      R4,R4
    00001838 E064                   MOV         #100,R0    ; H'00000064
    0000183A 6643                   MOV         R4,R6
               mnet.c       2164      _pmInfo[pm].command.status   = PSTAT_READY;
    0000183C E702                   MOV         #2,R7      ; H'00000002
    0000183E 4680                   MULR        R0,R6
    00001840 D16B                   MOV.L       L628+40,R1 ; __$_pmInfo
    00001842 6043                   MOV         R4,R0
    00001844 361C                   ADD         R1,R6
               mnet.c       2165    
               mnet.c       2166      if( MNET_DRV_TYPE[pm] == PCD4611 )
    00001846 D16B                   MOV.L       L628+44,R1 ; _MNET_DRV_TYPE
    00001848 001C                   MOV.B       @(R0,R1),R0; MNET_DRV_TYPE[]
    0000184A 3651102E               MOV.W       R5,@(92:12,R6); _pmInfo[].code
    0000184E 8809                   CMP/EQ      #9,R0
    00001850 3671102F               MOV.W       R7,@(94:12,R6); _pmInfo[].status
    00001854 8903                   BT          L540
               mnet.c       2167      {
               mnet.c       2168          // PCD4611は、処理不要。前段階で実行済み
               mnet.c       2169      }
               mnet.c       2170      else
               mnet.c       2171      {
               mnet.c       2172          SetMotorCommand(pm, _pmInfo[pm].startParam);
    00001856 35615030               MOV.W       @(96:12,R6),R5; _pmInfo[].startParam
    0000185A AB82                   BRA         __$SetMotorCommand
    0000185C 0009                   NOP
    0000185E              L540:
    0000185E 006B                   RTS/N
               mnet.c       2173      }
               mnet.c       2174    }
               mnet.c       2175    ///<summary>
               mnet.c       2176    /// 指定μs待機します
               mnet.c       2177    ///</summary>
               mnet.c       2178    static void g_Sleep(INT usec)
    00001860              _g_Sleep:                        ; function: g_Sleep
                                                           ; frame size=0
               mnet.c       2179    {
               mnet.c       2180        INT i;
               mnet.c       2181        
               mnet.c       2182        i = 40000;          // 6.25 ns/instruction * 4 instructions * loop_count = 1ms = 1000000 ns
               mnet.c       2183        i *= usec;
               mnet.c       2184        i /= 1000;
    00001860 E028                   MOV         #40,R0     ; H'00000028
    00001862 4480                   MULR        R0,R4
    00001864 6643                   MOV         R4,R6
    00001866              L543:
               mnet.c       2185        while (i--);        /* loop count */
    00001866 2668                   TST         R6,R6
    00001868 8FFD                   BF/S        L543
    0000186A 76FF                   ADD         #-1,R6
               mnet.c       2186    }
    0000186C 006B                   RTS/N
               mnet.c       2187    ///<summary>
               mnet.c       2188    /// 割り込み要因をクリアします
               mnet.c       2189    ///</summary>
               mnet.c       2190    static void ClearInterrupt(void)
               mnet.c       2191    {
               mnet.c       2192    }
               mnet.c       2193    
               mnet.c       2194    /******************************************************************************
               mnet.c       2195    * 
               mnet.c       2196    * [概要]  ＩＦＢアイドリング待ち
               mnet.c       2197    * [引数]  −
               mnet.c       2198    * [戻値]  IFBビット(TRUE = ビジー , FALSE = アイドリング)
               mnet.c       2199    * 
               mnet.c       2200    ******************************************************************************/
               mnet.c       2201    static BOOL IfbIdleWait(void)
    0000186E              __$IfbIdleWait:                  ; function: __$IfbIdleWait
                                                           ; frame size=8
    0000186E 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       2202    {
               mnet.c       2203      INT loop;
               mnet.c       2204      
               mnet.c       2205      for( loop = 0; loop < MNET_CMD_RTY_MAX; loop++ )
    00001870 EE78                   MOV         #120,R14   ; H'00000078
    00001872              L546:
               mnet.c       2206      {
               mnet.c       2207          if( ChkIFB() == TRUE )  return( FALSE );
    00001872 B00B                   BSR         __$ChkIFB
    00001874 0009                   NOP
    00001876 8801                   CMP/EQ      #1,R0
    00001878 8905                   BT          L548
               mnet.c       2208          g_Sleep(5);
    0000187A BFF1                   BSR         _g_Sleep
    0000187C E405                   MOV         #5,R4      ; H'00000005
    0000187E 4E10                   DT          R14
    00001880 8BF7                   BF          L546
               mnet.c       2209      }
               mnet.c       2210      
               mnet.c       2211      return( TRUE );
    00001882 A001                   BRA         L550
    00001884 0029                   MOVT        R0
    00001886              L548:
    00001886 0039                   MOVRT       R0
    00001888              L550:
    00001888 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       2212    }
    0000188A 006B                   RTS/N
               mnet.c       2213    /******************************************************************************
               mnet.c       2214    * 
               mnet.c       2215    * [概要]  ＩＦＢ状態取得
               mnet.c       2216    * [引数]  −
               mnet.c       2217    * [戻値]  IFBビット(TRUE = 1 , FALSE = 0)
               mnet.c       2218    * 
               mnet.c       2219    ******************************************************************************/
               mnet.c       2220    static BOOL ChkIFB( void )
    0000188C              __$ChkIFB:                       ; function: __$ChkIFB
                                                           ; frame size=0
               mnet.c       2221    {
               mnet.c       2222      BOOL    result; 
               mnet.c       2223    
               mnet.c       2224      if( PB.DR.BIT.B19 )
    0000188C 06E03880               MOVI20      #-116608,R6; H'FFFE3880
    00001890 8461                   MOV.B       @(1,R6),R0
    00001892 C808                   TST         #8,R0
               mnet.c       2225      {
               mnet.c       2226          result = TRUE;
               mnet.c       2227      }
               mnet.c       2228      else
               mnet.c       2229      {
               mnet.c       2230          result = FALSE;
               mnet.c       2231      }
               mnet.c       2232    
               mnet.c       2233      return( result );
               mnet.c       2234    }
    00001894 000B                   RTS
    00001896 0039                   MOVRT       R0
               mnet.c       2235    /******************************************************************************
               mnet.c       2236    * 
               mnet.c       2237    * [概要]  完了待ち
               mnet.c       2238    * [引数]  −
               mnet.c       2239    * [戻値]  TRUE = ビジー , FALSE = アイドリング
               mnet.c       2240    * 
               mnet.c       2241    ******************************************************************************/
               mnet.c       2242    static BOOL EndIdleWait(void)
    00001898              __$EndIdleWait:                  ; function: __$EndIdleWait
                                                           ; frame size=8
    00001898 4EF0                   MOVMU.L     R14,@-R15
               mnet.c       2243    {
               mnet.c       2244      INT loop;
               mnet.c       2245      
               mnet.c       2246      for( loop = 0; loop < MNET_CMD_RTY_MAX; loop++ )
    0000189A EE78                   MOV         #120,R14   ; H'00000078
    0000189C              L553:
               mnet.c       2247      {
               mnet.c       2248          if( ChkEnd() == TRUE )  return( FALSE );
    0000189C B00B                   BSR         __$ChkEnd
    0000189E 0009                   NOP
    000018A0 8801                   CMP/EQ      #1,R0
    000018A2 8905                   BT          L555
               mnet.c       2249          g_Sleep(5);
    000018A4 BFDC                   BSR         _g_Sleep
    000018A6 E405                   MOV         #5,R4      ; H'00000005
    000018A8 4E10                   DT          R14
    000018AA 8BF7                   BF          L553
               mnet.c       2250      }
               mnet.c       2251    
               mnet.c       2252      return( TRUE );
    000018AC A001                   BRA         L557
    000018AE 0029                   MOVT        R0
    000018B0              L555:
    000018B0 0039                   MOVRT       R0
    000018B2              L557:
    000018B2 4EF4                   MOVMU.L     @R15+,R14
               mnet.c       2253    }
    000018B4 006B                   RTS/N
               mnet.c       2254    /******************************************************************************
               mnet.c       2255    * 
               mnet.c       2256    * [概要]  エンド状態取得
               mnet.c       2257    * [引数]  −
               mnet.c       2258    * [戻値]  TRUE:完了、FALSE:未完了
               mnet.c       2259    * 
               mnet.c       2260    ******************************************************************************/
               mnet.c       2261    static BOOL ChkEnd( void )
    000018B6              __$ChkEnd:                       ; function: __$ChkEnd
                                                           ; frame size=8
    000018B6 4F22                   STS.L       PR,@-R15
    000018B8 7FFC                   ADD         #-4,R15
               mnet.c       2262    {
               mnet.c       2263      BOOL    result; 
               mnet.c       2264      MNETStatus status;
               mnet.c       2265    
               mnet.c       2266      GetMainStatus(&status);
    000018BA BB09                   BSR         __$GetMainStatus
    000018BC 64F3                   MOV         R15,R4
               mnet.c       2267    
               mnet.c       2268      if (status.UNID.BIT.CEND)
    000018BE 84F1                   MOV.B       @(1,R15),R0; (part of)status
    000018C0 8708                   BLD         #0,R0
    000018C2 8F04                   BF/S        L560
    000018C4 6603                   MOV         R0,R6
               mnet.c       2269      {
               mnet.c       2270          if (status.UNID.BIT.EDTE)
    000018C6 876C                   BLD         #4,R6
    000018C8 8901                   BT          L560
               mnet.c       2271          {
               mnet.c       2272              result = FALSE; //エラー
               mnet.c       2273          }
               mnet.c       2274          else
               mnet.c       2275          {
               mnet.c       2276              result = TRUE;
    000018CA A001                   BRA         L562
    000018CC 0239                   MOVRT       R2
    000018CE              L560:
    000018CE E200                   MOV         #0,R2      ; H'00000000
    000018D0              L562:
    000018D0 7F04                   ADD         #4,R15
    000018D2 4F26                   LDS.L       @R15+,PR
               mnet.c       2277          }
               mnet.c       2278      }
               mnet.c       2279      else
               mnet.c       2280      {
               mnet.c       2281          result = FALSE;
               mnet.c       2282      }
               mnet.c       2283    
               mnet.c       2284      return( result );
               mnet.c       2285    }
    000018D4 027B                   RTV/N       R2
               mnet.c       2286    /******************************************************************************
               mnet.c       2287    * 
               mnet.c       2288    * [概要]  RBSY状態取得
               mnet.c       2289    * [引数]  −
               mnet.c       2290    * [戻値]  1:ON、0:OFF
               mnet.c       2291    * 
               mnet.c       2292    ******************************************************************************/
               mnet.c       2293    static UB ChkRbsy( void )
    000018D6              __$ChkRbsy:                      ; function: __$ChkRbsy
                                                           ; frame size=8
    000018D6 4F22                   STS.L       PR,@-R15
    000018D8 7FFC                   ADD         #-4,R15
               mnet.c       2294    {
               mnet.c       2295      UB  result; 
               mnet.c       2296      MNETStatus status;
               mnet.c       2297    
               mnet.c       2298      GetMainStatus(&status);
    000018DA BAF9                   BSR         __$GetMainStatus
    000018DC 64F3                   MOV         R15,R4
               mnet.c       2299    
               mnet.c       2300      result = ( status.UNID.BIT.RBSY ? SET : CLR );
    000018DE 60F0                   MOV.B       @R15,R0    ; (part of)status
    000018E0 C820                   TST         #32,R0
    000018E2 7F04                   ADD         #4,R15
    000018E4 4F26                   LDS.L       @R15+,PR
               mnet.c       2301    
               mnet.c       2302      return( result );
               mnet.c       2303    }
    000018E6 000B                   RTS
    000018E8 0039                   MOVRT       R0
               mnet.c       2304    /******************************************************************************
               mnet.c       2305    * 
               mnet.c       2306    * [概要]  DBSY状態取得
               mnet.c       2307    * [引数]  −
               mnet.c       2308    * [戻値]  1:ON、0:OFF
               mnet.c       2309    * 
               mnet.c       2310    ******************************************************************************/
               mnet.c       2311    static UB ChkDbsy( void )
    000018EA              __$ChkDbsy:                      ; function: __$ChkDbsy
                                                           ; frame size=8
    000018EA 4F22                   STS.L       PR,@-R15
    000018EC 7FFC                   ADD         #-4,R15
               mnet.c       2312    {
               mnet.c       2313      UB  result; 
               mnet.c       2314      MNETStatus status;
               mnet.c       2315    
               mnet.c       2316      GetMainStatus(&status);
    000018EE BAEF                   BSR         __$GetMainStatus
    000018F0 64F3                   MOV         R15,R4
               mnet.c       2317    
               mnet.c       2318      result = ( status.UNID.BIT.DBSY ? SET : CLR );
    000018F2 60F0                   MOV.B       @R15,R0    ; (part of)status
    000018F4 C840                   TST         #64,R0
    000018F6 7F04                   ADD         #4,R15
    000018F8 4F26                   LDS.L       @R15+,PR
               mnet.c       2319    
               mnet.c       2320      return( result );
               mnet.c       2321    }
    000018FA 000B                   RTS
    000018FC 0039                   MOVRT       R0
               mnet.c       2322    /******************************************************************************
               mnet.c       2323    * 
               mnet.c       2324    * [概要]  SBSY状態取得
               mnet.c       2325    * [引数]  −
               mnet.c       2326    * [戻値]  1:ON、0:OFF
               mnet.c       2327    * 
               mnet.c       2328    ******************************************************************************/
               mnet.c       2329    static UB ChkSbsy( void )
    000018FE              __$ChkSbsy:                      ; function: __$ChkSbsy
                                                           ; frame size=8
    000018FE 4F22                   STS.L       PR,@-R15
    00001900 7FFC                   ADD         #-4,R15
               mnet.c       2330    {
               mnet.c       2331      UB  result; 
               mnet.c       2332      MNETStatus status;
               mnet.c       2333    
               mnet.c       2334      GetMainStatus(&status);
    00001902 BAE5                   BSR         __$GetMainStatus
    00001904 64F3                   MOV         R15,R4
               mnet.c       2335    
               mnet.c       2336      result = ( status.UNID.BIT.SBSY ? SET : CLR );
    00001906 60F0                   MOV.B       @R15,R0    ; (part of)status
    00001908 C810                   TST         #16,R0
    0000190A 7F04                   ADD         #4,R15
    0000190C 4F26                   LDS.L       @R15+,PR
               mnet.c       2337    
               mnet.c       2338      return( result );
               mnet.c       2339    }
    0000190E 000B                   RTS
    00001910 0039                   MOVRT       R0
               mnet.c       2340    static UB dev_nowk;
               mnet.c       2341    /******************************************************************************
               mnet.c       2342    * 
               mnet.c       2343    * [概要]  RENV1 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2344    * [引数]  −
               mnet.c       2345    * [戻値]  −
               mnet.c       2346    * 
               mnet.c       2347    ******************************************************************************/
               mnet.c       2348    static ER SetRenv1Fu( UB dev_no )
    00001912              __$SetRenv1Fu:                   ; function: __$SetRenv1Fu
                                                           ; frame size=20
    00001912 4CF0                   MOVMU.L     R12,@-R15
    00001914 7FFC                   ADD         #-4,R15
               mnet.c       2349    {
               mnet.c       2350      RENV1       renv1;
               mnet.c       2351      ER          result = E_SUCCESS;
               mnet.c       2352    dev_nowk = dev_no;
               mnet.c       2353      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    00001916 DE37                   MOV.L       L628+44,R14; _MNET_DRV_TYPE
    00001918 6D4C                   EXTU.B      R4,R13
    0000191A EC00                   MOV         #0,R12     ; H'00000000
    0000191C 3EDC                   ADD         R13,R14
    0000191E 60E0                   MOV.B       @R14,R0    ; MNET_DRV_TYPE[]
    00001920 D635                   MOV.L       L628+48,R6 ; __$dev_nowk
    00001922 880A                   CMP/EQ      #10,R0
    00001924 8F02                   BF/S        L568
    00001926 2640                   MOV.B       R4,@R6     ; dev_nowk
               mnet.c       2354      {
               mnet.c       2355          return( result );
    00001928 A018                   BRA         L569
    0000192A E000                   MOV         #0,R0      ; H'00000000
    0000192C              L568:
               mnet.c       2356      }
               mnet.c       2357    
               mnet.c       2358      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    0000192C 8809                   CMP/EQ      #9,R0
    0000192E 8914                   BT          L571
    00001930 E604                   MOV         #4,R6      ; H'00000004
    00001932 E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2359      {
               mnet.c       2360          memset( &renv1, CLR, sizeof( RENV1 ) );
    00001934 D231                   MOV.L       L628+52,R2 ; _memset
    00001936 420B                   JSR         @R2
    00001938 64F3                   MOV         R15,R4
               mnet.c       2361    
               mnet.c       2362          renv1.UNID.BIT.PDTC = 1;
               mnet.c       2363    
               mnet.c       2364          //FU-A
               mnet.c       2365          if( MNET_DRV_TYPE[dev_no] == BCD4020FUA )
    0000193A 60E0                   MOV.B       @R14,R0    ; MNET_DRV_TYPE[]
    0000193C 8801                   CMP/EQ      #1,R0
    0000193E 3F591000               BSET.B      #5,@(0,R15); (part of)renv1
    00001942 8B01                   BF          L573
               mnet.c       2366          {
               mnet.c       2367              // 自動カレントダウン
               mnet.c       2368              renv1.UNID.BIT.CDWN = 1;
    00001944 3F791000               BSET.B      #7,@(0,R15); (part of)renv1
    00001948              L573:
    00001948 66F2                   MOV.L       @R15,R6    ; renv1.UNID.data
    0000194A E59C                   MOV         #-100,R5   ; H'FFFFFF9C
    0000194C 655C                   EXTU.B      R5,R5
               mnet.c       2369          }
               mnet.c       2370    
               mnet.c       2371          // 9Ch
               mnet.c       2372          if (!SetMotorRegisterInt( dev_no, WRG_RENV1, renv1.UNID.data ) )
    0000194E BB26                   BSR         _SetMotorRegisterInt
    00001950 64D3                   MOV         R13,R4
    00001952 2008                   TST         R0,R0
    00001954 8B01                   BF          L571
               mnet.c       2373          {
               mnet.c       2374              result = E_MNT_ACCESS + WRG_RENV1;
    00001956 0C00059C               MOVI20      #1436,R12  ; H'0000059C
    0000195A              L571:
               mnet.c       2375          }
               mnet.c       2376      }
               mnet.c       2377      return( result );
    0000195A 60C3                   MOV         R12,R0
    0000195C              L569:
    0000195C 7F04                   ADD         #4,R15
    0000195E 4CF4                   MOVMU.L     @R15+,R12
               mnet.c       2378    }
    00001960 006B                   RTS/N
               mnet.c       2379    /******************************************************************************
               mnet.c       2380    * 
               mnet.c       2381    * [概要]  RENV2 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2382    * [引数]  −
               mnet.c       2383    * [戻値]  −
               mnet.c       2384    * 
               mnet.c       2385    ******************************************************************************/
               mnet.c       2386    static ER SetRenv2Fu( UB dev_no, UB teibai )
    00001962              __$SetRenv2Fu:                   ; function: __$SetRenv2Fu
                                                           ; frame size=24
    00001962 4BF0                   MOVMU.L     R11,@-R15
    00001964 7FFC                   ADD         #-4,R15
               mnet.c       2387    {
               mnet.c       2388      ER          result = E_SUCCESS;
               mnet.c       2389      RENV2       renv2;
               mnet.c       2390    
               mnet.c       2391      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    00001966 DE23                   MOV.L       L628+44,R14; _MNET_DRV_TYPE
    00001968 6C4C                   EXTU.B      R4,R12
    0000196A EB00                   MOV         #0,R11     ; H'00000000
    0000196C 3ECC                   ADD         R12,R14
    0000196E 60E0                   MOV.B       @R14,R0    ; MNET_DRV_TYPE[]
    00001970 880A                   CMP/EQ      #10,R0
    00001972 8F02                   BF/S        L582
    00001974 6D53                   MOV         R5,R13
               mnet.c       2392      {
               mnet.c       2393          return( result );
    00001976 A051                   BRA         L583
    00001978 E000                   MOV         #0,R0      ; H'00000000
    0000197A              L582:
               mnet.c       2394      }
               mnet.c       2395    
               mnet.c       2396      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    0000197A 8809                   CMP/EQ      #9,R0
    0000197C 894D                   BT          L585
    0000197E E604                   MOV         #4,R6      ; H'00000004
    00001980 E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2397      {
               mnet.c       2398          memset( &renv2, CLR, sizeof( RENV2 ) );
    00001982 D21E                   MOV.L       L628+52,R2 ; _memset
    00001984 420B                   JSR         @R2
    00001986 64F3                   MOV         R15,R4
               mnet.c       2399          
               mnet.c       2400          // P0M 励磁出力
               mnet.c       2401          renv2.UNID.BIT.P0M  = 1;
               mnet.c       2402          
               mnet.c       2403          if( MNET_DRV_TYPE[dev_no] == BCD4020FUA )
    00001988 60E0                   MOV.B       @R14,R0    ; MNET_DRV_TYPE[]
    0000198A 8801                   CMP/EQ      #1,R0
    0000198C 3F091003               BSET.B      #0,@(3,R15); (part of)renv2
    00001990 8B05                   BF          L587
               mnet.c       2404          {
               mnet.c       2405              // P1M 汎用出力
               mnet.c       2406              renv2.UNID.BIT.P1M  = 1;
    00001992 3F191003               BSET.B      #1,@(3,R15); (part of)renv2
               mnet.c       2407    
               mnet.c       2408              // P2M 汎用出力
               mnet.c       2409              renv2.UNID.BIT.P2M  = 1;
    00001996 3F291003               BSET.B      #2,@(3,R15); (part of)renv2
    0000199A A002                   BRA         L588
    0000199C 0009                   NOP
    0000199E              L587:
               mnet.c       2410          }
               mnet.c       2411          else
               mnet.c       2412          {
               mnet.c       2413              // P6M 自動カレントダウン
               mnet.c       2414              renv2.UNID.BIT.P6M  = 1;
    0000199E 3F691003               BSET.B      #6,@(3,R15); (part of)renv2
    000019A2              L588:
               mnet.c       2415          }
               mnet.c       2416          
               mnet.c       2417          // EOF
               mnet.c       2418          renv2.UNID.BIT.E0FF = 0;
               mnet.c       2419    
               mnet.c       2420          // EA/EB入力仕様
               mnet.c       2421          switch( teibai )
    000019A2 60DC                   EXTU.B      R13,R0
    000019A4 8801                   CMP/EQ      #1,R0
    000019A6 3F190001               BCLR.B      #1,@(1,R15); (part of)renv2
    000019AA 8903                   BT          L590
    000019AC 8802                   CMP/EQ      #2,R0
    000019AE 8905                   BT          L591
    000019B0 A026                   BRA         L592
    000019B2 0009                   NOP
    000019B4              L590:
               mnet.c       2422          {
               mnet.c       2423          // 1逓倍
               mnet.c       2424          case EC_1:
               mnet.c       2425              renv2.UNID.BIT.EIM0 = 0;
    000019B4 3F190002               BCLR.B      #1,@(2,R15); (part of)renv2
    000019B8 A002                   BRA         L593
    000019BA 0009                   NOP
    000019BC              L591:
               mnet.c       2426              renv2.UNID.BIT.EIM1 = 0;
               mnet.c       2427              break;
               mnet.c       2428          // 2逓倍
               mnet.c       2429          case EC_2:
               mnet.c       2430              renv2.UNID.BIT.EIM0 = 1;
    000019BC 3F191002               BSET.B      #1,@(2,R15); (part of)renv2
    000019C0              L593:
    000019C0 3F290002               BCLR.B      #2,@(2,R15); (part of)renv2
    000019C4 A020                   BRA         L594
    000019C6 0009                   NOP
    000019C8              L628:
    000019C8 <00000008>             .DATA.L     H'00000008+__$MOTORSPD_TBL_PCD4611
    000019CC <00000000>             .DATA.L     __$factor
    000019D0 <00000000>             .DATA.L     __$param
    000019D4 <00000000>             .DATA.L     __$RMG
    000019D8 6B645D8D               .DATA.L     H'6B645D8D
    000019DC <00000000>             .DATA.L     __$RFL
    000019E0 <00000000>             .DATA.L     __$RFH
    000019E4 <00000000>             .DATA.L     __$RUR
    000019E8 <00000000>             .DATA.L     __$RUS
    000019EC <00000000>             .DATA.L     __$RDS
    000019F0 <00000000>             .DATA.L     __$_pmInfo
    000019F4 <00000000>             .DATA.L     _MNET_DRV_TYPE
    000019F8 <00000000>             .DATA.L     __$dev_nowk
    000019FC <00000000>             .DATA.L     _memset
    00001A00              L592:
               mnet.c       2431              renv2.UNID.BIT.EIM1 = 0;
               mnet.c       2432              break;
               mnet.c       2433          // 4逓倍
               mnet.c       2434          case EC_3:
               mnet.c       2435          default:
               mnet.c       2436              renv2.UNID.BIT.EIM0 = 0;
    00001A00 3F190002               BCLR.B      #1,@(2,R15); (part of)renv2
               mnet.c       2437              renv2.UNID.BIT.EIM1 = 1;
    00001A04 3F291002               BSET.B      #2,@(2,R15); (part of)renv2
    00001A08              L594:
    00001A08 66F2                   MOV.L       @R15,R6    ; renv2.UNID.data
    00001A0A E59D                   MOV         #-99,R5    ; H'FFFFFF9D
    00001A0C 655C                   EXTU.B      R5,R5
               mnet.c       2438              break;
               mnet.c       2439          }
               mnet.c       2440          
               mnet.c       2441          // 9Dh
               mnet.c       2442          if (!SetMotorRegisterInt( dev_no, WRG_RENV2, renv2.UNID.data ) )
    00001A0E BAC6                   BSR         _SetMotorRegisterInt
    00001A10 64C3                   MOV         R12,R4
    00001A12 2008                   TST         R0,R0
    00001A14 8B01                   BF          L585
               mnet.c       2443          {
               mnet.c       2444              result = E_MNT_ACCESS + WRG_RENV2;
    00001A16 0B00059D               MOVI20      #1437,R11  ; H'0000059D
    00001A1A              L585:
               mnet.c       2445          }
               mnet.c       2446      }
               mnet.c       2447      return( result );
    00001A1A 60B3                   MOV         R11,R0
    00001A1C              L583:
    00001A1C 7F04                   ADD         #4,R15
    00001A1E 4BF4                   MOVMU.L     @R15+,R11
               mnet.c       2448    }
    00001A20 006B                   RTS/N
               mnet.c       2449    /******************************************************************************
               mnet.c       2450    * 
               mnet.c       2451    * [概要]  RENV3 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2452    * [引数]  −
               mnet.c       2453    * [戻値]  −
               mnet.c       2454    * 
               mnet.c       2455    ******************************************************************************/
               mnet.c       2456    static ER SetRenv3Fu( UB dev_no, UB enc )
    00001A22              __$SetRenv3Fu:                   ; function: __$SetRenv3Fu
                                                           ; frame size=16
    00001A22 4DF0                   MOVMU.L     R13,@-R15
    00001A24 7FFC                   ADD         #-4,R15
               mnet.c       2457    {
               mnet.c       2458      ER          result = E_SUCCESS;
               mnet.c       2459      RENV3       renv3;
               mnet.c       2460    
               mnet.c       2461      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    00001A26 D676                   MOV.L       L629+2,R6  ; _MNET_DRV_TYPE
    00001A28 6E4C                   EXTU.B      R4,R14
    00001A2A 60E3                   MOV         R14,R0
    00001A2C 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00001A2E 880A                   CMP/EQ      #10,R0
    00001A30 8F02                   BF/S        L598
    00001A32 ED00                   MOV         #0,R13     ; H'00000000
               mnet.c       2462      {
               mnet.c       2463          return( result );
    00001A34 A019                   BRA         L599
    00001A36 E000                   MOV         #0,R0      ; H'00000000
    00001A38              L598:
               mnet.c       2464      }
               mnet.c       2465    
               mnet.c       2466      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    00001A38 8809                   CMP/EQ      #9,R0
    00001A3A 8915                   BT          L601
    00001A3C E604                   MOV         #4,R6      ; H'00000004
    00001A3E E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2467      {
               mnet.c       2468          memset( &renv3, CLR, sizeof( RENV3 ) );
    00001A40 D270                   MOV.L       L629+6,R2  ; _memset
    00001A42 420B                   JSR         @R2
    00001A44 64F3                   MOV         R15,R4
               mnet.c       2469    
               mnet.c       2470          // 原点復帰動作設定：原点復帰２
               mnet.c       2471          renv3.UNID.BIT.ORM0 = 0;
    00001A46 85F1                   MOV.W       @(2,R15),R0; (part of)renv3
    00001A48 E59E                   MOV         #-98,R5    ; H'FFFFFF9E
    00001A4A 01F0F0FC               MOVI20      #-3844,R1  ; H'FFFFF0FC
    00001A4E 2019                   AND         R1,R0
    00001A50 655C                   EXTU.B      R5,R5
               mnet.c       2472          renv3.UNID.BIT.ORM1 = 0;
    00001A52 0200100C               MOVI20      #4108,R2   ; H'0000100C
    00001A56 202B                   OR          R2,R0
               mnet.c       2473          renv3.UNID.BIT.ORM2 = 1;
               mnet.c       2474          renv3.UNID.BIT.ORM3 = 1;
               mnet.c       2475    
               mnet.c       2476          // COUNTER2カウント設定：EA/EB入力
               mnet.c       2477          renv3.UNID.BIT.CI20 = 0;
               mnet.c       2478          renv3.UNID.BIT.CI21 = 0;
               mnet.c       2479    
               mnet.c       2480          // COUNTER3カウント設定：出力パルスとEA/EB入力（偏差）
               mnet.c       2481          renv3.UNID.BIT.CI30 = 0;
               mnet.c       2482          renv3.UNID.BIT.CI31 = 0;
               mnet.c       2483          renv3.UNID.BIT.CI32 = 1;
               mnet.c       2484    
               mnet.c       2485          // 9Eh
               mnet.c       2486          if (!SetMotorRegisterInt(dev_no, WRG_RENV3, renv3.UNID.data) )
    00001A58 64E3                   MOV         R14,R4
    00001A5A 81F1                   MOV.W       R0,@(2,R15); (part of)renv3
    00001A5C BA9F                   BSR         _SetMotorRegisterInt
    00001A5E 66F2                   MOV.L       @R15,R6    ; renv3.UNID.data
    00001A60 2008                   TST         R0,R0
    00001A62 8B01                   BF          L601
               mnet.c       2487          {
               mnet.c       2488              result = E_MNT_ACCESS + WRG_RENV3;
    00001A64 0D00059E               MOVI20      #1438,R13  ; H'0000059E
    00001A68              L601:
               mnet.c       2489          }
               mnet.c       2490      }
               mnet.c       2491      return( result );
    00001A68 60D3                   MOV         R13,R0
    00001A6A              L599:
    00001A6A 7F04                   ADD         #4,R15
    00001A6C 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       2492    }
    00001A6E 006B                   RTS/N
               mnet.c       2493    /******************************************************************************
               mnet.c       2494    * 
               mnet.c       2495    * [概要]  RENV4 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2496    * [引数]  −
               mnet.c       2497    * [戻値]  −
               mnet.c       2498    * 
               mnet.c       2499    ******************************************************************************/
               mnet.c       2500    static ER SetRenv4Fu( UB dev_no, INT so )
               mnet.c       2501    {
               mnet.c       2502      ER          result = E_SUCCESS;
               mnet.c       2503      RENV4       renv4;
               mnet.c       2504      UB          sts;
               mnet.c       2505    
               mnet.c       2506      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
               mnet.c       2507      {
               mnet.c       2508          return( result );
               mnet.c       2509      }
               mnet.c       2510      
               mnet.c       2511      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
               mnet.c       2512      {
               mnet.c       2513          memset( &renv4, CLR, sizeof( RENV4 ) );
               mnet.c       2514          
               mnet.c       2515          sts = ( so > 0 ? SET : CLR );
               mnet.c       2516    
               mnet.c       2517          // コンパレータ３の比較カウンタ選択：COUNTER3(汎用・偏差)
               mnet.c       2518          renv4.UNID.BIT.C3C0 = 0;
               mnet.c       2519          renv4.UNID.BIT.C3C1 = sts;
               mnet.c       2520    
               mnet.c       2521          // コンパレータ３の比較方法選択：RCMP3＝比較カウンタ
               mnet.c       2522          renv4.UNID.BIT.C3S0 = sts;
               mnet.c       2523          renv4.UNID.BIT.C3S1 = 0;
               mnet.c       2524          renv4.UNID.BIT.C3S2 = 0;
               mnet.c       2525          renv4.UNID.BIT.C3S3 = 0;
               mnet.c       2526    
               mnet.c       2527          // コンパレータ３条件成立時の処理選択：即停止
               mnet.c       2528          renv4.UNID.BIT.C3D0 = sts;
               mnet.c       2529          renv4.UNID.BIT.C3D1 = 0;
               mnet.c       2530          
               mnet.c       2531          // 9Fh
               mnet.c       2532          if (!SetMotorRegisterInt(dev_no, WRG_RENV4, renv4.UNID.data) )
               mnet.c       2533          {
               mnet.c       2534              result = E_MNT_ACCESS + WRG_RENV4;
               mnet.c       2535          }
               mnet.c       2536      }
               mnet.c       2537      return( result );
               mnet.c       2538    }
               mnet.c       2539    /******************************************************************************
               mnet.c       2540    * 
               mnet.c       2541    * [概要]  RMD 設定( BCD-4020FUA , BCD-4020FU )
               mnet.c       2542    * [引数]  −
               mnet.c       2543    * [戻値]  −
               mnet.c       2544    * 
               mnet.c       2545    ******************************************************************************/
               mnet.c       2546    static ER SetRmdFu( UB dev_no, UB mod )
    00001A70              __$SetRmdFu:                     ; function: __$SetRmdFu
                                                           ; frame size=20
    00001A70 4DF0                   MOVMU.L     R13,@-R15
    00001A72 7FF8                   ADD         #-8,R15
    00001A74 D662                   MOV.L       L629+2,R6  ; _MNET_DRV_TYPE
    00001A76 6E4C                   EXTU.B      R4,R14
    00001A78 60E3                   MOV         R14,R0
    00001A7A 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
               mnet.c       2547    {
               mnet.c       2548      ER          result = E_SUCCESS;
               mnet.c       2549      RMD         rmd;
               mnet.c       2550    
               mnet.c       2551      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )// 圧力ユニット
    00001A7C 880A                   CMP/EQ      #10,R0
    00001A7E 8D27                   BT/S        L605
    00001A80 6D53                   MOV         R5,R13
               mnet.c       2552      {
               mnet.c       2553          return( result );
               mnet.c       2554      }
               mnet.c       2555      
               mnet.c       2556      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    00001A82 8809                   CMP/EQ      #9,R0
    00001A84 8924                   BT          L605
    00001A86 E604                   MOV         #4,R6      ; H'00000004
    00001A88 E500                   MOV         #0,R5      ; H'00000000
               mnet.c       2557      {
               mnet.c       2558          memset( &rmd, CLR, sizeof( RMD ) );
    00001A8A D25E                   MOV.L       L629+6,R2  ; _memset
    00001A8C 420B                   JSR         @R2
    00001A8E 64F3                   MOV         R15,R4
    00001A90 E5D7                   MOV         #-41,R5    ; H'FFFFFFD7
    00001A92 1FE1                   MOV.L       R14,@(4,R15)
    00001A94 655C                   EXTU.B      R5,R5
               mnet.c       2559          
               mnet.c       2560          if (!GetMotorRegister(dev_no, RRG_RMD, &rmd.UNID.data))
    00001A96 64E3                   MOV         R14,R4
    00001A98 BAC6                   BSR         _GetMotorRegister
    00001A9A 66F3                   MOV         R15,R6
    00001A9C 2008                   TST         R0,R0
    00001A9E 000005D7               MOVI20      #1495,R0   ; H'000005D7
    00001AA2 8916                   BT          L608
               mnet.c       2561          {
               mnet.c       2562              return(( E_MNT_ACCESS + RRG_RMD ));
               mnet.c       2563          }
               mnet.c       2564          rmd.UNID.BIT.MOD = mod;
    00001AA4 84F3                   MOV.B       @(3,R15),R0; (part of)rmd
    00001AA6 E180                   MOV         #-128,R1   ; H'FFFFFF80
               mnet.c       2565          rmd.UNID.BIT.MINT = 1;
               mnet.c       2566    
               mnet.c       2567          if (!SetMotorRegisterInt(dev_no, WRG_RMD, rmd.UNID.data))
    00001AA8 54F1                   MOV.L       @(4,R15),R4
    00001AAA E597                   MOV         #-105,R5   ; H'FFFFFF97
    00001AAC 2019                   AND         R1,R0
    00001AAE 6203                   MOV         R0,R2
    00001AB0 60D3                   MOV         R13,R0
    00001AB2 C97F                   AND         #127,R0
    00001AB4 220B                   OR          R0,R2
    00001AB6 655C                   EXTU.B      R5,R5
    00001AB8 3F391001               BSET.B      #3,@(1,R15); (part of)rmd
    00001ABC 6023                   MOV         R2,R0
    00001ABE 80F3                   MOV.B       R0,@(3,R15); (part of)rmd
    00001AC0 BA6D                   BSR         _SetMotorRegisterInt
    00001AC2 66F2                   MOV.L       @R15,R6    ; rmd.UNID.data
    00001AC4 2008                   TST         R0,R0
    00001AC6 8B03                   BF          L605
               mnet.c       2568          {
               mnet.c       2569              return(( E_MNT_ACCESS + WRG_RMD ));
    00001AC8 00000597               MOVI20      #1431,R0   ; H'00000597
    00001ACC A001                   BRA         L608
    00001ACE 0009                   NOP
    00001AD0              L605:
    00001AD0 E000                   MOV         #0,R0      ; H'00000000
    00001AD2              L608:
    00001AD2 7F08                   ADD         #8,R15
    00001AD4 4DF4                   MOVMU.L     @R15+,R13
               mnet.c       2570          }
               mnet.c       2571      }
               mnet.c       2572      return( result );
               mnet.c       2573    }
    00001AD6 006B                   RTS/N
               mnet.c       2574    /******************************************************************************
               mnet.c       2575    * 
               mnet.c       2576    * [概要]  RMV 設定
               mnet.c       2577    * [引数]  −
               mnet.c       2578    * [戻値]  −
               mnet.c       2579    * 
               mnet.c       2580    ******************************************************************************/
               mnet.c       2581    static ER SetRmv( UB dev_no, INT pos )
    00001AD8              __$SetRmv:                       ; function: __$SetRmv
                                                           ; frame size=4
    00001AD8 4F22                   STS.L       PR,@-R15
               mnet.c       2582    {
               mnet.c       2583      ER          result = E_SUCCESS;
               mnet.c       2584    
               mnet.c       2585      if( MNET_DRV_TYPE[dev_no] == NCPRSUNIT )
    00001ADA D649                   MOV.L       L629+2,R6  ; _MNET_DRV_TYPE
    00001ADC 644C                   EXTU.B      R4,R4
    00001ADE 6043                   MOV         R4,R0
    00001AE0 006C                   MOV.B       @(R0,R6),R0; MNET_DRV_TYPE[]
    00001AE2 880A                   CMP/EQ      #10,R0
    00001AE4 890B                   BT          L612
               mnet.c       2586      {
               mnet.c       2587          // 圧力ユニット
               mnet.c       2588          return( result );
               mnet.c       2589      }
               mnet.c       2590      
               mnet.c       2591      if( MNET_DRV_TYPE[dev_no] != PCD4611 )
    00001AE6 8809                   CMP/EQ      #9,R0
    00001AE8 8909                   BT          L612
               mnet.c       2592      {
               mnet.c       2593          if (!SetMotorRegisterInt(dev_no, WRG_RMV, pos))
    00001AEA 6653                   MOV         R5,R6
    00001AEC E590                   MOV         #-112,R5   ; H'FFFFFF90
    00001AEE BA56                   BSR         _SetMotorRegisterInt
    00001AF0 655C                   EXTU.B      R5,R5
    00001AF2 2008                   TST         R0,R0
    00001AF4 8B03                   BF          L612
               mnet.c       2594          {
               mnet.c       2595              return(( E_MNT_ACCESS + WRG_RMV ));
    00001AF6 00000590               MOVI20      #1424,R0   ; H'00000590
    00001AFA A001                   BRA         L615
    00001AFC 0009                   NOP
    00001AFE              L612:
    00001AFE E000                   MOV         #0,R0      ; H'00000000
    00001B00              L615:
    00001B00 4F26                   LDS.L       @R15+,PR
               mnet.c       2596          }
               mnet.c       2597      }
               mnet.c       2598      return( result );
               mnet.c       2599    }
    00001B02 006B                   RTS/N
               mnet.c       2600    /******************************************************************************
               mnet.c       2601    * 
               mnet.c       2602    * [概要]  RMV 設定
               mnet.c       2603    * [引数]  −
               mnet.c       2604    * [戻値]  −
               mnet.c       2605    * 
               mnet.c       2606    ******************************************************************************/
               mnet.c       2607    static ER SetRmvPCD4611( UB dev_no, INT pos )
               mnet.c       2608    {
               mnet.c       2609      WriteMemoryIntPCD4611( pos );
               mnet.c       2610      WriteMemoryPCD4611( WRG_RMV );
               mnet.c       2611    
               mnet.c       2612      return( E_SUCCESS );
               mnet.c       2613    }
               mnet.c       2614    /******************************************************************************
               mnet.c       2615    * 
               mnet.c       2616    * [概要]  RENV1 設定( PCD4611 )
               mnet.c       2617    * [引数]  −
               mnet.c       2618    * [戻値]  −
               mnet.c       2619    * 
               mnet.c       2620    ******************************************************************************/
               mnet.c       2621    static ER SetRenv1PCD4611( UB dev_no )
               mnet.c       2622    {
               mnet.c       2623    
               mnet.c       2624      return( E_SUCCESS );
               mnet.c       2625    }
               mnet.c       2626    
               mnet.c       2627    /******************************************************************************
               mnet.c       2628    * 
               mnet.c       2629    * [概要]  RENV2 設定( PCD4611 )
               mnet.c       2630    * [引数]  −
               mnet.c       2631    * [戻値]  −
               mnet.c       2632    * 
               mnet.c       2633    ******************************************************************************/
               mnet.c       2634    static ER SetRenv2PCD4611()
               mnet.c       2635    {
               mnet.c       2636      WriteMemoryIntPCD4611( 0x00000005 );// EA/EB: A/B相1逓倍, P1〜P0: 汎用出力
               mnet.c       2637      WriteMemoryPCD4611( WPCD_RENV2 );   // 0x9D
               mnet.c       2638    
               mnet.c       2639      return( E_SUCCESS );
               mnet.c       2640    }
               mnet.c       2641    /******************************************************************************
               mnet.c       2642    * 
               mnet.c       2643    * [概要]  RENV3 設定( PCD4611 )
               mnet.c       2644    * [引数]  −
               mnet.c       2645    * [戻値]  −
               mnet.c       2646    * 
               mnet.c       2647    ******************************************************************************/
               mnet.c       2648    static ER SetRenv3PCD4611( UB dev_no, UB enc )
               mnet.c       2649    {
               mnet.c       2650      return( E_SUCCESS );
               mnet.c       2651    }
               mnet.c       2652    /******************************************************************************
               mnet.c       2653    * 
               mnet.c       2654    * [概要]  RMD 設定( PCD4611 )
               mnet.c       2655    * [引数]  −
               mnet.c       2656    * [戻値]  −
               mnet.c       2657    * 
               mnet.c       2658    ******************************************************************************/
               mnet.c       2659    static ER SetRmdPCD4611( UB dev_no, UB mod )
               mnet.c       2660    {
               mnet.c       2661      WriteMemoryIntPCD4611( mod );
               mnet.c       2662      WriteMemoryPCD4611( WPCD_PRMD );
               mnet.c       2663    
               mnet.c       2664      return( E_SUCCESS );
               mnet.c       2665    }
               mnet.c       2666    
               mnet.c       2667    #ifdef DEBUG_INFO
               mnet.c       2668    static    INT dbgread;
               mnet.c       2669    
               mnet.c       2670    /******************************************************************************
               mnet.c       2671    * 
               mnet.c       2672    * [概要]  SBSY状態取得
               mnet.c       2673    * [引数]  −
               mnet.c       2674    * [戻値]  1:ON、0:OFF
               mnet.c       2675    * 
               mnet.c       2676    ******************************************************************************/
               mnet.c       2677    static void DebugMnetInfo( UB mm )
    00001B04              __$DebugMnetInfo:                ; function: __$DebugMnetInfo
                                                           ; frame size=16
    00001B04 4CF0                   MOVMU.L     R12,@-R15
               mnet.c       2678    {
               mnet.c       2679    
               mnet.c       2680      dbgread = 0;
    00001B06 E100                   MOV         #0,R1      ; H'00000000
    00001B08 E5C0                   MOV         #-64,R5    ; H'FFFFFFC0
    00001B0A DE3F                   MOV.L       L629+10,R14; __$dbgread
    00001B0C 2E12                   MOV.L       R1,@R14    ; dbgread
               mnet.c       2681      GetMotorRegister(mm, RRG_PRMV, &dbgread);           //  RRG_PRMV    = 0x00C0,   PRMV レジスタ の読み出し
    00001B0E 6C4C                   EXTU.B      R4,R12
    00001B10 655C                   EXTU.B      R5,R5
    00001B12 66E3                   MOV         R14,R6
    00001B14 6D53                   MOV         R5,R13
    00001B16 7D05                   ADD         #5,R13
    00001B18 BA86                   BSR         _GetMotorRegister
    00001B1A 64C3                   MOV         R12,R4
               mnet.c       2682    
               mnet.c       2683      dbgread = 0;
               mnet.c       2684    //    GetMotorRegister(mm, RRG_PRFL, &dbgread);           //  RRG_PRFL    = 0x00C1,   PRFL レジスタ の読み出し
               mnet.c       2685    //    GetMotorRegister(mm, RRG_PRFH, &dbgread);           //  RRG_PRFH    = 0x00C2,   PRFH レジスタ の読み出し
               mnet.c       2686    //    GetMotorRegister(mm, RRG_PRUR, &dbgread);           //  RRG_PRUR    = 0x00C3,   PRUR レジスタ の読み出し
               mnet.c       2687    //    GetMotorRegister(mm, RRG_PRDR, &dbgread);           //  RRG_PRDR    = 0x00C4,   PRDR レジスタ の読み出し
               mnet.c       2688    
               mnet.c       2689      dbgread = 0;
    00001B1C E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2690      GetMotorRegister(mm, RRG_PRMG, &dbgread);           //  RRG_PRMG    = 0x00C5,   PRMG レジスタ の読み出し
    00001B1E 66E3                   MOV         R14,R6
    00001B20 2E72                   MOV.L       R7,@R14    ; dbgread
    00001B22 64C3                   MOV         R12,R4
    00001B24 65D3                   MOV         R13,R5
    00001B26 BA7F                   BSR         _GetMotorRegister
    00001B28 7D01                   ADD         #1,R13
               mnet.c       2691      dbgread = 0;
    00001B2A E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2692      GetMotorRegister(mm, RRG_PRDP, &dbgread);           //  RRG_PRDP    = 0x00C6,   PRDP レジスタ の読み出し
    00001B2C 66E3                   MOV         R14,R6
    00001B2E 2E12                   MOV.L       R1,@R14    ; dbgread
    00001B30 64C3                   MOV         R12,R4
    00001B32 65D3                   MOV         R13,R5
    00001B34 BA78                   BSR         _GetMotorRegister
    00001B36 7D01                   ADD         #1,R13
               mnet.c       2693      dbgread = 0;
    00001B38 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2694      GetMotorRegister(mm, RRG_PRMD, &dbgread);           //  RRG_PRMD    = 0x00C7,   PRMD レジスタ の読み出し
    00001B3A 66E3                   MOV         R14,R6
    00001B3C 2E72                   MOV.L       R7,@R14    ; dbgread
    00001B3E 64C3                   MOV         R12,R4
    00001B40 65D3                   MOV         R13,R5
    00001B42 BA71                   BSR         _GetMotorRegister
    00001B44 7D02                   ADD         #2,R13
               mnet.c       2695      dbgread = 0;
    00001B46 E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2696      GetMotorRegister(mm, RRG_PRUS, &dbgread);           //  RRG_PRUS    = 0x00C9,   PRUS レジスタ の読み出し
    00001B48 66E3                   MOV         R14,R6
    00001B4A 2E12                   MOV.L       R1,@R14    ; dbgread
    00001B4C 64C3                   MOV         R12,R4
    00001B4E 65D3                   MOV         R13,R5
    00001B50 BA6A                   BSR         _GetMotorRegister
    00001B52 7D01                   ADD         #1,R13
               mnet.c       2697      dbgread = 0;
    00001B54 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2698      GetMotorRegister(mm, RRG_PRDS, &dbgread);           //  RRG_PRDS    = 0x00CA,   PRDS レジスタ の読み出し
    00001B56 66E3                   MOV         R14,R6
    00001B58 2E72                   MOV.L       R7,@R14    ; dbgread
    00001B5A 64C3                   MOV         R12,R4
    00001B5C 65D3                   MOV         R13,R5
    00001B5E BA63                   BSR         _GetMotorRegister
    00001B60 7D06                   ADD         #6,R13
               mnet.c       2699      
               mnet.c       2700      dbgread = 0;
    00001B62 E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2701      GetMotorRegister(mm, RRG_RMV, &dbgread);            //  RRG_RMV     = 0x00D0,   RMV レジスタ の読み出し
    00001B64 66E3                   MOV         R14,R6
    00001B66 2E12                   MOV.L       R1,@R14    ; dbgread
    00001B68 64C3                   MOV         R12,R4
    00001B6A 65D3                   MOV         R13,R5
    00001B6C BA5C                   BSR         _GetMotorRegister
    00001B6E 7D07                   ADD         #7,R13
               mnet.c       2702    //    GetMotorRegister(mm, RRG_RFL, &dbgread);            //  RRG_RFL     = 0x00D1,   RFL レジスタ の読み出し
               mnet.c       2703    //    GetMotorRegister(mm, RRG_RFH, &dbgread);            //  RRG_RFH     = 0x00D2,   RFH レジスタ の読み出し
               mnet.c       2704    //    GetMotorRegister(mm, RRG_RUR, &dbgread);            //  RRG_RUR     = 0x00D3,   RUR レジスタ の読み出し
               mnet.c       2705    //    GetMotorRegister(mm, RRG_RDR, &dbgread);            //  RRG_RDR     = 0x00D4,   RDR レジスタ の読み出し
               mnet.c       2706    //    GetMotorRegister(mm, RRG_RMG, &dbgread);            //  RRG_RMG     = 0x00D5,   RMG レジスタ の読み出し
               mnet.c       2707    //    GetMotorRegister(mm, RRG_RDP, &dbgread);            //  RRG_RDP     = 0x00D6,   RDP レジスタ の読み出し
               mnet.c       2708      dbgread = 0;
    00001B70 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2709      GetMotorRegister(mm, RRG_RMD, &dbgread);            //  RRG_RMD     = 0x00D7,   RMD レジスタ の読み出し
    00001B72 66E3                   MOV         R14,R6
    00001B74 2E72                   MOV.L       R7,@R14    ; dbgread
    00001B76 64C3                   MOV         R12,R4
    00001B78 65D3                   MOV         R13,R5
    00001B7A BA55                   BSR         _GetMotorRegister
    00001B7C 7D05                   ADD         #5,R13
               mnet.c       2710    //    GetMotorRegister(mm, RRG_RUS, &dbgread);            //  RRG_RUS     = 0x00D9,   RUS レジスタ の読み出し
               mnet.c       2711    //    GetMotorRegister(mm, RRG_RDS, &dbgread);            //  RRG_RDS     = 0x00DA,   RDS レジスタ の読み出し
               mnet.c       2712    //    GetMotorRegister(mm, RRG_RFA, &dbgread);            //  RRG_RFA     = 0x00DB,   RFA レジスタ の読み出し
               mnet.c       2713      dbgread = 0;
    00001B7E E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2714      GetMotorRegister(mm, RRG_RENV1, &dbgread);          //  RRG_RENV1   = 0x00DC,   RENV1 レジスタ の読み出し
    00001B80 66E3                   MOV         R14,R6
    00001B82 2E12                   MOV.L       R1,@R14    ; dbgread
    00001B84 64C3                   MOV         R12,R4
    00001B86 65D3                   MOV         R13,R5
    00001B88 BA4E                   BSR         _GetMotorRegister
    00001B8A 7D01                   ADD         #1,R13
               mnet.c       2715      dbgread = 0;
    00001B8C E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2716      GetMotorRegister(mm, RRG_RENV2, &dbgread);          //  RRG_RENV2   = 0x00DD,   RENV2 レジスタ の読み出し
    00001B8E 66E3                   MOV         R14,R6
    00001B90 2E72                   MOV.L       R7,@R14    ; dbgread
    00001B92 64C3                   MOV         R12,R4
    00001B94 65D3                   MOV         R13,R5
    00001B96 BA47                   BSR         _GetMotorRegister
    00001B98 7D01                   ADD         #1,R13
               mnet.c       2717      dbgread = 0;
    00001B9A E100                   MOV         #0,R1      ; H'00000000
               mnet.c       2718      GetMotorRegister(mm, RRG_RENV3, &dbgread);          //  RRG_RENV3   = 0x00DE,   RENV3 レジスタ の読み出し
    00001B9C 66E3                   MOV         R14,R6
    00001B9E 2E12                   MOV.L       R1,@R14    ; dbgread
    00001BA0 64C3                   MOV         R12,R4
    00001BA2 65D3                   MOV         R13,R5
    00001BA4 BA40                   BSR         _GetMotorRegister
    00001BA6 7D01                   ADD         #1,R13
               mnet.c       2719      dbgread = 0;
    00001BA8 E700                   MOV         #0,R7      ; H'00000000
               mnet.c       2720      GetMotorRegister(mm, RRG_RENV4, &dbgread);          //  RRG_RENV4   = 0x00DF,   RENV4 レジスタ の読み出し
    00001BAA 66E3                   MOV         R14,R6
    00001BAC 2E72                   MOV.L       R7,@R14    ; dbgread
    00001BAE 64C3                   MOV         R12,R4
    00001BB0 65D3                   MOV         R13,R5
    00001BB2 BA39                   BSR         _GetMotorRegister
    00001BB4 7D01                   ADD         #1,R13
               mnet.c       2721      dbgread = 0;
    00001BB6 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2722      GetMotorRegister(mm, RRG_RENV5, &dbgread);          //  RRG_RENV5   = 0x00E0,   RENV5 レジスタ の読み出し
    00001BB8 66E3                   MOV         R14,R6
    00001BBA 2E22                   MOV.L       R2,@R14    ; dbgread
    00001BBC 64C3                   MOV         R12,R4
    00001BBE 65D3                   MOV         R13,R5
    00001BC0 BA32                   BSR         _GetMotorRegister
    00001BC2 7D01                   ADD         #1,R13
               mnet.c       2723      dbgread = 0;
    00001BC4 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2724      GetMotorRegister(mm, RRG_RENV6, &dbgread);          //  RRG_RENV6   = 0x00E1,   RENV6 レジスタ の読み出し
    00001BC6 66E3                   MOV         R14,R6
    00001BC8 2E22                   MOV.L       R2,@R14    ; dbgread
    00001BCA 64C3                   MOV         R12,R4
    00001BCC 65D3                   MOV         R13,R5
    00001BCE BA2B                   BSR         _GetMotorRegister
    00001BD0 7D02                   ADD         #2,R13
               mnet.c       2725    //    GetMotorRegister(mm, RRG_RENV7, &dbgread);          //  RRG_RENV7   = 0x00E2,   RENV7 レジスタ の読み出し
               mnet.c       2726      dbgread = 0;
    00001BD2 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2727      GetMotorRegister(mm, RRG_RCUN1, &dbgread);          //  RRG_RCUN1   = 0x00E3,   RCUN1 レジスタ の読み出し
    00001BD4 66E3                   MOV         R14,R6
    00001BD6 2E22                   MOV.L       R2,@R14    ; dbgread
    00001BD8 64C3                   MOV         R12,R4
    00001BDA 65D3                   MOV         R13,R5
    00001BDC BA24                   BSR         _GetMotorRegister
    00001BDE 7D01                   ADD         #1,R13
               mnet.c       2728      dbgread = 0;
    00001BE0 E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2729      GetMotorRegister(mm, RRG_RCUN2, &dbgread);          //  RRG_RCUN2   = 0x00E4,   RCUN2 レジスタ の読み出し
    00001BE2 66E3                   MOV         R14,R6
    00001BE4 2E22                   MOV.L       R2,@R14    ; dbgread
    00001BE6 64C3                   MOV         R12,R4
    00001BE8 65D3                   MOV         R13,R5
    00001BEA BA1D                   BSR         _GetMotorRegister
    00001BEC 7D01                   ADD         #1,R13
               mnet.c       2730      dbgread = 0;
    00001BEE E200                   MOV         #0,R2      ; H'00000000
               mnet.c       2731      GetMotorRegister(mm, RRG_RCUN3, &dbgread);          //  RRG_RCUN3   = 0x00E5,   RCUN3 レジスタ の読み出し
    00001BF0 66E3                   MOV         R14,R6
    00001BF2 2E22                   MOV.L       R2,@R14    ; dbgread
    00001BF4 65D3                   MOV         R13,R5
    00001BF6 64C3                   MOV         R12,R4
    00001BF8 4CF4                   MOVMU.L     @R15+,R12
    00001BFA AA15                   BRA         _GetMotorRegister
    00001BFC 0009                   NOP
    00001BFE              L629:
    00001BFE 00000002               .RES.W      1
    00001C00 <00000000>             .DATA.L     _MNET_DRV_TYPE
    00001C04 <00000000>             .DATA.L     _memset
    00001C08 <00000000>             .DATA.L     __$dbgread
               mnet.c       2732    
               mnet.c       2733    }
               mnet.c       2734    #endif
               mnet.c       2735    
               mnet.c       2736    //    struct
               mnet.c       2737    //    {
               mnet.c       2738    //        UH  BBSY    : 1;    // RENV0(8)= "1" でブレーク通信コマンド（0610h）を発行したとき、
               mnet.c       2739    //                                // ブレーク通信が完了するまで "1" となります。
               mnet.c       2740    //        UH  DBSY    : 1;    // システム通信中、またはデータ通信中に1 になります。
               mnet.c       2741    //        UH  RBSY    : 1;    // リセット処理中に1 になります。
               mnet.c       2742    //        UH  SBSY    : 1;    // サイクリック通信スタート中に1 になります。
               mnet.c       2743    //        UH  reserve2: 1;    // 常に0 になります。
               mnet.c       2744    //        UH  RDBB    : 1;    // データ受信用FIFO に受信データがある時に1 になります。
               mnet.c       2745    //        UH  TDBB    : 1;    // データ送信用FIFO に送信データがある時に1 になります。
               mnet.c       2746    //        UH  REF     : 1;    // 未送信の出力ポートデータがある時1 になります。
               mnet.c       2747    //        UH  reserve1: 1;    // 常に0 になります。
               mnet.c       2748    //        UH  CAER    : 1;    // CPU のアクセスエラーです。
               mnet.c       2749    //        UH  ERAE    : 1;    // ﾛｰｶﾙ側受信処理ｴﾗｰ発生時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2750    //        UH  EDTE    : 1;    // データ通信エラー発生時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2751    //        UH  EIOE    : 1;    // サイクリック通信ｴﾗｰ発生時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2752    //        UH  IOPC    : 1;    // 「入力変化割り込み設定」を1 にセットした入力ポートの状態が変化した時に1 になり、
               mnet.c       2753    //                                // 割り込み信号(INT)を出力します。
               mnet.c       2754    //        UH  BRKF    : 1;    // ブレークフレーム受信時に1 になり、割り込み信号(INT)を出力します。
               mnet.c       2755    //        UH  CEND    : 1;    // データ送信用FIFO 書き込み可能時に1 になります。
               mnet.c       2756    //    }BIT;
               mnet.c       2757    
C   00000000              __$MOTORSPD_TBL:                 ; static: __$MOTORSPD_TBL
    00000000 000007CF00             .DATA.L     H'000007CF,H'000003E7,H'0000018F,H'000000C7,H'00000063,H'00000027,H'00000013,
             0003E70000 +                       H'00000009,H'00000003,H'00000002
             018F000000   
             C700000063   
             0000002700   
             0000130000   
             0009000000   
             0300000002   
    00000028              __$MOTORSPD_TBL_PCD4611:         ; static: __$MOTORSPD_TBL_PCD4611
    00000028 00000F9F00             .DATA.L     H'00000F9F,H'0000095F,H'000004AF,H'00000257,H'000000EF,H'0000003B,H'0000001D,
             00095F0000 +                       H'0000000E,H'00000005,H'00000002
             04AF000002   
             57000000EF   
             0000003B00   
             00001D0000   
             000E000000   
             0500000002   
    00000050              __$LMMOD_TBL:                    ; static: __$LMMOD_TBL
    00000050 2020282222             .DATA.B     H'20,H'20,H'28,H'22,H'22,H'2A
             2A           
D   00000000              __$Initialized:                  ; static: __$Initialized
    00000000 00000000               .DATA.L     H'00000000
C   00000056 00000002               .RES.W      1
    00000058              L648:
    00000058 00000000               .DATA.L     H'00000000
    0000005C 00                     .DATAB.B    36,0
B   00000000              _pMotionnet:                     ; static: pMotionnet
    00000000 00000004               .RES.L      1
    00000004              _pPulseMotor:                    ; static: pPulseMotor
    00000004 00000004               .RES.L      1
    00000008              __$_pmInfo:                      ; static: __$_pmInfo
    00000008 00000004               .RES.L      500
    000007D8              __$factor:                       ; static: __$factor
    000007D8 00000004               .RES.L      1
    000007DC              __$param:                        ; static: __$param
    000007DC 00000004               .RES.L      1
    000007E0              __$RMG:                          ; static: __$RMG
    000007E0 00000004               .RES.L      1
    000007E4              __$RFL:                          ; static: __$RFL
    000007E4 00000004               .RES.L      1
    000007E8              __$RFH:                          ; static: __$RFH
    000007E8 00000004               .RES.L      1
    000007EC              __$RUR:                          ; static: __$RUR
    000007EC 00000004               .RES.L      1
    000007F0              __$RUS:                          ; static: __$RUS
    000007F0 00000004               .RES.L      1
    000007F4              __$RDS:                          ; static: __$RDS
    000007F4 00000004               .RES.L      1
    000007F8              __$pcd_rsts:                     ; static: __$pcd_rsts
    000007F8 00000004               .RES.L      1
    000007FC              __$dev_nowk:                     ; static: __$dev_nowk
    000007FC 00000001               .RES.B      1
    000007FD 00000001               .RES.B      1
    000007FE 00000002               .RES.W      1
    00000800              __$dbgread:                      ; static: __$dbgread
    00000800 00000004               .RES.L      1
SH SERIES C/C++ Compiler (V.9.04.03.000)                                                         07-Sep-2023 20:41:33  PAGE    1


******** STATISTICS INFORMATION ********


********** ERROR INFORMATION ***********

NUMBER OF ERRORS:           0
NUMBER OF WARNINGS:         0




******* SOURCE LINE INFORMATION ********

COMPILED SOURCE LINE:     2757



******* SECTION SIZE INFORMATION *******

PROGRAM  SECTION (P):                                 00001C0C Byte(s)
CONSTANT SECTION (C):                                 00000080 Byte(s)
DATA     SECTION (D):                                 00000004 Byte(s)
BSS      SECTION (B):                                 00000804 Byte(s)

TOTAL PROGRAM  SECTION: 00001C0C Byte(s)
TOTAL CONSTANT SECTION: 00000080 Byte(s)
TOTAL DATA     SECTION: 00000004 Byte(s)
TOTAL BSS      SECTION: 00000804 Byte(s)

    TOTAL PROGRAM SIZE: 00002494 Byte(s)



********** LABEL INFORMATION ***********

NUMBER OF EXTERNAL REFERENCE SYMBOLS:           12
NUMBER OF EXTERNAL DEFINITION SYMBOLS:          33
NUMBER OF INTERNAL/EXTERNAL SYMBOLS:           314



*** COMMAND PARAMETER ***

-subcommand=C:\WorkSpace\QuickGene\Soft_Firm\QuickGene_Project\SHC9\QuickGene_Hew\ROM_Big\mnet.shc
-cpu=sh2a
-include="C:\NORTi\INC","C:\NORTi\INC\Dummy","C:\NORTi\INC","C:\NORTi\LIB"
-object="C:\WorkSpace\QuickGene\Soft_Firm\QuickGene_Project\SHC9\QuickGene_Hew\ROM_Big\mnet.obj"
-debug
-listfile="C:\WorkSpace\QuickGene\Soft_Firm\QuickGene_Project\SHC9\QuickGene_Hew\ROM_Big\mnet.lst"
-show=source,tab=4
-gbr=auto
-chgincpath
-errorpath
"C:\WorkSpace\QuickGene\Soft_Firm\QuickGene_Project\mnet.c"
-global_volatile=0
-opt_range=all
-infinite_loop=0
-del_vacant_loop=0
-struct_alloc=1
-lang=c
-nologo
